
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Rack
 * 
 */
export type Rack = $Result.DefaultSelection<Prisma.$RackPayload>
/**
 * Model Bunch
 * 
 */
export type Bunch = $Result.DefaultSelection<Prisma.$BunchPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model ItemSupplier
 * 
 */
export type ItemSupplier = $Result.DefaultSelection<Prisma.$ItemSupplierPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Fabric
 * 
 */
export type Fabric = $Result.DefaultSelection<Prisma.$FabricPayload>
/**
 * Model FabricOrderList
 * 
 */
export type FabricOrderList = $Result.DefaultSelection<Prisma.$FabricOrderListPayload>
/**
 * Model FinalJacketMeasurement
 * 
 */
export type FinalJacketMeasurement = $Result.DefaultSelection<Prisma.$FinalJacketMeasurementPayload>
/**
 * Model JacketMeasurement
 * 
 */
export type JacketMeasurement = $Result.DefaultSelection<Prisma.$JacketMeasurementPayload>
/**
 * Model FinalPantMeasurement
 * 
 */
export type FinalPantMeasurement = $Result.DefaultSelection<Prisma.$FinalPantMeasurementPayload>
/**
 * Model PantMeasurement
 * 
 */
export type PantMeasurement = $Result.DefaultSelection<Prisma.$PantMeasurementPayload>
/**
 * Model FinalShirtMeasurement
 * 
 */
export type FinalShirtMeasurement = $Result.DefaultSelection<Prisma.$FinalShirtMeasurementPayload>
/**
 * Model ShirtMeasurement
 * 
 */
export type ShirtMeasurement = $Result.DefaultSelection<Prisma.$ShirtMeasurementPayload>
/**
 * Model OrderPhotos
 * 
 */
export type OrderPhotos = $Result.DefaultSelection<Prisma.$OrderPhotosPayload>
/**
 * Model Orders
 * 
 */
export type Orders = $Result.DefaultSelection<Prisma.$OrdersPayload>
/**
 * Model Items
 * 
 */
export type Items = $Result.DefaultSelection<Prisma.$ItemsPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Tailor
 * 
 */
export type Tailor = $Result.DefaultSelection<Prisma.$TailorPayload>
/**
 * Model OrderTailor
 * 
 */
export type OrderTailor = $Result.DefaultSelection<Prisma.$OrderTailorPayload>
/**
 * Model RawMaterialsOrderList
 * 
 */
export type RawMaterialsOrderList = $Result.DefaultSelection<Prisma.$RawMaterialsOrderListPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LogEntry
 * 
 */
export type LogEntry = $Result.DefaultSelection<Prisma.$LogEntryPayload>
/**
 * Model OrderProduction
 * 
 */
export type OrderProduction = $Result.DefaultSelection<Prisma.$OrderProductionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MovementType: {
  IN: 'IN',
  OUT: 'OUT',
  TRANSFER: 'TRANSFER',
  ADJUSTMENT: 'ADJUSTMENT'
};

export type MovementType = (typeof MovementType)[keyof typeof MovementType]


export const InventoryItemType: {
  FABRIC: 'FABRIC',
  RAW_MATERIAL: 'RAW_MATERIAL',
  PACKAGING_MATERIAL: 'PACKAGING_MATERIAL'
};

export type InventoryItemType = (typeof InventoryItemType)[keyof typeof InventoryItemType]


export const ItemType: {
  SHIRT: 'SHIRT',
  JACKET: 'JACKET',
  PANT: 'PANT'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const ProductionStatus: {
  PATTERN_CUTTING_PENDING: 'PATTERN_CUTTING_PENDING',
  TAILOR_ASSIGNMENT_PENDING: 'TAILOR_ASSIGNMENT_PENDING',
  BASE_SUIT_PRODUCTION: 'BASE_SUIT_PRODUCTION',
  TRIAL_PENDING: 'TRIAL_PENDING',
  FINAL_PRODUCTION: 'FINAL_PRODUCTION',
  FINAL_FITTING_PENDING: 'FINAL_FITTING_PENDING',
  DELIVERY_PENDING: 'DELIVERY_PENDING',
  DELIVERED: 'DELIVERED'
};

export type ProductionStatus = (typeof ProductionStatus)[keyof typeof ProductionStatus]


export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  FLOOR_MANAGER: 'FLOOR_MANAGER',
  INVENTORY_MANAGER: 'INVENTORY_MANAGER'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type MovementType = $Enums.MovementType

export const MovementType: typeof $Enums.MovementType

export type InventoryItemType = $Enums.InventoryItemType

export const InventoryItemType: typeof $Enums.InventoryItemType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type ProductionStatus = $Enums.ProductionStatus

export const ProductionStatus: typeof $Enums.ProductionStatus

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Locations
 * const locations = await prisma.location.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Locations
   * const locations = await prisma.location.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rack`: Exposes CRUD operations for the **Rack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Racks
    * const racks = await prisma.rack.findMany()
    * ```
    */
  get rack(): Prisma.RackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bunch`: Exposes CRUD operations for the **Bunch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bunches
    * const bunches = await prisma.bunch.findMany()
    * ```
    */
  get bunch(): Prisma.BunchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemSupplier`: Exposes CRUD operations for the **ItemSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemSuppliers
    * const itemSuppliers = await prisma.itemSupplier.findMany()
    * ```
    */
  get itemSupplier(): Prisma.ItemSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fabric`: Exposes CRUD operations for the **Fabric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fabrics
    * const fabrics = await prisma.fabric.findMany()
    * ```
    */
  get fabric(): Prisma.FabricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fabricOrderList`: Exposes CRUD operations for the **FabricOrderList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FabricOrderLists
    * const fabricOrderLists = await prisma.fabricOrderList.findMany()
    * ```
    */
  get fabricOrderList(): Prisma.FabricOrderListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finalJacketMeasurement`: Exposes CRUD operations for the **FinalJacketMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinalJacketMeasurements
    * const finalJacketMeasurements = await prisma.finalJacketMeasurement.findMany()
    * ```
    */
  get finalJacketMeasurement(): Prisma.FinalJacketMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jacketMeasurement`: Exposes CRUD operations for the **JacketMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JacketMeasurements
    * const jacketMeasurements = await prisma.jacketMeasurement.findMany()
    * ```
    */
  get jacketMeasurement(): Prisma.JacketMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finalPantMeasurement`: Exposes CRUD operations for the **FinalPantMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinalPantMeasurements
    * const finalPantMeasurements = await prisma.finalPantMeasurement.findMany()
    * ```
    */
  get finalPantMeasurement(): Prisma.FinalPantMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pantMeasurement`: Exposes CRUD operations for the **PantMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PantMeasurements
    * const pantMeasurements = await prisma.pantMeasurement.findMany()
    * ```
    */
  get pantMeasurement(): Prisma.PantMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finalShirtMeasurement`: Exposes CRUD operations for the **FinalShirtMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinalShirtMeasurements
    * const finalShirtMeasurements = await prisma.finalShirtMeasurement.findMany()
    * ```
    */
  get finalShirtMeasurement(): Prisma.FinalShirtMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shirtMeasurement`: Exposes CRUD operations for the **ShirtMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShirtMeasurements
    * const shirtMeasurements = await prisma.shirtMeasurement.findMany()
    * ```
    */
  get shirtMeasurement(): Prisma.ShirtMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderPhotos`: Exposes CRUD operations for the **OrderPhotos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderPhotos
    * const orderPhotos = await prisma.orderPhotos.findMany()
    * ```
    */
  get orderPhotos(): Prisma.OrderPhotosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **Items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.ItemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tailor`: Exposes CRUD operations for the **Tailor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tailors
    * const tailors = await prisma.tailor.findMany()
    * ```
    */
  get tailor(): Prisma.TailorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderTailor`: Exposes CRUD operations for the **OrderTailor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderTailors
    * const orderTailors = await prisma.orderTailor.findMany()
    * ```
    */
  get orderTailor(): Prisma.OrderTailorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rawMaterialsOrderList`: Exposes CRUD operations for the **RawMaterialsOrderList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RawMaterialsOrderLists
    * const rawMaterialsOrderLists = await prisma.rawMaterialsOrderList.findMany()
    * ```
    */
  get rawMaterialsOrderList(): Prisma.RawMaterialsOrderListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logEntry`: Exposes CRUD operations for the **LogEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogEntries
    * const logEntries = await prisma.logEntry.findMany()
    * ```
    */
  get logEntry(): Prisma.LogEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderProduction`: Exposes CRUD operations for the **OrderProduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderProductions
    * const orderProductions = await prisma.orderProduction.findMany()
    * ```
    */
  get orderProduction(): Prisma.OrderProductionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Location: 'Location',
    Rack: 'Rack',
    Bunch: 'Bunch',
    Unit: 'Unit',
    InventoryMovement: 'InventoryMovement',
    ItemSupplier: 'ItemSupplier',
    InventoryItem: 'InventoryItem',
    Customer: 'Customer',
    Fabric: 'Fabric',
    FabricOrderList: 'FabricOrderList',
    FinalJacketMeasurement: 'FinalJacketMeasurement',
    JacketMeasurement: 'JacketMeasurement',
    FinalPantMeasurement: 'FinalPantMeasurement',
    PantMeasurement: 'PantMeasurement',
    FinalShirtMeasurement: 'FinalShirtMeasurement',
    ShirtMeasurement: 'ShirtMeasurement',
    OrderPhotos: 'OrderPhotos',
    Orders: 'Orders',
    Items: 'Items',
    Supplier: 'Supplier',
    Tailor: 'Tailor',
    OrderTailor: 'OrderTailor',
    RawMaterialsOrderList: 'RawMaterialsOrderList',
    User: 'User',
    LogEntry: 'LogEntry',
    OrderProduction: 'OrderProduction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "location" | "rack" | "bunch" | "unit" | "inventoryMovement" | "itemSupplier" | "inventoryItem" | "customer" | "fabric" | "fabricOrderList" | "finalJacketMeasurement" | "jacketMeasurement" | "finalPantMeasurement" | "pantMeasurement" | "finalShirtMeasurement" | "shirtMeasurement" | "orderPhotos" | "orders" | "items" | "supplier" | "tailor" | "orderTailor" | "rawMaterialsOrderList" | "user" | "logEntry" | "orderProduction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Rack: {
        payload: Prisma.$RackPayload<ExtArgs>
        fields: Prisma.RackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          findFirst: {
            args: Prisma.RackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          findMany: {
            args: Prisma.RackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>[]
          }
          create: {
            args: Prisma.RackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          createMany: {
            args: Prisma.RackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>[]
          }
          delete: {
            args: Prisma.RackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          update: {
            args: Prisma.RackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          deleteMany: {
            args: Prisma.RackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>[]
          }
          upsert: {
            args: Prisma.RackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RackPayload>
          }
          aggregate: {
            args: Prisma.RackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRack>
          }
          groupBy: {
            args: Prisma.RackGroupByArgs<ExtArgs>
            result: $Utils.Optional<RackGroupByOutputType>[]
          }
          count: {
            args: Prisma.RackCountArgs<ExtArgs>
            result: $Utils.Optional<RackCountAggregateOutputType> | number
          }
        }
      }
      Bunch: {
        payload: Prisma.$BunchPayload<ExtArgs>
        fields: Prisma.BunchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BunchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BunchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>
          }
          findFirst: {
            args: Prisma.BunchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BunchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>
          }
          findMany: {
            args: Prisma.BunchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>[]
          }
          create: {
            args: Prisma.BunchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>
          }
          createMany: {
            args: Prisma.BunchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BunchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>[]
          }
          delete: {
            args: Prisma.BunchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>
          }
          update: {
            args: Prisma.BunchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>
          }
          deleteMany: {
            args: Prisma.BunchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BunchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BunchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>[]
          }
          upsert: {
            args: Prisma.BunchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BunchPayload>
          }
          aggregate: {
            args: Prisma.BunchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBunch>
          }
          groupBy: {
            args: Prisma.BunchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BunchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BunchCountArgs<ExtArgs>
            result: $Utils.Optional<BunchCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      ItemSupplier: {
        payload: Prisma.$ItemSupplierPayload<ExtArgs>
        fields: Prisma.ItemSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          findFirst: {
            args: Prisma.ItemSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          findMany: {
            args: Prisma.ItemSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>[]
          }
          create: {
            args: Prisma.ItemSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          createMany: {
            args: Prisma.ItemSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>[]
          }
          delete: {
            args: Prisma.ItemSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          update: {
            args: Prisma.ItemSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          deleteMany: {
            args: Prisma.ItemSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>[]
          }
          upsert: {
            args: Prisma.ItemSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemSupplierPayload>
          }
          aggregate: {
            args: Prisma.ItemSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemSupplier>
          }
          groupBy: {
            args: Prisma.ItemSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<ItemSupplierCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Fabric: {
        payload: Prisma.$FabricPayload<ExtArgs>
        fields: Prisma.FabricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FabricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FabricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>
          }
          findFirst: {
            args: Prisma.FabricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FabricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>
          }
          findMany: {
            args: Prisma.FabricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>[]
          }
          create: {
            args: Prisma.FabricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>
          }
          createMany: {
            args: Prisma.FabricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FabricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>[]
          }
          delete: {
            args: Prisma.FabricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>
          }
          update: {
            args: Prisma.FabricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>
          }
          deleteMany: {
            args: Prisma.FabricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FabricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FabricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>[]
          }
          upsert: {
            args: Prisma.FabricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricPayload>
          }
          aggregate: {
            args: Prisma.FabricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFabric>
          }
          groupBy: {
            args: Prisma.FabricGroupByArgs<ExtArgs>
            result: $Utils.Optional<FabricGroupByOutputType>[]
          }
          count: {
            args: Prisma.FabricCountArgs<ExtArgs>
            result: $Utils.Optional<FabricCountAggregateOutputType> | number
          }
        }
      }
      FabricOrderList: {
        payload: Prisma.$FabricOrderListPayload<ExtArgs>
        fields: Prisma.FabricOrderListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FabricOrderListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FabricOrderListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>
          }
          findFirst: {
            args: Prisma.FabricOrderListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FabricOrderListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>
          }
          findMany: {
            args: Prisma.FabricOrderListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>[]
          }
          create: {
            args: Prisma.FabricOrderListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>
          }
          createMany: {
            args: Prisma.FabricOrderListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FabricOrderListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>[]
          }
          delete: {
            args: Prisma.FabricOrderListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>
          }
          update: {
            args: Prisma.FabricOrderListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>
          }
          deleteMany: {
            args: Prisma.FabricOrderListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FabricOrderListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FabricOrderListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>[]
          }
          upsert: {
            args: Prisma.FabricOrderListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FabricOrderListPayload>
          }
          aggregate: {
            args: Prisma.FabricOrderListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFabricOrderList>
          }
          groupBy: {
            args: Prisma.FabricOrderListGroupByArgs<ExtArgs>
            result: $Utils.Optional<FabricOrderListGroupByOutputType>[]
          }
          count: {
            args: Prisma.FabricOrderListCountArgs<ExtArgs>
            result: $Utils.Optional<FabricOrderListCountAggregateOutputType> | number
          }
        }
      }
      FinalJacketMeasurement: {
        payload: Prisma.$FinalJacketMeasurementPayload<ExtArgs>
        fields: Prisma.FinalJacketMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinalJacketMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinalJacketMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>
          }
          findFirst: {
            args: Prisma.FinalJacketMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinalJacketMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>
          }
          findMany: {
            args: Prisma.FinalJacketMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>[]
          }
          create: {
            args: Prisma.FinalJacketMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>
          }
          createMany: {
            args: Prisma.FinalJacketMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinalJacketMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>[]
          }
          delete: {
            args: Prisma.FinalJacketMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>
          }
          update: {
            args: Prisma.FinalJacketMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.FinalJacketMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinalJacketMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinalJacketMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.FinalJacketMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalJacketMeasurementPayload>
          }
          aggregate: {
            args: Prisma.FinalJacketMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinalJacketMeasurement>
          }
          groupBy: {
            args: Prisma.FinalJacketMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinalJacketMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinalJacketMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<FinalJacketMeasurementCountAggregateOutputType> | number
          }
        }
      }
      JacketMeasurement: {
        payload: Prisma.$JacketMeasurementPayload<ExtArgs>
        fields: Prisma.JacketMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JacketMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JacketMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>
          }
          findFirst: {
            args: Prisma.JacketMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JacketMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>
          }
          findMany: {
            args: Prisma.JacketMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>[]
          }
          create: {
            args: Prisma.JacketMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>
          }
          createMany: {
            args: Prisma.JacketMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JacketMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>[]
          }
          delete: {
            args: Prisma.JacketMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>
          }
          update: {
            args: Prisma.JacketMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.JacketMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JacketMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JacketMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.JacketMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JacketMeasurementPayload>
          }
          aggregate: {
            args: Prisma.JacketMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJacketMeasurement>
          }
          groupBy: {
            args: Prisma.JacketMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<JacketMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.JacketMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<JacketMeasurementCountAggregateOutputType> | number
          }
        }
      }
      FinalPantMeasurement: {
        payload: Prisma.$FinalPantMeasurementPayload<ExtArgs>
        fields: Prisma.FinalPantMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinalPantMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinalPantMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>
          }
          findFirst: {
            args: Prisma.FinalPantMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinalPantMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>
          }
          findMany: {
            args: Prisma.FinalPantMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>[]
          }
          create: {
            args: Prisma.FinalPantMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>
          }
          createMany: {
            args: Prisma.FinalPantMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinalPantMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>[]
          }
          delete: {
            args: Prisma.FinalPantMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>
          }
          update: {
            args: Prisma.FinalPantMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.FinalPantMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinalPantMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinalPantMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.FinalPantMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalPantMeasurementPayload>
          }
          aggregate: {
            args: Prisma.FinalPantMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinalPantMeasurement>
          }
          groupBy: {
            args: Prisma.FinalPantMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinalPantMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinalPantMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<FinalPantMeasurementCountAggregateOutputType> | number
          }
        }
      }
      PantMeasurement: {
        payload: Prisma.$PantMeasurementPayload<ExtArgs>
        fields: Prisma.PantMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PantMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PantMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>
          }
          findFirst: {
            args: Prisma.PantMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PantMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>
          }
          findMany: {
            args: Prisma.PantMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>[]
          }
          create: {
            args: Prisma.PantMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>
          }
          createMany: {
            args: Prisma.PantMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PantMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>[]
          }
          delete: {
            args: Prisma.PantMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>
          }
          update: {
            args: Prisma.PantMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.PantMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PantMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PantMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.PantMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PantMeasurementPayload>
          }
          aggregate: {
            args: Prisma.PantMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePantMeasurement>
          }
          groupBy: {
            args: Prisma.PantMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PantMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PantMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<PantMeasurementCountAggregateOutputType> | number
          }
        }
      }
      FinalShirtMeasurement: {
        payload: Prisma.$FinalShirtMeasurementPayload<ExtArgs>
        fields: Prisma.FinalShirtMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinalShirtMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinalShirtMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>
          }
          findFirst: {
            args: Prisma.FinalShirtMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinalShirtMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>
          }
          findMany: {
            args: Prisma.FinalShirtMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>[]
          }
          create: {
            args: Prisma.FinalShirtMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>
          }
          createMany: {
            args: Prisma.FinalShirtMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinalShirtMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>[]
          }
          delete: {
            args: Prisma.FinalShirtMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>
          }
          update: {
            args: Prisma.FinalShirtMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.FinalShirtMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinalShirtMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinalShirtMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.FinalShirtMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalShirtMeasurementPayload>
          }
          aggregate: {
            args: Prisma.FinalShirtMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinalShirtMeasurement>
          }
          groupBy: {
            args: Prisma.FinalShirtMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinalShirtMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinalShirtMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<FinalShirtMeasurementCountAggregateOutputType> | number
          }
        }
      }
      ShirtMeasurement: {
        payload: Prisma.$ShirtMeasurementPayload<ExtArgs>
        fields: Prisma.ShirtMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShirtMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShirtMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>
          }
          findFirst: {
            args: Prisma.ShirtMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShirtMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>
          }
          findMany: {
            args: Prisma.ShirtMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>[]
          }
          create: {
            args: Prisma.ShirtMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>
          }
          createMany: {
            args: Prisma.ShirtMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShirtMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>[]
          }
          delete: {
            args: Prisma.ShirtMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>
          }
          update: {
            args: Prisma.ShirtMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.ShirtMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShirtMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShirtMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.ShirtMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShirtMeasurementPayload>
          }
          aggregate: {
            args: Prisma.ShirtMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShirtMeasurement>
          }
          groupBy: {
            args: Prisma.ShirtMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShirtMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShirtMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<ShirtMeasurementCountAggregateOutputType> | number
          }
        }
      }
      OrderPhotos: {
        payload: Prisma.$OrderPhotosPayload<ExtArgs>
        fields: Prisma.OrderPhotosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderPhotosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderPhotosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>
          }
          findFirst: {
            args: Prisma.OrderPhotosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderPhotosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>
          }
          findMany: {
            args: Prisma.OrderPhotosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>[]
          }
          create: {
            args: Prisma.OrderPhotosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>
          }
          createMany: {
            args: Prisma.OrderPhotosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderPhotosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>[]
          }
          delete: {
            args: Prisma.OrderPhotosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>
          }
          update: {
            args: Prisma.OrderPhotosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>
          }
          deleteMany: {
            args: Prisma.OrderPhotosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderPhotosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderPhotosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>[]
          }
          upsert: {
            args: Prisma.OrderPhotosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPhotosPayload>
          }
          aggregate: {
            args: Prisma.OrderPhotosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderPhotos>
          }
          groupBy: {
            args: Prisma.OrderPhotosGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderPhotosGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderPhotosCountArgs<ExtArgs>
            result: $Utils.Optional<OrderPhotosCountAggregateOutputType> | number
          }
        }
      }
      Orders: {
        payload: Prisma.$OrdersPayload<ExtArgs>
        fields: Prisma.OrdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findFirst: {
            args: Prisma.OrdersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findMany: {
            args: Prisma.OrdersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          create: {
            args: Prisma.OrdersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          createMany: {
            args: Prisma.OrdersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          delete: {
            args: Prisma.OrdersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          update: {
            args: Prisma.OrdersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          deleteMany: {
            args: Prisma.OrdersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrdersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          upsert: {
            args: Prisma.OrdersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.OrdersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      Items: {
        payload: Prisma.$ItemsPayload<ExtArgs>
        fields: Prisma.ItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          findFirst: {
            args: Prisma.ItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          findMany: {
            args: Prisma.ItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>[]
          }
          create: {
            args: Prisma.ItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          createMany: {
            args: Prisma.ItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>[]
          }
          delete: {
            args: Prisma.ItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          update: {
            args: Prisma.ItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          deleteMany: {
            args: Prisma.ItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>[]
          }
          upsert: {
            args: Prisma.ItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.ItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemsCountArgs<ExtArgs>
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Tailor: {
        payload: Prisma.$TailorPayload<ExtArgs>
        fields: Prisma.TailorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          findFirst: {
            args: Prisma.TailorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          findMany: {
            args: Prisma.TailorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>[]
          }
          create: {
            args: Prisma.TailorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          createMany: {
            args: Prisma.TailorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>[]
          }
          delete: {
            args: Prisma.TailorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          update: {
            args: Prisma.TailorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          deleteMany: {
            args: Prisma.TailorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TailorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>[]
          }
          upsert: {
            args: Prisma.TailorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          aggregate: {
            args: Prisma.TailorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailor>
          }
          groupBy: {
            args: Prisma.TailorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailorCountArgs<ExtArgs>
            result: $Utils.Optional<TailorCountAggregateOutputType> | number
          }
        }
      }
      OrderTailor: {
        payload: Prisma.$OrderTailorPayload<ExtArgs>
        fields: Prisma.OrderTailorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderTailorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderTailorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>
          }
          findFirst: {
            args: Prisma.OrderTailorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderTailorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>
          }
          findMany: {
            args: Prisma.OrderTailorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>[]
          }
          create: {
            args: Prisma.OrderTailorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>
          }
          createMany: {
            args: Prisma.OrderTailorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderTailorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>[]
          }
          delete: {
            args: Prisma.OrderTailorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>
          }
          update: {
            args: Prisma.OrderTailorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>
          }
          deleteMany: {
            args: Prisma.OrderTailorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderTailorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderTailorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>[]
          }
          upsert: {
            args: Prisma.OrderTailorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTailorPayload>
          }
          aggregate: {
            args: Prisma.OrderTailorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderTailor>
          }
          groupBy: {
            args: Prisma.OrderTailorGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderTailorGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderTailorCountArgs<ExtArgs>
            result: $Utils.Optional<OrderTailorCountAggregateOutputType> | number
          }
        }
      }
      RawMaterialsOrderList: {
        payload: Prisma.$RawMaterialsOrderListPayload<ExtArgs>
        fields: Prisma.RawMaterialsOrderListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RawMaterialsOrderListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RawMaterialsOrderListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>
          }
          findFirst: {
            args: Prisma.RawMaterialsOrderListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RawMaterialsOrderListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>
          }
          findMany: {
            args: Prisma.RawMaterialsOrderListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>[]
          }
          create: {
            args: Prisma.RawMaterialsOrderListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>
          }
          createMany: {
            args: Prisma.RawMaterialsOrderListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RawMaterialsOrderListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>[]
          }
          delete: {
            args: Prisma.RawMaterialsOrderListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>
          }
          update: {
            args: Prisma.RawMaterialsOrderListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>
          }
          deleteMany: {
            args: Prisma.RawMaterialsOrderListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RawMaterialsOrderListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RawMaterialsOrderListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>[]
          }
          upsert: {
            args: Prisma.RawMaterialsOrderListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RawMaterialsOrderListPayload>
          }
          aggregate: {
            args: Prisma.RawMaterialsOrderListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRawMaterialsOrderList>
          }
          groupBy: {
            args: Prisma.RawMaterialsOrderListGroupByArgs<ExtArgs>
            result: $Utils.Optional<RawMaterialsOrderListGroupByOutputType>[]
          }
          count: {
            args: Prisma.RawMaterialsOrderListCountArgs<ExtArgs>
            result: $Utils.Optional<RawMaterialsOrderListCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LogEntry: {
        payload: Prisma.$LogEntryPayload<ExtArgs>
        fields: Prisma.LogEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          findFirst: {
            args: Prisma.LogEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          findMany: {
            args: Prisma.LogEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>[]
          }
          create: {
            args: Prisma.LogEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          createMany: {
            args: Prisma.LogEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>[]
          }
          delete: {
            args: Prisma.LogEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          update: {
            args: Prisma.LogEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          deleteMany: {
            args: Prisma.LogEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>[]
          }
          upsert: {
            args: Prisma.LogEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          aggregate: {
            args: Prisma.LogEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogEntry>
          }
          groupBy: {
            args: Prisma.LogEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LogEntryCountAggregateOutputType> | number
          }
        }
      }
      OrderProduction: {
        payload: Prisma.$OrderProductionPayload<ExtArgs>
        fields: Prisma.OrderProductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderProductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderProductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>
          }
          findFirst: {
            args: Prisma.OrderProductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderProductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>
          }
          findMany: {
            args: Prisma.OrderProductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>[]
          }
          create: {
            args: Prisma.OrderProductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>
          }
          createMany: {
            args: Prisma.OrderProductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderProductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>[]
          }
          delete: {
            args: Prisma.OrderProductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>
          }
          update: {
            args: Prisma.OrderProductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>
          }
          deleteMany: {
            args: Prisma.OrderProductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderProductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderProductionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>[]
          }
          upsert: {
            args: Prisma.OrderProductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductionPayload>
          }
          aggregate: {
            args: Prisma.OrderProductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderProduction>
          }
          groupBy: {
            args: Prisma.OrderProductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderProductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderProductionCountArgs<ExtArgs>
            result: $Utils.Optional<OrderProductionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    location?: LocationOmit
    rack?: RackOmit
    bunch?: BunchOmit
    unit?: UnitOmit
    inventoryMovement?: InventoryMovementOmit
    itemSupplier?: ItemSupplierOmit
    inventoryItem?: InventoryItemOmit
    customer?: CustomerOmit
    fabric?: FabricOmit
    fabricOrderList?: FabricOrderListOmit
    finalJacketMeasurement?: FinalJacketMeasurementOmit
    jacketMeasurement?: JacketMeasurementOmit
    finalPantMeasurement?: FinalPantMeasurementOmit
    pantMeasurement?: PantMeasurementOmit
    finalShirtMeasurement?: FinalShirtMeasurementOmit
    shirtMeasurement?: ShirtMeasurementOmit
    orderPhotos?: OrderPhotosOmit
    orders?: OrdersOmit
    items?: ItemsOmit
    supplier?: SupplierOmit
    tailor?: TailorOmit
    orderTailor?: OrderTailorOmit
    rawMaterialsOrderList?: RawMaterialsOrderListOmit
    user?: UserOmit
    logEntry?: LogEntryOmit
    orderProduction?: OrderProductionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    racks: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    racks?: boolean | LocationCountOutputTypeCountRacksArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RackWhereInput
  }


  /**
   * Count Type RackCountOutputType
   */

  export type RackCountOutputType = {
    bunches: number
  }

  export type RackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bunches?: boolean | RackCountOutputTypeCountBunchesArgs
  }

  // Custom InputTypes
  /**
   * RackCountOutputType without action
   */
  export type RackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RackCountOutputType
     */
    select?: RackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RackCountOutputType without action
   */
  export type RackCountOutputTypeCountBunchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BunchWhereInput
  }


  /**
   * Count Type BunchCountOutputType
   */

  export type BunchCountOutputType = {
    items: number
  }

  export type BunchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BunchCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * BunchCountOutputType without action
   */
  export type BunchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BunchCountOutputType
     */
    select?: BunchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BunchCountOutputType without action
   */
  export type BunchCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    items: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | UnitCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    suppliers: number
    movement_logs: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | InventoryItemCountOutputTypeCountSuppliersArgs
    movement_logs?: boolean | InventoryItemCountOutputTypeCountMovement_logsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSupplierWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountMovement_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    measurements: number
    FinalPantMeasurement: number
    FinalShirtMeasurement: number
    JacketMeasurement: number
    PantMeasurement: number
    ShirtMeasurement: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    measurements?: boolean | CustomerCountOutputTypeCountMeasurementsArgs
    FinalPantMeasurement?: boolean | CustomerCountOutputTypeCountFinalPantMeasurementArgs
    FinalShirtMeasurement?: boolean | CustomerCountOutputTypeCountFinalShirtMeasurementArgs
    JacketMeasurement?: boolean | CustomerCountOutputTypeCountJacketMeasurementArgs
    PantMeasurement?: boolean | CustomerCountOutputTypeCountPantMeasurementArgs
    ShirtMeasurement?: boolean | CustomerCountOutputTypeCountShirtMeasurementArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalJacketMeasurementWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountFinalPantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalPantMeasurementWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountFinalShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalShirtMeasurementWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountJacketMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JacketMeasurementWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PantMeasurementWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShirtMeasurementWhereInput
  }


  /**
   * Count Type FabricCountOutputType
   */

  export type FabricCountOutputType = {
    fabricOrders: number
    items: number
    liningItems: number
  }

  export type FabricCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fabricOrders?: boolean | FabricCountOutputTypeCountFabricOrdersArgs
    items?: boolean | FabricCountOutputTypeCountItemsArgs
    liningItems?: boolean | FabricCountOutputTypeCountLiningItemsArgs
  }

  // Custom InputTypes
  /**
   * FabricCountOutputType without action
   */
  export type FabricCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricCountOutputType
     */
    select?: FabricCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FabricCountOutputType without action
   */
  export type FabricCountOutputTypeCountFabricOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FabricOrderListWhereInput
  }

  /**
   * FabricCountOutputType without action
   */
  export type FabricCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }

  /**
   * FabricCountOutputType without action
   */
  export type FabricCountOutputTypeCountLiningItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type FinalJacketMeasurementCountOutputType
   */

  export type FinalJacketMeasurementCountOutputType = {
    Items: number
  }

  export type FinalJacketMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Items?: boolean | FinalJacketMeasurementCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FinalJacketMeasurementCountOutputType without action
   */
  export type FinalJacketMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurementCountOutputType
     */
    select?: FinalJacketMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinalJacketMeasurementCountOutputType without action
   */
  export type FinalJacketMeasurementCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type JacketMeasurementCountOutputType
   */

  export type JacketMeasurementCountOutputType = {
    Items: number
  }

  export type JacketMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Items?: boolean | JacketMeasurementCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * JacketMeasurementCountOutputType without action
   */
  export type JacketMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurementCountOutputType
     */
    select?: JacketMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JacketMeasurementCountOutputType without action
   */
  export type JacketMeasurementCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type FinalPantMeasurementCountOutputType
   */

  export type FinalPantMeasurementCountOutputType = {
    Items: number
  }

  export type FinalPantMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Items?: boolean | FinalPantMeasurementCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FinalPantMeasurementCountOutputType without action
   */
  export type FinalPantMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurementCountOutputType
     */
    select?: FinalPantMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinalPantMeasurementCountOutputType without action
   */
  export type FinalPantMeasurementCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type PantMeasurementCountOutputType
   */

  export type PantMeasurementCountOutputType = {
    Items: number
  }

  export type PantMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Items?: boolean | PantMeasurementCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PantMeasurementCountOutputType without action
   */
  export type PantMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurementCountOutputType
     */
    select?: PantMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PantMeasurementCountOutputType without action
   */
  export type PantMeasurementCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type FinalShirtMeasurementCountOutputType
   */

  export type FinalShirtMeasurementCountOutputType = {
    Items: number
  }

  export type FinalShirtMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Items?: boolean | FinalShirtMeasurementCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FinalShirtMeasurementCountOutputType without action
   */
  export type FinalShirtMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurementCountOutputType
     */
    select?: FinalShirtMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FinalShirtMeasurementCountOutputType without action
   */
  export type FinalShirtMeasurementCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type ShirtMeasurementCountOutputType
   */

  export type ShirtMeasurementCountOutputType = {
    Items: number
  }

  export type ShirtMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Items?: boolean | ShirtMeasurementCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ShirtMeasurementCountOutputType without action
   */
  export type ShirtMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurementCountOutputType
     */
    select?: ShirtMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShirtMeasurementCountOutputType without action
   */
  export type ShirtMeasurementCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    items: number
    FinalJacketMeasurement: number
    FinalPantMeasurement: number
    FinalShirtMeasurement: number
    JacketMeasurement: number
    PantMeasurement: number
    ShirtMeasurement: number
    OrderPhotos: number
    tailors: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrdersCountOutputTypeCountItemsArgs
    FinalJacketMeasurement?: boolean | OrdersCountOutputTypeCountFinalJacketMeasurementArgs
    FinalPantMeasurement?: boolean | OrdersCountOutputTypeCountFinalPantMeasurementArgs
    FinalShirtMeasurement?: boolean | OrdersCountOutputTypeCountFinalShirtMeasurementArgs
    JacketMeasurement?: boolean | OrdersCountOutputTypeCountJacketMeasurementArgs
    PantMeasurement?: boolean | OrdersCountOutputTypeCountPantMeasurementArgs
    ShirtMeasurement?: boolean | OrdersCountOutputTypeCountShirtMeasurementArgs
    OrderPhotos?: boolean | OrdersCountOutputTypeCountOrderPhotosArgs
    tailors?: boolean | OrdersCountOutputTypeCountTailorsArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountFinalJacketMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalJacketMeasurementWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountFinalPantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalPantMeasurementWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountFinalShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalShirtMeasurementWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountJacketMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JacketMeasurementWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountPantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PantMeasurementWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShirtMeasurementWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrderPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderPhotosWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountTailorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTailorWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    FabricOrderList: number
    RawMaterialsOrderList: number
    ItemSupplier: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FabricOrderList?: boolean | SupplierCountOutputTypeCountFabricOrderListArgs
    RawMaterialsOrderList?: boolean | SupplierCountOutputTypeCountRawMaterialsOrderListArgs
    ItemSupplier?: boolean | SupplierCountOutputTypeCountItemSupplierArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountFabricOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FabricOrderListWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountRawMaterialsOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawMaterialsOrderListWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountItemSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSupplierWhereInput
  }


  /**
   * Count Type TailorCountOutputType
   */

  export type TailorCountOutputType = {
    orders: number
  }

  export type TailorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | TailorCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * TailorCountOutputType without action
   */
  export type TailorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorCountOutputType
     */
    select?: TailorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TailorCountOutputType without action
   */
  export type TailorCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTailorWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    logs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | UserCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    racks?: boolean | Location$racksArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    racks?: boolean | Location$racksArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      racks: Prisma.$RackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    racks<T extends Location$racksArgs<ExtArgs> = {}>(args?: Subset<T, Location$racksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly name: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.racks
   */
  export type Location$racksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    where?: RackWhereInput
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    cursor?: RackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Rack
   */

  export type AggregateRack = {
    _count: RackCountAggregateOutputType | null
    _avg: RackAvgAggregateOutputType | null
    _sum: RackSumAggregateOutputType | null
    _min: RackMinAggregateOutputType | null
    _max: RackMaxAggregateOutputType | null
  }

  export type RackAvgAggregateOutputType = {
    id: number | null
    location_id: number | null
    capacity: number | null
    current_utilization: number | null
  }

  export type RackSumAggregateOutputType = {
    id: number | null
    location_id: number | null
    capacity: number | null
    current_utilization: number | null
  }

  export type RackMinAggregateOutputType = {
    id: number | null
    name: string | null
    location_id: number | null
    capacity: number | null
    current_utilization: number | null
    createdAt: Date | null
  }

  export type RackMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location_id: number | null
    capacity: number | null
    current_utilization: number | null
    createdAt: Date | null
  }

  export type RackCountAggregateOutputType = {
    id: number
    name: number
    location_id: number
    capacity: number
    current_utilization: number
    createdAt: number
    _all: number
  }


  export type RackAvgAggregateInputType = {
    id?: true
    location_id?: true
    capacity?: true
    current_utilization?: true
  }

  export type RackSumAggregateInputType = {
    id?: true
    location_id?: true
    capacity?: true
    current_utilization?: true
  }

  export type RackMinAggregateInputType = {
    id?: true
    name?: true
    location_id?: true
    capacity?: true
    current_utilization?: true
    createdAt?: true
  }

  export type RackMaxAggregateInputType = {
    id?: true
    name?: true
    location_id?: true
    capacity?: true
    current_utilization?: true
    createdAt?: true
  }

  export type RackCountAggregateInputType = {
    id?: true
    name?: true
    location_id?: true
    capacity?: true
    current_utilization?: true
    createdAt?: true
    _all?: true
  }

  export type RackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rack to aggregate.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Racks
    **/
    _count?: true | RackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RackMaxAggregateInputType
  }

  export type GetRackAggregateType<T extends RackAggregateArgs> = {
        [P in keyof T & keyof AggregateRack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRack[P]>
      : GetScalarType<T[P], AggregateRack[P]>
  }




  export type RackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RackWhereInput
    orderBy?: RackOrderByWithAggregationInput | RackOrderByWithAggregationInput[]
    by: RackScalarFieldEnum[] | RackScalarFieldEnum
    having?: RackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RackCountAggregateInputType | true
    _avg?: RackAvgAggregateInputType
    _sum?: RackSumAggregateInputType
    _min?: RackMinAggregateInputType
    _max?: RackMaxAggregateInputType
  }

  export type RackGroupByOutputType = {
    id: number
    name: string
    location_id: number
    capacity: number
    current_utilization: number
    createdAt: Date
    _count: RackCountAggregateOutputType | null
    _avg: RackAvgAggregateOutputType | null
    _sum: RackSumAggregateOutputType | null
    _min: RackMinAggregateOutputType | null
    _max: RackMaxAggregateOutputType | null
  }

  type GetRackGroupByPayload<T extends RackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RackGroupByOutputType[P]>
            : GetScalarType<T[P], RackGroupByOutputType[P]>
        }
      >
    >


  export type RackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location_id?: boolean
    capacity?: boolean
    current_utilization?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    bunches?: boolean | Rack$bunchesArgs<ExtArgs>
    _count?: boolean | RackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rack"]>

  export type RackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location_id?: boolean
    capacity?: boolean
    current_utilization?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rack"]>

  export type RackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location_id?: boolean
    capacity?: boolean
    current_utilization?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rack"]>

  export type RackSelectScalar = {
    id?: boolean
    name?: boolean
    location_id?: boolean
    capacity?: boolean
    current_utilization?: boolean
    createdAt?: boolean
  }

  export type RackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location_id" | "capacity" | "current_utilization" | "createdAt", ExtArgs["result"]["rack"]>
  export type RackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    bunches?: boolean | Rack$bunchesArgs<ExtArgs>
    _count?: boolean | RackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type RackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $RackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rack"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      bunches: Prisma.$BunchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location_id: number
      capacity: number
      current_utilization: number
      createdAt: Date
    }, ExtArgs["result"]["rack"]>
    composites: {}
  }

  type RackGetPayload<S extends boolean | null | undefined | RackDefaultArgs> = $Result.GetResult<Prisma.$RackPayload, S>

  type RackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RackCountAggregateInputType | true
    }

  export interface RackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rack'], meta: { name: 'Rack' } }
    /**
     * Find zero or one Rack that matches the filter.
     * @param {RackFindUniqueArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RackFindUniqueArgs>(args: SelectSubset<T, RackFindUniqueArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RackFindUniqueOrThrowArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RackFindUniqueOrThrowArgs>(args: SelectSubset<T, RackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackFindFirstArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RackFindFirstArgs>(args?: SelectSubset<T, RackFindFirstArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackFindFirstOrThrowArgs} args - Arguments to find a Rack
     * @example
     * // Get one Rack
     * const rack = await prisma.rack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RackFindFirstOrThrowArgs>(args?: SelectSubset<T, RackFindFirstOrThrowArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Racks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Racks
     * const racks = await prisma.rack.findMany()
     * 
     * // Get first 10 Racks
     * const racks = await prisma.rack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rackWithIdOnly = await prisma.rack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RackFindManyArgs>(args?: SelectSubset<T, RackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rack.
     * @param {RackCreateArgs} args - Arguments to create a Rack.
     * @example
     * // Create one Rack
     * const Rack = await prisma.rack.create({
     *   data: {
     *     // ... data to create a Rack
     *   }
     * })
     * 
     */
    create<T extends RackCreateArgs>(args: SelectSubset<T, RackCreateArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Racks.
     * @param {RackCreateManyArgs} args - Arguments to create many Racks.
     * @example
     * // Create many Racks
     * const rack = await prisma.rack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RackCreateManyArgs>(args?: SelectSubset<T, RackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Racks and returns the data saved in the database.
     * @param {RackCreateManyAndReturnArgs} args - Arguments to create many Racks.
     * @example
     * // Create many Racks
     * const rack = await prisma.rack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Racks and only return the `id`
     * const rackWithIdOnly = await prisma.rack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RackCreateManyAndReturnArgs>(args?: SelectSubset<T, RackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rack.
     * @param {RackDeleteArgs} args - Arguments to delete one Rack.
     * @example
     * // Delete one Rack
     * const Rack = await prisma.rack.delete({
     *   where: {
     *     // ... filter to delete one Rack
     *   }
     * })
     * 
     */
    delete<T extends RackDeleteArgs>(args: SelectSubset<T, RackDeleteArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rack.
     * @param {RackUpdateArgs} args - Arguments to update one Rack.
     * @example
     * // Update one Rack
     * const rack = await prisma.rack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RackUpdateArgs>(args: SelectSubset<T, RackUpdateArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Racks.
     * @param {RackDeleteManyArgs} args - Arguments to filter Racks to delete.
     * @example
     * // Delete a few Racks
     * const { count } = await prisma.rack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RackDeleteManyArgs>(args?: SelectSubset<T, RackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Racks
     * const rack = await prisma.rack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RackUpdateManyArgs>(args: SelectSubset<T, RackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Racks and returns the data updated in the database.
     * @param {RackUpdateManyAndReturnArgs} args - Arguments to update many Racks.
     * @example
     * // Update many Racks
     * const rack = await prisma.rack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Racks and only return the `id`
     * const rackWithIdOnly = await prisma.rack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RackUpdateManyAndReturnArgs>(args: SelectSubset<T, RackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rack.
     * @param {RackUpsertArgs} args - Arguments to update or create a Rack.
     * @example
     * // Update or create a Rack
     * const rack = await prisma.rack.upsert({
     *   create: {
     *     // ... data to create a Rack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rack we want to update
     *   }
     * })
     */
    upsert<T extends RackUpsertArgs>(args: SelectSubset<T, RackUpsertArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Racks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackCountArgs} args - Arguments to filter Racks to count.
     * @example
     * // Count the number of Racks
     * const count = await prisma.rack.count({
     *   where: {
     *     // ... the filter for the Racks we want to count
     *   }
     * })
    **/
    count<T extends RackCountArgs>(
      args?: Subset<T, RackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RackAggregateArgs>(args: Subset<T, RackAggregateArgs>): Prisma.PrismaPromise<GetRackAggregateType<T>>

    /**
     * Group by Rack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RackGroupByArgs['orderBy'] }
        : { orderBy?: RackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rack model
   */
  readonly fields: RackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bunches<T extends Rack$bunchesArgs<ExtArgs> = {}>(args?: Subset<T, Rack$bunchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rack model
   */
  interface RackFieldRefs {
    readonly id: FieldRef<"Rack", 'Int'>
    readonly name: FieldRef<"Rack", 'String'>
    readonly location_id: FieldRef<"Rack", 'Int'>
    readonly capacity: FieldRef<"Rack", 'Int'>
    readonly current_utilization: FieldRef<"Rack", 'Int'>
    readonly createdAt: FieldRef<"Rack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rack findUnique
   */
  export type RackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack findUniqueOrThrow
   */
  export type RackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack findFirst
   */
  export type RackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Racks.
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Racks.
     */
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Rack findFirstOrThrow
   */
  export type RackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Rack to fetch.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Racks.
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Racks.
     */
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Rack findMany
   */
  export type RackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter, which Racks to fetch.
     */
    where?: RackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Racks to fetch.
     */
    orderBy?: RackOrderByWithRelationInput | RackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Racks.
     */
    cursor?: RackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Racks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Racks.
     */
    skip?: number
    distinct?: RackScalarFieldEnum | RackScalarFieldEnum[]
  }

  /**
   * Rack create
   */
  export type RackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * The data needed to create a Rack.
     */
    data: XOR<RackCreateInput, RackUncheckedCreateInput>
  }

  /**
   * Rack createMany
   */
  export type RackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Racks.
     */
    data: RackCreateManyInput | RackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rack createManyAndReturn
   */
  export type RackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * The data used to create many Racks.
     */
    data: RackCreateManyInput | RackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rack update
   */
  export type RackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * The data needed to update a Rack.
     */
    data: XOR<RackUpdateInput, RackUncheckedUpdateInput>
    /**
     * Choose, which Rack to update.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack updateMany
   */
  export type RackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Racks.
     */
    data: XOR<RackUpdateManyMutationInput, RackUncheckedUpdateManyInput>
    /**
     * Filter which Racks to update
     */
    where?: RackWhereInput
    /**
     * Limit how many Racks to update.
     */
    limit?: number
  }

  /**
   * Rack updateManyAndReturn
   */
  export type RackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * The data used to update Racks.
     */
    data: XOR<RackUpdateManyMutationInput, RackUncheckedUpdateManyInput>
    /**
     * Filter which Racks to update
     */
    where?: RackWhereInput
    /**
     * Limit how many Racks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rack upsert
   */
  export type RackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * The filter to search for the Rack to update in case it exists.
     */
    where: RackWhereUniqueInput
    /**
     * In case the Rack found by the `where` argument doesn't exist, create a new Rack with this data.
     */
    create: XOR<RackCreateInput, RackUncheckedCreateInput>
    /**
     * In case the Rack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RackUpdateInput, RackUncheckedUpdateInput>
  }

  /**
   * Rack delete
   */
  export type RackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
    /**
     * Filter which Rack to delete.
     */
    where: RackWhereUniqueInput
  }

  /**
   * Rack deleteMany
   */
  export type RackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Racks to delete
     */
    where?: RackWhereInput
    /**
     * Limit how many Racks to delete.
     */
    limit?: number
  }

  /**
   * Rack.bunches
   */
  export type Rack$bunchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    where?: BunchWhereInput
    orderBy?: BunchOrderByWithRelationInput | BunchOrderByWithRelationInput[]
    cursor?: BunchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BunchScalarFieldEnum | BunchScalarFieldEnum[]
  }

  /**
   * Rack without action
   */
  export type RackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack
     */
    select?: RackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rack
     */
    omit?: RackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RackInclude<ExtArgs> | null
  }


  /**
   * Model Bunch
   */

  export type AggregateBunch = {
    _count: BunchCountAggregateOutputType | null
    _avg: BunchAvgAggregateOutputType | null
    _sum: BunchSumAggregateOutputType | null
    _min: BunchMinAggregateOutputType | null
    _max: BunchMaxAggregateOutputType | null
  }

  export type BunchAvgAggregateOutputType = {
    id: number | null
    rack_id: number | null
  }

  export type BunchSumAggregateOutputType = {
    id: number | null
    rack_id: number | null
  }

  export type BunchMinAggregateOutputType = {
    id: number | null
    name: string | null
    rack_id: number | null
    createdAt: Date | null
  }

  export type BunchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    rack_id: number | null
    createdAt: Date | null
  }

  export type BunchCountAggregateOutputType = {
    id: number
    name: number
    rack_id: number
    createdAt: number
    _all: number
  }


  export type BunchAvgAggregateInputType = {
    id?: true
    rack_id?: true
  }

  export type BunchSumAggregateInputType = {
    id?: true
    rack_id?: true
  }

  export type BunchMinAggregateInputType = {
    id?: true
    name?: true
    rack_id?: true
    createdAt?: true
  }

  export type BunchMaxAggregateInputType = {
    id?: true
    name?: true
    rack_id?: true
    createdAt?: true
  }

  export type BunchCountAggregateInputType = {
    id?: true
    name?: true
    rack_id?: true
    createdAt?: true
    _all?: true
  }

  export type BunchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bunch to aggregate.
     */
    where?: BunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bunches to fetch.
     */
    orderBy?: BunchOrderByWithRelationInput | BunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bunches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bunches
    **/
    _count?: true | BunchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BunchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BunchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BunchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BunchMaxAggregateInputType
  }

  export type GetBunchAggregateType<T extends BunchAggregateArgs> = {
        [P in keyof T & keyof AggregateBunch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBunch[P]>
      : GetScalarType<T[P], AggregateBunch[P]>
  }




  export type BunchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BunchWhereInput
    orderBy?: BunchOrderByWithAggregationInput | BunchOrderByWithAggregationInput[]
    by: BunchScalarFieldEnum[] | BunchScalarFieldEnum
    having?: BunchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BunchCountAggregateInputType | true
    _avg?: BunchAvgAggregateInputType
    _sum?: BunchSumAggregateInputType
    _min?: BunchMinAggregateInputType
    _max?: BunchMaxAggregateInputType
  }

  export type BunchGroupByOutputType = {
    id: number
    name: string
    rack_id: number
    createdAt: Date
    _count: BunchCountAggregateOutputType | null
    _avg: BunchAvgAggregateOutputType | null
    _sum: BunchSumAggregateOutputType | null
    _min: BunchMinAggregateOutputType | null
    _max: BunchMaxAggregateOutputType | null
  }

  type GetBunchGroupByPayload<T extends BunchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BunchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BunchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BunchGroupByOutputType[P]>
            : GetScalarType<T[P], BunchGroupByOutputType[P]>
        }
      >
    >


  export type BunchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rack_id?: boolean
    createdAt?: boolean
    rack?: boolean | RackDefaultArgs<ExtArgs>
    items?: boolean | Bunch$itemsArgs<ExtArgs>
    _count?: boolean | BunchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bunch"]>

  export type BunchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rack_id?: boolean
    createdAt?: boolean
    rack?: boolean | RackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bunch"]>

  export type BunchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rack_id?: boolean
    createdAt?: boolean
    rack?: boolean | RackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bunch"]>

  export type BunchSelectScalar = {
    id?: boolean
    name?: boolean
    rack_id?: boolean
    createdAt?: boolean
  }

  export type BunchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "rack_id" | "createdAt", ExtArgs["result"]["bunch"]>
  export type BunchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rack?: boolean | RackDefaultArgs<ExtArgs>
    items?: boolean | Bunch$itemsArgs<ExtArgs>
    _count?: boolean | BunchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BunchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rack?: boolean | RackDefaultArgs<ExtArgs>
  }
  export type BunchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rack?: boolean | RackDefaultArgs<ExtArgs>
  }

  export type $BunchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bunch"
    objects: {
      rack: Prisma.$RackPayload<ExtArgs>
      items: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      rack_id: number
      createdAt: Date
    }, ExtArgs["result"]["bunch"]>
    composites: {}
  }

  type BunchGetPayload<S extends boolean | null | undefined | BunchDefaultArgs> = $Result.GetResult<Prisma.$BunchPayload, S>

  type BunchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BunchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BunchCountAggregateInputType | true
    }

  export interface BunchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bunch'], meta: { name: 'Bunch' } }
    /**
     * Find zero or one Bunch that matches the filter.
     * @param {BunchFindUniqueArgs} args - Arguments to find a Bunch
     * @example
     * // Get one Bunch
     * const bunch = await prisma.bunch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BunchFindUniqueArgs>(args: SelectSubset<T, BunchFindUniqueArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bunch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BunchFindUniqueOrThrowArgs} args - Arguments to find a Bunch
     * @example
     * // Get one Bunch
     * const bunch = await prisma.bunch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BunchFindUniqueOrThrowArgs>(args: SelectSubset<T, BunchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bunch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchFindFirstArgs} args - Arguments to find a Bunch
     * @example
     * // Get one Bunch
     * const bunch = await prisma.bunch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BunchFindFirstArgs>(args?: SelectSubset<T, BunchFindFirstArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bunch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchFindFirstOrThrowArgs} args - Arguments to find a Bunch
     * @example
     * // Get one Bunch
     * const bunch = await prisma.bunch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BunchFindFirstOrThrowArgs>(args?: SelectSubset<T, BunchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bunches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bunches
     * const bunches = await prisma.bunch.findMany()
     * 
     * // Get first 10 Bunches
     * const bunches = await prisma.bunch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bunchWithIdOnly = await prisma.bunch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BunchFindManyArgs>(args?: SelectSubset<T, BunchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bunch.
     * @param {BunchCreateArgs} args - Arguments to create a Bunch.
     * @example
     * // Create one Bunch
     * const Bunch = await prisma.bunch.create({
     *   data: {
     *     // ... data to create a Bunch
     *   }
     * })
     * 
     */
    create<T extends BunchCreateArgs>(args: SelectSubset<T, BunchCreateArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bunches.
     * @param {BunchCreateManyArgs} args - Arguments to create many Bunches.
     * @example
     * // Create many Bunches
     * const bunch = await prisma.bunch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BunchCreateManyArgs>(args?: SelectSubset<T, BunchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bunches and returns the data saved in the database.
     * @param {BunchCreateManyAndReturnArgs} args - Arguments to create many Bunches.
     * @example
     * // Create many Bunches
     * const bunch = await prisma.bunch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bunches and only return the `id`
     * const bunchWithIdOnly = await prisma.bunch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BunchCreateManyAndReturnArgs>(args?: SelectSubset<T, BunchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bunch.
     * @param {BunchDeleteArgs} args - Arguments to delete one Bunch.
     * @example
     * // Delete one Bunch
     * const Bunch = await prisma.bunch.delete({
     *   where: {
     *     // ... filter to delete one Bunch
     *   }
     * })
     * 
     */
    delete<T extends BunchDeleteArgs>(args: SelectSubset<T, BunchDeleteArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bunch.
     * @param {BunchUpdateArgs} args - Arguments to update one Bunch.
     * @example
     * // Update one Bunch
     * const bunch = await prisma.bunch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BunchUpdateArgs>(args: SelectSubset<T, BunchUpdateArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bunches.
     * @param {BunchDeleteManyArgs} args - Arguments to filter Bunches to delete.
     * @example
     * // Delete a few Bunches
     * const { count } = await prisma.bunch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BunchDeleteManyArgs>(args?: SelectSubset<T, BunchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bunches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bunches
     * const bunch = await prisma.bunch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BunchUpdateManyArgs>(args: SelectSubset<T, BunchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bunches and returns the data updated in the database.
     * @param {BunchUpdateManyAndReturnArgs} args - Arguments to update many Bunches.
     * @example
     * // Update many Bunches
     * const bunch = await prisma.bunch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bunches and only return the `id`
     * const bunchWithIdOnly = await prisma.bunch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BunchUpdateManyAndReturnArgs>(args: SelectSubset<T, BunchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bunch.
     * @param {BunchUpsertArgs} args - Arguments to update or create a Bunch.
     * @example
     * // Update or create a Bunch
     * const bunch = await prisma.bunch.upsert({
     *   create: {
     *     // ... data to create a Bunch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bunch we want to update
     *   }
     * })
     */
    upsert<T extends BunchUpsertArgs>(args: SelectSubset<T, BunchUpsertArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bunches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchCountArgs} args - Arguments to filter Bunches to count.
     * @example
     * // Count the number of Bunches
     * const count = await prisma.bunch.count({
     *   where: {
     *     // ... the filter for the Bunches we want to count
     *   }
     * })
    **/
    count<T extends BunchCountArgs>(
      args?: Subset<T, BunchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BunchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bunch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BunchAggregateArgs>(args: Subset<T, BunchAggregateArgs>): Prisma.PrismaPromise<GetBunchAggregateType<T>>

    /**
     * Group by Bunch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BunchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BunchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BunchGroupByArgs['orderBy'] }
        : { orderBy?: BunchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BunchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBunchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bunch model
   */
  readonly fields: BunchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bunch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BunchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rack<T extends RackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RackDefaultArgs<ExtArgs>>): Prisma__RackClient<$Result.GetResult<Prisma.$RackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Bunch$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Bunch$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bunch model
   */
  interface BunchFieldRefs {
    readonly id: FieldRef<"Bunch", 'Int'>
    readonly name: FieldRef<"Bunch", 'String'>
    readonly rack_id: FieldRef<"Bunch", 'Int'>
    readonly createdAt: FieldRef<"Bunch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bunch findUnique
   */
  export type BunchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * Filter, which Bunch to fetch.
     */
    where: BunchWhereUniqueInput
  }

  /**
   * Bunch findUniqueOrThrow
   */
  export type BunchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * Filter, which Bunch to fetch.
     */
    where: BunchWhereUniqueInput
  }

  /**
   * Bunch findFirst
   */
  export type BunchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * Filter, which Bunch to fetch.
     */
    where?: BunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bunches to fetch.
     */
    orderBy?: BunchOrderByWithRelationInput | BunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bunches.
     */
    cursor?: BunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bunches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bunches.
     */
    distinct?: BunchScalarFieldEnum | BunchScalarFieldEnum[]
  }

  /**
   * Bunch findFirstOrThrow
   */
  export type BunchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * Filter, which Bunch to fetch.
     */
    where?: BunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bunches to fetch.
     */
    orderBy?: BunchOrderByWithRelationInput | BunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bunches.
     */
    cursor?: BunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bunches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bunches.
     */
    distinct?: BunchScalarFieldEnum | BunchScalarFieldEnum[]
  }

  /**
   * Bunch findMany
   */
  export type BunchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * Filter, which Bunches to fetch.
     */
    where?: BunchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bunches to fetch.
     */
    orderBy?: BunchOrderByWithRelationInput | BunchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bunches.
     */
    cursor?: BunchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bunches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bunches.
     */
    skip?: number
    distinct?: BunchScalarFieldEnum | BunchScalarFieldEnum[]
  }

  /**
   * Bunch create
   */
  export type BunchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * The data needed to create a Bunch.
     */
    data: XOR<BunchCreateInput, BunchUncheckedCreateInput>
  }

  /**
   * Bunch createMany
   */
  export type BunchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bunches.
     */
    data: BunchCreateManyInput | BunchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bunch createManyAndReturn
   */
  export type BunchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * The data used to create many Bunches.
     */
    data: BunchCreateManyInput | BunchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bunch update
   */
  export type BunchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * The data needed to update a Bunch.
     */
    data: XOR<BunchUpdateInput, BunchUncheckedUpdateInput>
    /**
     * Choose, which Bunch to update.
     */
    where: BunchWhereUniqueInput
  }

  /**
   * Bunch updateMany
   */
  export type BunchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bunches.
     */
    data: XOR<BunchUpdateManyMutationInput, BunchUncheckedUpdateManyInput>
    /**
     * Filter which Bunches to update
     */
    where?: BunchWhereInput
    /**
     * Limit how many Bunches to update.
     */
    limit?: number
  }

  /**
   * Bunch updateManyAndReturn
   */
  export type BunchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * The data used to update Bunches.
     */
    data: XOR<BunchUpdateManyMutationInput, BunchUncheckedUpdateManyInput>
    /**
     * Filter which Bunches to update
     */
    where?: BunchWhereInput
    /**
     * Limit how many Bunches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bunch upsert
   */
  export type BunchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * The filter to search for the Bunch to update in case it exists.
     */
    where: BunchWhereUniqueInput
    /**
     * In case the Bunch found by the `where` argument doesn't exist, create a new Bunch with this data.
     */
    create: XOR<BunchCreateInput, BunchUncheckedCreateInput>
    /**
     * In case the Bunch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BunchUpdateInput, BunchUncheckedUpdateInput>
  }

  /**
   * Bunch delete
   */
  export type BunchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    /**
     * Filter which Bunch to delete.
     */
    where: BunchWhereUniqueInput
  }

  /**
   * Bunch deleteMany
   */
  export type BunchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bunches to delete
     */
    where?: BunchWhereInput
    /**
     * Limit how many Bunches to delete.
     */
    limit?: number
  }

  /**
   * Bunch.items
   */
  export type Bunch$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Bunch without action
   */
  export type BunchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
    conversion_rate: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
    conversion_rate: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    name: string | null
    symbol: string | null
    baseUnit: string | null
    conversion_rate: number | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    symbol: string | null
    baseUnit: string | null
    conversion_rate: number | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    baseUnit: number
    conversion_rate: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
    conversion_rate?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
    conversion_rate?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    baseUnit?: true
    conversion_rate?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    baseUnit?: true
    conversion_rate?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    baseUnit?: true
    conversion_rate?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    name: string
    symbol: string
    baseUnit: string | null
    conversion_rate: number | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    baseUnit?: boolean
    conversion_rate?: boolean
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    baseUnit?: boolean
    conversion_rate?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    baseUnit?: boolean
    conversion_rate?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    baseUnit?: boolean
    conversion_rate?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "baseUnit" | "conversion_rate", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      items: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      symbol: string
      baseUnit: string | null
      conversion_rate: number | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Unit$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly symbol: FieldRef<"Unit", 'String'>
    readonly baseUnit: FieldRef<"Unit", 'String'>
    readonly conversion_rate: FieldRef<"Unit", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.items
   */
  export type Unit$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: number | null
    item_id: string | null
    type: $Enums.MovementType | null
    quantity: number | null
    note: string | null
    moved_at: Date | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: number | null
    item_id: string | null
    type: $Enums.MovementType | null
    quantity: number | null
    note: string | null
    moved_at: Date | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    item_id: number
    type: number
    quantity: number
    note: number
    moved_at: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    item_id?: true
    type?: true
    quantity?: true
    note?: true
    moved_at?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    item_id?: true
    type?: true
    quantity?: true
    note?: true
    moved_at?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    item_id?: true
    type?: true
    quantity?: true
    note?: true
    moved_at?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: number
    item_id: string
    type: $Enums.MovementType
    quantity: number
    note: string | null
    moved_at: Date
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    type?: boolean
    quantity?: boolean
    note?: boolean
    moved_at?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    type?: boolean
    quantity?: boolean
    note?: boolean
    moved_at?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    type?: boolean
    quantity?: boolean
    note?: boolean
    moved_at?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    item_id?: boolean
    type?: boolean
    quantity?: boolean
    note?: boolean
    moved_at?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_id" | "type" | "quantity" | "note" | "moved_at", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      item: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_id: string
      type: $Enums.MovementType
      quantity: number
      note: string | null
      moved_at: Date
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements and returns the data updated in the database.
     * @param {InventoryMovementUpdateManyAndReturnArgs} args - Arguments to update many InventoryMovements.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'Int'>
    readonly item_id: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'MovementType'>
    readonly quantity: FieldRef<"InventoryMovement", 'Float'>
    readonly note: FieldRef<"InventoryMovement", 'String'>
    readonly moved_at: FieldRef<"InventoryMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement updateManyAndReturn
   */
  export type InventoryMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model ItemSupplier
   */

  export type AggregateItemSupplier = {
    _count: ItemSupplierCountAggregateOutputType | null
    _avg: ItemSupplierAvgAggregateOutputType | null
    _sum: ItemSupplierSumAggregateOutputType | null
    _min: ItemSupplierMinAggregateOutputType | null
    _max: ItemSupplierMaxAggregateOutputType | null
  }

  export type ItemSupplierAvgAggregateOutputType = {
    id: number | null
    supplier_id: number | null
    price: Decimal | null
  }

  export type ItemSupplierSumAggregateOutputType = {
    id: number | null
    supplier_id: number | null
    price: Decimal | null
  }

  export type ItemSupplierMinAggregateOutputType = {
    id: number | null
    item_id: string | null
    supplier_id: number | null
    price: Decimal | null
    added_on: Date | null
  }

  export type ItemSupplierMaxAggregateOutputType = {
    id: number | null
    item_id: string | null
    supplier_id: number | null
    price: Decimal | null
    added_on: Date | null
  }

  export type ItemSupplierCountAggregateOutputType = {
    id: number
    item_id: number
    supplier_id: number
    price: number
    added_on: number
    _all: number
  }


  export type ItemSupplierAvgAggregateInputType = {
    id?: true
    supplier_id?: true
    price?: true
  }

  export type ItemSupplierSumAggregateInputType = {
    id?: true
    supplier_id?: true
    price?: true
  }

  export type ItemSupplierMinAggregateInputType = {
    id?: true
    item_id?: true
    supplier_id?: true
    price?: true
    added_on?: true
  }

  export type ItemSupplierMaxAggregateInputType = {
    id?: true
    item_id?: true
    supplier_id?: true
    price?: true
    added_on?: true
  }

  export type ItemSupplierCountAggregateInputType = {
    id?: true
    item_id?: true
    supplier_id?: true
    price?: true
    added_on?: true
    _all?: true
  }

  export type ItemSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSupplier to aggregate.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemSuppliers
    **/
    _count?: true | ItemSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemSupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemSupplierMaxAggregateInputType
  }

  export type GetItemSupplierAggregateType<T extends ItemSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateItemSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemSupplier[P]>
      : GetScalarType<T[P], AggregateItemSupplier[P]>
  }




  export type ItemSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemSupplierWhereInput
    orderBy?: ItemSupplierOrderByWithAggregationInput | ItemSupplierOrderByWithAggregationInput[]
    by: ItemSupplierScalarFieldEnum[] | ItemSupplierScalarFieldEnum
    having?: ItemSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemSupplierCountAggregateInputType | true
    _avg?: ItemSupplierAvgAggregateInputType
    _sum?: ItemSupplierSumAggregateInputType
    _min?: ItemSupplierMinAggregateInputType
    _max?: ItemSupplierMaxAggregateInputType
  }

  export type ItemSupplierGroupByOutputType = {
    id: number
    item_id: string
    supplier_id: number
    price: Decimal | null
    added_on: Date
    _count: ItemSupplierCountAggregateOutputType | null
    _avg: ItemSupplierAvgAggregateOutputType | null
    _sum: ItemSupplierSumAggregateOutputType | null
    _min: ItemSupplierMinAggregateOutputType | null
    _max: ItemSupplierMaxAggregateOutputType | null
  }

  type GetItemSupplierGroupByPayload<T extends ItemSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], ItemSupplierGroupByOutputType[P]>
        }
      >
    >


  export type ItemSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    supplier_id?: boolean
    price?: boolean
    added_on?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSupplier"]>

  export type ItemSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    supplier_id?: boolean
    price?: boolean
    added_on?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSupplier"]>

  export type ItemSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    supplier_id?: boolean
    price?: boolean
    added_on?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemSupplier"]>

  export type ItemSupplierSelectScalar = {
    id?: boolean
    item_id?: boolean
    supplier_id?: boolean
    price?: boolean
    added_on?: boolean
  }

  export type ItemSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_id" | "supplier_id" | "price" | "added_on", ExtArgs["result"]["itemSupplier"]>
  export type ItemSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type ItemSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type ItemSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $ItemSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemSupplier"
    objects: {
      item: Prisma.$InventoryItemPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_id: string
      supplier_id: number
      price: Prisma.Decimal | null
      added_on: Date
    }, ExtArgs["result"]["itemSupplier"]>
    composites: {}
  }

  type ItemSupplierGetPayload<S extends boolean | null | undefined | ItemSupplierDefaultArgs> = $Result.GetResult<Prisma.$ItemSupplierPayload, S>

  type ItemSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemSupplierCountAggregateInputType | true
    }

  export interface ItemSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemSupplier'], meta: { name: 'ItemSupplier' } }
    /**
     * Find zero or one ItemSupplier that matches the filter.
     * @param {ItemSupplierFindUniqueArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemSupplierFindUniqueArgs>(args: SelectSubset<T, ItemSupplierFindUniqueArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemSupplierFindUniqueOrThrowArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierFindFirstArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemSupplierFindFirstArgs>(args?: SelectSubset<T, ItemSupplierFindFirstArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierFindFirstOrThrowArgs} args - Arguments to find a ItemSupplier
     * @example
     * // Get one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemSuppliers
     * const itemSuppliers = await prisma.itemSupplier.findMany()
     * 
     * // Get first 10 ItemSuppliers
     * const itemSuppliers = await prisma.itemSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemSupplierWithIdOnly = await prisma.itemSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemSupplierFindManyArgs>(args?: SelectSubset<T, ItemSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemSupplier.
     * @param {ItemSupplierCreateArgs} args - Arguments to create a ItemSupplier.
     * @example
     * // Create one ItemSupplier
     * const ItemSupplier = await prisma.itemSupplier.create({
     *   data: {
     *     // ... data to create a ItemSupplier
     *   }
     * })
     * 
     */
    create<T extends ItemSupplierCreateArgs>(args: SelectSubset<T, ItemSupplierCreateArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemSuppliers.
     * @param {ItemSupplierCreateManyArgs} args - Arguments to create many ItemSuppliers.
     * @example
     * // Create many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemSupplierCreateManyArgs>(args?: SelectSubset<T, ItemSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemSuppliers and returns the data saved in the database.
     * @param {ItemSupplierCreateManyAndReturnArgs} args - Arguments to create many ItemSuppliers.
     * @example
     * // Create many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemSuppliers and only return the `id`
     * const itemSupplierWithIdOnly = await prisma.itemSupplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemSupplier.
     * @param {ItemSupplierDeleteArgs} args - Arguments to delete one ItemSupplier.
     * @example
     * // Delete one ItemSupplier
     * const ItemSupplier = await prisma.itemSupplier.delete({
     *   where: {
     *     // ... filter to delete one ItemSupplier
     *   }
     * })
     * 
     */
    delete<T extends ItemSupplierDeleteArgs>(args: SelectSubset<T, ItemSupplierDeleteArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemSupplier.
     * @param {ItemSupplierUpdateArgs} args - Arguments to update one ItemSupplier.
     * @example
     * // Update one ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemSupplierUpdateArgs>(args: SelectSubset<T, ItemSupplierUpdateArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemSuppliers.
     * @param {ItemSupplierDeleteManyArgs} args - Arguments to filter ItemSuppliers to delete.
     * @example
     * // Delete a few ItemSuppliers
     * const { count } = await prisma.itemSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemSupplierDeleteManyArgs>(args?: SelectSubset<T, ItemSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemSupplierUpdateManyArgs>(args: SelectSubset<T, ItemSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemSuppliers and returns the data updated in the database.
     * @param {ItemSupplierUpdateManyAndReturnArgs} args - Arguments to update many ItemSuppliers.
     * @example
     * // Update many ItemSuppliers
     * const itemSupplier = await prisma.itemSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemSuppliers and only return the `id`
     * const itemSupplierWithIdOnly = await prisma.itemSupplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemSupplier.
     * @param {ItemSupplierUpsertArgs} args - Arguments to update or create a ItemSupplier.
     * @example
     * // Update or create a ItemSupplier
     * const itemSupplier = await prisma.itemSupplier.upsert({
     *   create: {
     *     // ... data to create a ItemSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemSupplier we want to update
     *   }
     * })
     */
    upsert<T extends ItemSupplierUpsertArgs>(args: SelectSubset<T, ItemSupplierUpsertArgs<ExtArgs>>): Prisma__ItemSupplierClient<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierCountArgs} args - Arguments to filter ItemSuppliers to count.
     * @example
     * // Count the number of ItemSuppliers
     * const count = await prisma.itemSupplier.count({
     *   where: {
     *     // ... the filter for the ItemSuppliers we want to count
     *   }
     * })
    **/
    count<T extends ItemSupplierCountArgs>(
      args?: Subset<T, ItemSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemSupplierAggregateArgs>(args: Subset<T, ItemSupplierAggregateArgs>): Prisma.PrismaPromise<GetItemSupplierAggregateType<T>>

    /**
     * Group by ItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemSupplierGroupByArgs['orderBy'] }
        : { orderBy?: ItemSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemSupplier model
   */
  readonly fields: ItemSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemSupplier model
   */
  interface ItemSupplierFieldRefs {
    readonly id: FieldRef<"ItemSupplier", 'Int'>
    readonly item_id: FieldRef<"ItemSupplier", 'String'>
    readonly supplier_id: FieldRef<"ItemSupplier", 'Int'>
    readonly price: FieldRef<"ItemSupplier", 'Decimal'>
    readonly added_on: FieldRef<"ItemSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemSupplier findUnique
   */
  export type ItemSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier findUniqueOrThrow
   */
  export type ItemSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier findFirst
   */
  export type ItemSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSuppliers.
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSuppliers.
     */
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * ItemSupplier findFirstOrThrow
   */
  export type ItemSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSupplier to fetch.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemSuppliers.
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemSuppliers.
     */
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * ItemSupplier findMany
   */
  export type ItemSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which ItemSuppliers to fetch.
     */
    where?: ItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemSuppliers to fetch.
     */
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemSuppliers.
     */
    cursor?: ItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemSuppliers.
     */
    skip?: number
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * ItemSupplier create
   */
  export type ItemSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemSupplier.
     */
    data: XOR<ItemSupplierCreateInput, ItemSupplierUncheckedCreateInput>
  }

  /**
   * ItemSupplier createMany
   */
  export type ItemSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemSuppliers.
     */
    data: ItemSupplierCreateManyInput | ItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemSupplier createManyAndReturn
   */
  export type ItemSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many ItemSuppliers.
     */
    data: ItemSupplierCreateManyInput | ItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemSupplier update
   */
  export type ItemSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemSupplier.
     */
    data: XOR<ItemSupplierUpdateInput, ItemSupplierUncheckedUpdateInput>
    /**
     * Choose, which ItemSupplier to update.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier updateMany
   */
  export type ItemSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemSuppliers.
     */
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which ItemSuppliers to update
     */
    where?: ItemSupplierWhereInput
    /**
     * Limit how many ItemSuppliers to update.
     */
    limit?: number
  }

  /**
   * ItemSupplier updateManyAndReturn
   */
  export type ItemSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to update ItemSuppliers.
     */
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which ItemSuppliers to update
     */
    where?: ItemSupplierWhereInput
    /**
     * Limit how many ItemSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemSupplier upsert
   */
  export type ItemSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemSupplier to update in case it exists.
     */
    where: ItemSupplierWhereUniqueInput
    /**
     * In case the ItemSupplier found by the `where` argument doesn't exist, create a new ItemSupplier with this data.
     */
    create: XOR<ItemSupplierCreateInput, ItemSupplierUncheckedCreateInput>
    /**
     * In case the ItemSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemSupplierUpdateInput, ItemSupplierUncheckedUpdateInput>
  }

  /**
   * ItemSupplier delete
   */
  export type ItemSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    /**
     * Filter which ItemSupplier to delete.
     */
    where: ItemSupplierWhereUniqueInput
  }

  /**
   * ItemSupplier deleteMany
   */
  export type ItemSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemSuppliers to delete
     */
    where?: ItemSupplierWhereInput
    /**
     * Limit how many ItemSuppliers to delete.
     */
    limit?: number
  }

  /**
   * ItemSupplier without action
   */
  export type ItemSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    bunch_id: number | null
    unit_id: number | null
    quantity: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    bunch_id: number | null
    unit_id: number | null
    quantity: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    item_id: string | null
    item_name: string | null
    item_type: $Enums.InventoryItemType | null
    bunch_id: number | null
    unit_id: number | null
    quantity: number | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    item_id: string | null
    item_name: string | null
    item_type: $Enums.InventoryItemType | null
    bunch_id: number | null
    unit_id: number | null
    quantity: number | null
  }

  export type InventoryItemCountAggregateOutputType = {
    item_id: number
    item_name: number
    item_type: number
    bunch_id: number
    unit_id: number
    quantity: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    bunch_id?: true
    unit_id?: true
    quantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    bunch_id?: true
    unit_id?: true
    quantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    item_id?: true
    item_name?: true
    item_type?: true
    bunch_id?: true
    unit_id?: true
    quantity?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    item_id?: true
    item_name?: true
    item_type?: true
    bunch_id?: true
    unit_id?: true
    quantity?: true
  }

  export type InventoryItemCountAggregateInputType = {
    item_id?: true
    item_name?: true
    item_type?: true
    bunch_id?: true
    unit_id?: true
    quantity?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id: number | null
    unit_id: number | null
    quantity: number | null
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    item_name?: boolean
    item_type?: boolean
    bunch_id?: boolean
    unit_id?: boolean
    quantity?: boolean
    bunch?: boolean | InventoryItem$bunchArgs<ExtArgs>
    unit?: boolean | InventoryItem$unitArgs<ExtArgs>
    suppliers?: boolean | InventoryItem$suppliersArgs<ExtArgs>
    movement_logs?: boolean | InventoryItem$movement_logsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    item_name?: boolean
    item_type?: boolean
    bunch_id?: boolean
    unit_id?: boolean
    quantity?: boolean
    bunch?: boolean | InventoryItem$bunchArgs<ExtArgs>
    unit?: boolean | InventoryItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    item_name?: boolean
    item_type?: boolean
    bunch_id?: boolean
    unit_id?: boolean
    quantity?: boolean
    bunch?: boolean | InventoryItem$bunchArgs<ExtArgs>
    unit?: boolean | InventoryItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    item_id?: boolean
    item_name?: boolean
    item_type?: boolean
    bunch_id?: boolean
    unit_id?: boolean
    quantity?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"item_id" | "item_name" | "item_type" | "bunch_id" | "unit_id" | "quantity", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bunch?: boolean | InventoryItem$bunchArgs<ExtArgs>
    unit?: boolean | InventoryItem$unitArgs<ExtArgs>
    suppliers?: boolean | InventoryItem$suppliersArgs<ExtArgs>
    movement_logs?: boolean | InventoryItem$movement_logsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bunch?: boolean | InventoryItem$bunchArgs<ExtArgs>
    unit?: boolean | InventoryItem$unitArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bunch?: boolean | InventoryItem$bunchArgs<ExtArgs>
    unit?: boolean | InventoryItem$unitArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      bunch: Prisma.$BunchPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      suppliers: Prisma.$ItemSupplierPayload<ExtArgs>[]
      movement_logs: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      item_id: string
      item_name: string
      item_type: $Enums.InventoryItemType
      bunch_id: number | null
      unit_id: number | null
      quantity: number | null
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const inventoryItemWithItem_idOnly = await prisma.inventoryItem.findMany({ select: { item_id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `item_id`
     * const inventoryItemWithItem_idOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { item_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `item_id`
     * const inventoryItemWithItem_idOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { item_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bunch<T extends InventoryItem$bunchArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$bunchArgs<ExtArgs>>): Prisma__BunchClient<$Result.GetResult<Prisma.$BunchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends InventoryItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends InventoryItem$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movement_logs<T extends InventoryItem$movement_logsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$movement_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly item_id: FieldRef<"InventoryItem", 'String'>
    readonly item_name: FieldRef<"InventoryItem", 'String'>
    readonly item_type: FieldRef<"InventoryItem", 'InventoryItemType'>
    readonly bunch_id: FieldRef<"InventoryItem", 'Int'>
    readonly unit_id: FieldRef<"InventoryItem", 'Int'>
    readonly quantity: FieldRef<"InventoryItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.bunch
   */
  export type InventoryItem$bunchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bunch
     */
    select?: BunchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bunch
     */
    omit?: BunchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BunchInclude<ExtArgs> | null
    where?: BunchWhereInput
  }

  /**
   * InventoryItem.unit
   */
  export type InventoryItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * InventoryItem.suppliers
   */
  export type InventoryItem$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    where?: ItemSupplierWhereInput
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    cursor?: ItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * InventoryItem.movement_logs
   */
  export type InventoryItem$movement_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    customer_id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    customer_id: number | null
    first_name: string | null
    middle_name: string | null
    last_name: string | null
    add1: string | null
    add2: string | null
    add3: string | null
    add4: string | null
    email: string | null
    mobile: string | null
    office_phone: string | null
    residential_phone: string | null
    last_ordered_date: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    customer_id: number | null
    first_name: string | null
    middle_name: string | null
    last_name: string | null
    add1: string | null
    add2: string | null
    add3: string | null
    add4: string | null
    email: string | null
    mobile: string | null
    office_phone: string | null
    residential_phone: string | null
    last_ordered_date: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    customer_id: number
    first_name: number
    middle_name: number
    last_name: number
    add1: number
    add2: number
    add3: number
    add4: number
    email: number
    mobile: number
    office_phone: number
    residential_phone: number
    last_ordered_date: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    customer_id?: true
  }

  export type CustomerSumAggregateInputType = {
    customer_id?: true
  }

  export type CustomerMinAggregateInputType = {
    customer_id?: true
    first_name?: true
    middle_name?: true
    last_name?: true
    add1?: true
    add2?: true
    add3?: true
    add4?: true
    email?: true
    mobile?: true
    office_phone?: true
    residential_phone?: true
    last_ordered_date?: true
  }

  export type CustomerMaxAggregateInputType = {
    customer_id?: true
    first_name?: true
    middle_name?: true
    last_name?: true
    add1?: true
    add2?: true
    add3?: true
    add4?: true
    email?: true
    mobile?: true
    office_phone?: true
    residential_phone?: true
    last_ordered_date?: true
  }

  export type CustomerCountAggregateInputType = {
    customer_id?: true
    first_name?: true
    middle_name?: true
    last_name?: true
    add1?: true
    add2?: true
    add3?: true
    add4?: true
    email?: true
    mobile?: true
    office_phone?: true
    residential_phone?: true
    last_ordered_date?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    customer_id: number
    first_name: string | null
    middle_name: string | null
    last_name: string | null
    add1: string | null
    add2: string | null
    add3: string | null
    add4: string | null
    email: string | null
    mobile: string | null
    office_phone: string | null
    residential_phone: string | null
    last_ordered_date: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    first_name?: boolean
    middle_name?: boolean
    last_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    add4?: boolean
    email?: boolean
    mobile?: boolean
    office_phone?: boolean
    residential_phone?: boolean
    last_ordered_date?: boolean
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    measurements?: boolean | Customer$measurementsArgs<ExtArgs>
    FinalPantMeasurement?: boolean | Customer$FinalPantMeasurementArgs<ExtArgs>
    FinalShirtMeasurement?: boolean | Customer$FinalShirtMeasurementArgs<ExtArgs>
    JacketMeasurement?: boolean | Customer$JacketMeasurementArgs<ExtArgs>
    PantMeasurement?: boolean | Customer$PantMeasurementArgs<ExtArgs>
    ShirtMeasurement?: boolean | Customer$ShirtMeasurementArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    first_name?: boolean
    middle_name?: boolean
    last_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    add4?: boolean
    email?: boolean
    mobile?: boolean
    office_phone?: boolean
    residential_phone?: boolean
    last_ordered_date?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    first_name?: boolean
    middle_name?: boolean
    last_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    add4?: boolean
    email?: boolean
    mobile?: boolean
    office_phone?: boolean
    residential_phone?: boolean
    last_ordered_date?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    customer_id?: boolean
    first_name?: boolean
    middle_name?: boolean
    last_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    add4?: boolean
    email?: boolean
    mobile?: boolean
    office_phone?: boolean
    residential_phone?: boolean
    last_ordered_date?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customer_id" | "first_name" | "middle_name" | "last_name" | "add1" | "add2" | "add3" | "add4" | "email" | "mobile" | "office_phone" | "residential_phone" | "last_ordered_date", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    measurements?: boolean | Customer$measurementsArgs<ExtArgs>
    FinalPantMeasurement?: boolean | Customer$FinalPantMeasurementArgs<ExtArgs>
    FinalShirtMeasurement?: boolean | Customer$FinalShirtMeasurementArgs<ExtArgs>
    JacketMeasurement?: boolean | Customer$JacketMeasurementArgs<ExtArgs>
    PantMeasurement?: boolean | Customer$PantMeasurementArgs<ExtArgs>
    ShirtMeasurement?: boolean | Customer$ShirtMeasurementArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      measurements: Prisma.$FinalJacketMeasurementPayload<ExtArgs>[]
      FinalPantMeasurement: Prisma.$FinalPantMeasurementPayload<ExtArgs>[]
      FinalShirtMeasurement: Prisma.$FinalShirtMeasurementPayload<ExtArgs>[]
      JacketMeasurement: Prisma.$JacketMeasurementPayload<ExtArgs>[]
      PantMeasurement: Prisma.$PantMeasurementPayload<ExtArgs>[]
      ShirtMeasurement: Prisma.$ShirtMeasurementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      customer_id: number
      first_name: string | null
      middle_name: string | null
      last_name: string | null
      add1: string | null
      add2: string | null
      add3: string | null
      add4: string | null
      email: string | null
      mobile: string | null
      office_phone: string | null
      residential_phone: string | null
      last_ordered_date: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.findMany({ select: { customer_id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.createManyAndReturn({
     *   select: { customer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `customer_id`
     * const customerWithCustomer_idOnly = await prisma.customer.updateManyAndReturn({
     *   select: { customer_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measurements<T extends Customer$measurementsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FinalPantMeasurement<T extends Customer$FinalPantMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Customer$FinalPantMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FinalShirtMeasurement<T extends Customer$FinalShirtMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Customer$FinalShirtMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JacketMeasurement<T extends Customer$JacketMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Customer$JacketMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PantMeasurement<T extends Customer$PantMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Customer$PantMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShirtMeasurement<T extends Customer$ShirtMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ShirtMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly customer_id: FieldRef<"Customer", 'Int'>
    readonly first_name: FieldRef<"Customer", 'String'>
    readonly middle_name: FieldRef<"Customer", 'String'>
    readonly last_name: FieldRef<"Customer", 'String'>
    readonly add1: FieldRef<"Customer", 'String'>
    readonly add2: FieldRef<"Customer", 'String'>
    readonly add3: FieldRef<"Customer", 'String'>
    readonly add4: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly mobile: FieldRef<"Customer", 'String'>
    readonly office_phone: FieldRef<"Customer", 'String'>
    readonly residential_phone: FieldRef<"Customer", 'String'>
    readonly last_ordered_date: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data?: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Customer.measurements
   */
  export type Customer$measurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    where?: FinalJacketMeasurementWhereInput
    orderBy?: FinalJacketMeasurementOrderByWithRelationInput | FinalJacketMeasurementOrderByWithRelationInput[]
    cursor?: FinalJacketMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalJacketMeasurementScalarFieldEnum | FinalJacketMeasurementScalarFieldEnum[]
  }

  /**
   * Customer.FinalPantMeasurement
   */
  export type Customer$FinalPantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    where?: FinalPantMeasurementWhereInput
    orderBy?: FinalPantMeasurementOrderByWithRelationInput | FinalPantMeasurementOrderByWithRelationInput[]
    cursor?: FinalPantMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalPantMeasurementScalarFieldEnum | FinalPantMeasurementScalarFieldEnum[]
  }

  /**
   * Customer.FinalShirtMeasurement
   */
  export type Customer$FinalShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    where?: FinalShirtMeasurementWhereInput
    orderBy?: FinalShirtMeasurementOrderByWithRelationInput | FinalShirtMeasurementOrderByWithRelationInput[]
    cursor?: FinalShirtMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalShirtMeasurementScalarFieldEnum | FinalShirtMeasurementScalarFieldEnum[]
  }

  /**
   * Customer.JacketMeasurement
   */
  export type Customer$JacketMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    where?: JacketMeasurementWhereInput
    orderBy?: JacketMeasurementOrderByWithRelationInput | JacketMeasurementOrderByWithRelationInput[]
    cursor?: JacketMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JacketMeasurementScalarFieldEnum | JacketMeasurementScalarFieldEnum[]
  }

  /**
   * Customer.PantMeasurement
   */
  export type Customer$PantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    where?: PantMeasurementWhereInput
    orderBy?: PantMeasurementOrderByWithRelationInput | PantMeasurementOrderByWithRelationInput[]
    cursor?: PantMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PantMeasurementScalarFieldEnum | PantMeasurementScalarFieldEnum[]
  }

  /**
   * Customer.ShirtMeasurement
   */
  export type Customer$ShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    where?: ShirtMeasurementWhereInput
    orderBy?: ShirtMeasurementOrderByWithRelationInput | ShirtMeasurementOrderByWithRelationInput[]
    cursor?: ShirtMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShirtMeasurementScalarFieldEnum | ShirtMeasurementScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Fabric
   */

  export type AggregateFabric = {
    _count: FabricCountAggregateOutputType | null
    _avg: FabricAvgAggregateOutputType | null
    _sum: FabricSumAggregateOutputType | null
    _min: FabricMinAggregateOutputType | null
    _max: FabricMaxAggregateOutputType | null
  }

  export type FabricAvgAggregateOutputType = {
    fabric_id: number | null
    available_length: Decimal | null
  }

  export type FabricSumAggregateOutputType = {
    fabric_id: number | null
    available_length: Decimal | null
  }

  export type FabricMinAggregateOutputType = {
    fabric_id: number | null
    description: string | null
    available_length: Decimal | null
    fabric_code: string | null
    fabric_brand: string | null
    stock_location: string | null
    image: string | null
    barcode: string | null
  }

  export type FabricMaxAggregateOutputType = {
    fabric_id: number | null
    description: string | null
    available_length: Decimal | null
    fabric_code: string | null
    fabric_brand: string | null
    stock_location: string | null
    image: string | null
    barcode: string | null
  }

  export type FabricCountAggregateOutputType = {
    fabric_id: number
    description: number
    available_length: number
    fabric_code: number
    fabric_brand: number
    stock_location: number
    image: number
    barcode: number
    _all: number
  }


  export type FabricAvgAggregateInputType = {
    fabric_id?: true
    available_length?: true
  }

  export type FabricSumAggregateInputType = {
    fabric_id?: true
    available_length?: true
  }

  export type FabricMinAggregateInputType = {
    fabric_id?: true
    description?: true
    available_length?: true
    fabric_code?: true
    fabric_brand?: true
    stock_location?: true
    image?: true
    barcode?: true
  }

  export type FabricMaxAggregateInputType = {
    fabric_id?: true
    description?: true
    available_length?: true
    fabric_code?: true
    fabric_brand?: true
    stock_location?: true
    image?: true
    barcode?: true
  }

  export type FabricCountAggregateInputType = {
    fabric_id?: true
    description?: true
    available_length?: true
    fabric_code?: true
    fabric_brand?: true
    stock_location?: true
    image?: true
    barcode?: true
    _all?: true
  }

  export type FabricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fabric to aggregate.
     */
    where?: FabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fabrics to fetch.
     */
    orderBy?: FabricOrderByWithRelationInput | FabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fabrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fabrics
    **/
    _count?: true | FabricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FabricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FabricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FabricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FabricMaxAggregateInputType
  }

  export type GetFabricAggregateType<T extends FabricAggregateArgs> = {
        [P in keyof T & keyof AggregateFabric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFabric[P]>
      : GetScalarType<T[P], AggregateFabric[P]>
  }




  export type FabricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FabricWhereInput
    orderBy?: FabricOrderByWithAggregationInput | FabricOrderByWithAggregationInput[]
    by: FabricScalarFieldEnum[] | FabricScalarFieldEnum
    having?: FabricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FabricCountAggregateInputType | true
    _avg?: FabricAvgAggregateInputType
    _sum?: FabricSumAggregateInputType
    _min?: FabricMinAggregateInputType
    _max?: FabricMaxAggregateInputType
  }

  export type FabricGroupByOutputType = {
    fabric_id: number
    description: string | null
    available_length: Decimal | null
    fabric_code: string | null
    fabric_brand: string | null
    stock_location: string | null
    image: string | null
    barcode: string | null
    _count: FabricCountAggregateOutputType | null
    _avg: FabricAvgAggregateOutputType | null
    _sum: FabricSumAggregateOutputType | null
    _min: FabricMinAggregateOutputType | null
    _max: FabricMaxAggregateOutputType | null
  }

  type GetFabricGroupByPayload<T extends FabricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FabricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FabricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FabricGroupByOutputType[P]>
            : GetScalarType<T[P], FabricGroupByOutputType[P]>
        }
      >
    >


  export type FabricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fabric_id?: boolean
    description?: boolean
    available_length?: boolean
    fabric_code?: boolean
    fabric_brand?: boolean
    stock_location?: boolean
    image?: boolean
    barcode?: boolean
    fabricOrders?: boolean | Fabric$fabricOrdersArgs<ExtArgs>
    items?: boolean | Fabric$itemsArgs<ExtArgs>
    liningItems?: boolean | Fabric$liningItemsArgs<ExtArgs>
    _count?: boolean | FabricCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fabric"]>

  export type FabricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fabric_id?: boolean
    description?: boolean
    available_length?: boolean
    fabric_code?: boolean
    fabric_brand?: boolean
    stock_location?: boolean
    image?: boolean
    barcode?: boolean
  }, ExtArgs["result"]["fabric"]>

  export type FabricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fabric_id?: boolean
    description?: boolean
    available_length?: boolean
    fabric_code?: boolean
    fabric_brand?: boolean
    stock_location?: boolean
    image?: boolean
    barcode?: boolean
  }, ExtArgs["result"]["fabric"]>

  export type FabricSelectScalar = {
    fabric_id?: boolean
    description?: boolean
    available_length?: boolean
    fabric_code?: boolean
    fabric_brand?: boolean
    stock_location?: boolean
    image?: boolean
    barcode?: boolean
  }

  export type FabricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"fabric_id" | "description" | "available_length" | "fabric_code" | "fabric_brand" | "stock_location" | "image" | "barcode", ExtArgs["result"]["fabric"]>
  export type FabricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fabricOrders?: boolean | Fabric$fabricOrdersArgs<ExtArgs>
    items?: boolean | Fabric$itemsArgs<ExtArgs>
    liningItems?: boolean | Fabric$liningItemsArgs<ExtArgs>
    _count?: boolean | FabricCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FabricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FabricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FabricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fabric"
    objects: {
      fabricOrders: Prisma.$FabricOrderListPayload<ExtArgs>[]
      items: Prisma.$ItemsPayload<ExtArgs>[]
      liningItems: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      fabric_id: number
      description: string | null
      available_length: Prisma.Decimal | null
      fabric_code: string | null
      fabric_brand: string | null
      stock_location: string | null
      image: string | null
      barcode: string | null
    }, ExtArgs["result"]["fabric"]>
    composites: {}
  }

  type FabricGetPayload<S extends boolean | null | undefined | FabricDefaultArgs> = $Result.GetResult<Prisma.$FabricPayload, S>

  type FabricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FabricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FabricCountAggregateInputType | true
    }

  export interface FabricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fabric'], meta: { name: 'Fabric' } }
    /**
     * Find zero or one Fabric that matches the filter.
     * @param {FabricFindUniqueArgs} args - Arguments to find a Fabric
     * @example
     * // Get one Fabric
     * const fabric = await prisma.fabric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FabricFindUniqueArgs>(args: SelectSubset<T, FabricFindUniqueArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fabric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FabricFindUniqueOrThrowArgs} args - Arguments to find a Fabric
     * @example
     * // Get one Fabric
     * const fabric = await prisma.fabric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FabricFindUniqueOrThrowArgs>(args: SelectSubset<T, FabricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fabric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricFindFirstArgs} args - Arguments to find a Fabric
     * @example
     * // Get one Fabric
     * const fabric = await prisma.fabric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FabricFindFirstArgs>(args?: SelectSubset<T, FabricFindFirstArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fabric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricFindFirstOrThrowArgs} args - Arguments to find a Fabric
     * @example
     * // Get one Fabric
     * const fabric = await prisma.fabric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FabricFindFirstOrThrowArgs>(args?: SelectSubset<T, FabricFindFirstOrThrowArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fabrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fabrics
     * const fabrics = await prisma.fabric.findMany()
     * 
     * // Get first 10 Fabrics
     * const fabrics = await prisma.fabric.findMany({ take: 10 })
     * 
     * // Only select the `fabric_id`
     * const fabricWithFabric_idOnly = await prisma.fabric.findMany({ select: { fabric_id: true } })
     * 
     */
    findMany<T extends FabricFindManyArgs>(args?: SelectSubset<T, FabricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fabric.
     * @param {FabricCreateArgs} args - Arguments to create a Fabric.
     * @example
     * // Create one Fabric
     * const Fabric = await prisma.fabric.create({
     *   data: {
     *     // ... data to create a Fabric
     *   }
     * })
     * 
     */
    create<T extends FabricCreateArgs>(args: SelectSubset<T, FabricCreateArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fabrics.
     * @param {FabricCreateManyArgs} args - Arguments to create many Fabrics.
     * @example
     * // Create many Fabrics
     * const fabric = await prisma.fabric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FabricCreateManyArgs>(args?: SelectSubset<T, FabricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fabrics and returns the data saved in the database.
     * @param {FabricCreateManyAndReturnArgs} args - Arguments to create many Fabrics.
     * @example
     * // Create many Fabrics
     * const fabric = await prisma.fabric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fabrics and only return the `fabric_id`
     * const fabricWithFabric_idOnly = await prisma.fabric.createManyAndReturn({
     *   select: { fabric_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FabricCreateManyAndReturnArgs>(args?: SelectSubset<T, FabricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fabric.
     * @param {FabricDeleteArgs} args - Arguments to delete one Fabric.
     * @example
     * // Delete one Fabric
     * const Fabric = await prisma.fabric.delete({
     *   where: {
     *     // ... filter to delete one Fabric
     *   }
     * })
     * 
     */
    delete<T extends FabricDeleteArgs>(args: SelectSubset<T, FabricDeleteArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fabric.
     * @param {FabricUpdateArgs} args - Arguments to update one Fabric.
     * @example
     * // Update one Fabric
     * const fabric = await prisma.fabric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FabricUpdateArgs>(args: SelectSubset<T, FabricUpdateArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fabrics.
     * @param {FabricDeleteManyArgs} args - Arguments to filter Fabrics to delete.
     * @example
     * // Delete a few Fabrics
     * const { count } = await prisma.fabric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FabricDeleteManyArgs>(args?: SelectSubset<T, FabricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fabrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fabrics
     * const fabric = await prisma.fabric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FabricUpdateManyArgs>(args: SelectSubset<T, FabricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fabrics and returns the data updated in the database.
     * @param {FabricUpdateManyAndReturnArgs} args - Arguments to update many Fabrics.
     * @example
     * // Update many Fabrics
     * const fabric = await prisma.fabric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fabrics and only return the `fabric_id`
     * const fabricWithFabric_idOnly = await prisma.fabric.updateManyAndReturn({
     *   select: { fabric_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FabricUpdateManyAndReturnArgs>(args: SelectSubset<T, FabricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fabric.
     * @param {FabricUpsertArgs} args - Arguments to update or create a Fabric.
     * @example
     * // Update or create a Fabric
     * const fabric = await prisma.fabric.upsert({
     *   create: {
     *     // ... data to create a Fabric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fabric we want to update
     *   }
     * })
     */
    upsert<T extends FabricUpsertArgs>(args: SelectSubset<T, FabricUpsertArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fabrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricCountArgs} args - Arguments to filter Fabrics to count.
     * @example
     * // Count the number of Fabrics
     * const count = await prisma.fabric.count({
     *   where: {
     *     // ... the filter for the Fabrics we want to count
     *   }
     * })
    **/
    count<T extends FabricCountArgs>(
      args?: Subset<T, FabricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FabricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fabric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FabricAggregateArgs>(args: Subset<T, FabricAggregateArgs>): Prisma.PrismaPromise<GetFabricAggregateType<T>>

    /**
     * Group by Fabric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FabricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FabricGroupByArgs['orderBy'] }
        : { orderBy?: FabricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FabricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFabricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fabric model
   */
  readonly fields: FabricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fabric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FabricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fabricOrders<T extends Fabric$fabricOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Fabric$fabricOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Fabric$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Fabric$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liningItems<T extends Fabric$liningItemsArgs<ExtArgs> = {}>(args?: Subset<T, Fabric$liningItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fabric model
   */
  interface FabricFieldRefs {
    readonly fabric_id: FieldRef<"Fabric", 'Int'>
    readonly description: FieldRef<"Fabric", 'String'>
    readonly available_length: FieldRef<"Fabric", 'Decimal'>
    readonly fabric_code: FieldRef<"Fabric", 'String'>
    readonly fabric_brand: FieldRef<"Fabric", 'String'>
    readonly stock_location: FieldRef<"Fabric", 'String'>
    readonly image: FieldRef<"Fabric", 'String'>
    readonly barcode: FieldRef<"Fabric", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fabric findUnique
   */
  export type FabricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * Filter, which Fabric to fetch.
     */
    where: FabricWhereUniqueInput
  }

  /**
   * Fabric findUniqueOrThrow
   */
  export type FabricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * Filter, which Fabric to fetch.
     */
    where: FabricWhereUniqueInput
  }

  /**
   * Fabric findFirst
   */
  export type FabricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * Filter, which Fabric to fetch.
     */
    where?: FabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fabrics to fetch.
     */
    orderBy?: FabricOrderByWithRelationInput | FabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fabrics.
     */
    cursor?: FabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fabrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fabrics.
     */
    distinct?: FabricScalarFieldEnum | FabricScalarFieldEnum[]
  }

  /**
   * Fabric findFirstOrThrow
   */
  export type FabricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * Filter, which Fabric to fetch.
     */
    where?: FabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fabrics to fetch.
     */
    orderBy?: FabricOrderByWithRelationInput | FabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fabrics.
     */
    cursor?: FabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fabrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fabrics.
     */
    distinct?: FabricScalarFieldEnum | FabricScalarFieldEnum[]
  }

  /**
   * Fabric findMany
   */
  export type FabricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * Filter, which Fabrics to fetch.
     */
    where?: FabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fabrics to fetch.
     */
    orderBy?: FabricOrderByWithRelationInput | FabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fabrics.
     */
    cursor?: FabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fabrics.
     */
    skip?: number
    distinct?: FabricScalarFieldEnum | FabricScalarFieldEnum[]
  }

  /**
   * Fabric create
   */
  export type FabricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * The data needed to create a Fabric.
     */
    data?: XOR<FabricCreateInput, FabricUncheckedCreateInput>
  }

  /**
   * Fabric createMany
   */
  export type FabricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fabrics.
     */
    data: FabricCreateManyInput | FabricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fabric createManyAndReturn
   */
  export type FabricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * The data used to create many Fabrics.
     */
    data: FabricCreateManyInput | FabricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fabric update
   */
  export type FabricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * The data needed to update a Fabric.
     */
    data: XOR<FabricUpdateInput, FabricUncheckedUpdateInput>
    /**
     * Choose, which Fabric to update.
     */
    where: FabricWhereUniqueInput
  }

  /**
   * Fabric updateMany
   */
  export type FabricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fabrics.
     */
    data: XOR<FabricUpdateManyMutationInput, FabricUncheckedUpdateManyInput>
    /**
     * Filter which Fabrics to update
     */
    where?: FabricWhereInput
    /**
     * Limit how many Fabrics to update.
     */
    limit?: number
  }

  /**
   * Fabric updateManyAndReturn
   */
  export type FabricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * The data used to update Fabrics.
     */
    data: XOR<FabricUpdateManyMutationInput, FabricUncheckedUpdateManyInput>
    /**
     * Filter which Fabrics to update
     */
    where?: FabricWhereInput
    /**
     * Limit how many Fabrics to update.
     */
    limit?: number
  }

  /**
   * Fabric upsert
   */
  export type FabricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * The filter to search for the Fabric to update in case it exists.
     */
    where: FabricWhereUniqueInput
    /**
     * In case the Fabric found by the `where` argument doesn't exist, create a new Fabric with this data.
     */
    create: XOR<FabricCreateInput, FabricUncheckedCreateInput>
    /**
     * In case the Fabric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FabricUpdateInput, FabricUncheckedUpdateInput>
  }

  /**
   * Fabric delete
   */
  export type FabricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    /**
     * Filter which Fabric to delete.
     */
    where: FabricWhereUniqueInput
  }

  /**
   * Fabric deleteMany
   */
  export type FabricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fabrics to delete
     */
    where?: FabricWhereInput
    /**
     * Limit how many Fabrics to delete.
     */
    limit?: number
  }

  /**
   * Fabric.fabricOrders
   */
  export type Fabric$fabricOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    where?: FabricOrderListWhereInput
    orderBy?: FabricOrderListOrderByWithRelationInput | FabricOrderListOrderByWithRelationInput[]
    cursor?: FabricOrderListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FabricOrderListScalarFieldEnum | FabricOrderListScalarFieldEnum[]
  }

  /**
   * Fabric.items
   */
  export type Fabric$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * Fabric.liningItems
   */
  export type Fabric$liningItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * Fabric without action
   */
  export type FabricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
  }


  /**
   * Model FabricOrderList
   */

  export type AggregateFabricOrderList = {
    _count: FabricOrderListCountAggregateOutputType | null
    _avg: FabricOrderListAvgAggregateOutputType | null
    _sum: FabricOrderListSumAggregateOutputType | null
    _min: FabricOrderListMinAggregateOutputType | null
    _max: FabricOrderListMaxAggregateOutputType | null
  }

  export type FabricOrderListAvgAggregateOutputType = {
    order_id: number | null
    fabric_id: number | null
    meters: Decimal | null
    supplier_id: number | null
  }

  export type FabricOrderListSumAggregateOutputType = {
    order_id: number | null
    fabric_id: number | null
    meters: Decimal | null
    supplier_id: number | null
  }

  export type FabricOrderListMinAggregateOutputType = {
    order_id: number | null
    fabric_id: number | null
    description: string | null
    supplier_name: string | null
    meters: Decimal | null
    ordered_date: Date | null
    ordered_for: string | null
    supplier_id: number | null
  }

  export type FabricOrderListMaxAggregateOutputType = {
    order_id: number | null
    fabric_id: number | null
    description: string | null
    supplier_name: string | null
    meters: Decimal | null
    ordered_date: Date | null
    ordered_for: string | null
    supplier_id: number | null
  }

  export type FabricOrderListCountAggregateOutputType = {
    order_id: number
    fabric_id: number
    description: number
    supplier_name: number
    meters: number
    ordered_date: number
    ordered_for: number
    supplier_id: number
    _all: number
  }


  export type FabricOrderListAvgAggregateInputType = {
    order_id?: true
    fabric_id?: true
    meters?: true
    supplier_id?: true
  }

  export type FabricOrderListSumAggregateInputType = {
    order_id?: true
    fabric_id?: true
    meters?: true
    supplier_id?: true
  }

  export type FabricOrderListMinAggregateInputType = {
    order_id?: true
    fabric_id?: true
    description?: true
    supplier_name?: true
    meters?: true
    ordered_date?: true
    ordered_for?: true
    supplier_id?: true
  }

  export type FabricOrderListMaxAggregateInputType = {
    order_id?: true
    fabric_id?: true
    description?: true
    supplier_name?: true
    meters?: true
    ordered_date?: true
    ordered_for?: true
    supplier_id?: true
  }

  export type FabricOrderListCountAggregateInputType = {
    order_id?: true
    fabric_id?: true
    description?: true
    supplier_name?: true
    meters?: true
    ordered_date?: true
    ordered_for?: true
    supplier_id?: true
    _all?: true
  }

  export type FabricOrderListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FabricOrderList to aggregate.
     */
    where?: FabricOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FabricOrderLists to fetch.
     */
    orderBy?: FabricOrderListOrderByWithRelationInput | FabricOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FabricOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FabricOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FabricOrderLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FabricOrderLists
    **/
    _count?: true | FabricOrderListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FabricOrderListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FabricOrderListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FabricOrderListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FabricOrderListMaxAggregateInputType
  }

  export type GetFabricOrderListAggregateType<T extends FabricOrderListAggregateArgs> = {
        [P in keyof T & keyof AggregateFabricOrderList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFabricOrderList[P]>
      : GetScalarType<T[P], AggregateFabricOrderList[P]>
  }




  export type FabricOrderListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FabricOrderListWhereInput
    orderBy?: FabricOrderListOrderByWithAggregationInput | FabricOrderListOrderByWithAggregationInput[]
    by: FabricOrderListScalarFieldEnum[] | FabricOrderListScalarFieldEnum
    having?: FabricOrderListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FabricOrderListCountAggregateInputType | true
    _avg?: FabricOrderListAvgAggregateInputType
    _sum?: FabricOrderListSumAggregateInputType
    _min?: FabricOrderListMinAggregateInputType
    _max?: FabricOrderListMaxAggregateInputType
  }

  export type FabricOrderListGroupByOutputType = {
    order_id: number
    fabric_id: number | null
    description: string | null
    supplier_name: string | null
    meters: Decimal | null
    ordered_date: Date | null
    ordered_for: string | null
    supplier_id: number | null
    _count: FabricOrderListCountAggregateOutputType | null
    _avg: FabricOrderListAvgAggregateOutputType | null
    _sum: FabricOrderListSumAggregateOutputType | null
    _min: FabricOrderListMinAggregateOutputType | null
    _max: FabricOrderListMaxAggregateOutputType | null
  }

  type GetFabricOrderListGroupByPayload<T extends FabricOrderListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FabricOrderListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FabricOrderListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FabricOrderListGroupByOutputType[P]>
            : GetScalarType<T[P], FabricOrderListGroupByOutputType[P]>
        }
      >
    >


  export type FabricOrderListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    fabric_id?: boolean
    description?: boolean
    supplier_name?: boolean
    meters?: boolean
    ordered_date?: boolean
    ordered_for?: boolean
    supplier_id?: boolean
    fabric?: boolean | FabricOrderList$fabricArgs<ExtArgs>
    supplier?: boolean | FabricOrderList$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["fabricOrderList"]>

  export type FabricOrderListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    fabric_id?: boolean
    description?: boolean
    supplier_name?: boolean
    meters?: boolean
    ordered_date?: boolean
    ordered_for?: boolean
    supplier_id?: boolean
    fabric?: boolean | FabricOrderList$fabricArgs<ExtArgs>
    supplier?: boolean | FabricOrderList$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["fabricOrderList"]>

  export type FabricOrderListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    fabric_id?: boolean
    description?: boolean
    supplier_name?: boolean
    meters?: boolean
    ordered_date?: boolean
    ordered_for?: boolean
    supplier_id?: boolean
    fabric?: boolean | FabricOrderList$fabricArgs<ExtArgs>
    supplier?: boolean | FabricOrderList$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["fabricOrderList"]>

  export type FabricOrderListSelectScalar = {
    order_id?: boolean
    fabric_id?: boolean
    description?: boolean
    supplier_name?: boolean
    meters?: boolean
    ordered_date?: boolean
    ordered_for?: boolean
    supplier_id?: boolean
  }

  export type FabricOrderListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"order_id" | "fabric_id" | "description" | "supplier_name" | "meters" | "ordered_date" | "ordered_for" | "supplier_id", ExtArgs["result"]["fabricOrderList"]>
  export type FabricOrderListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fabric?: boolean | FabricOrderList$fabricArgs<ExtArgs>
    supplier?: boolean | FabricOrderList$supplierArgs<ExtArgs>
  }
  export type FabricOrderListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fabric?: boolean | FabricOrderList$fabricArgs<ExtArgs>
    supplier?: boolean | FabricOrderList$supplierArgs<ExtArgs>
  }
  export type FabricOrderListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fabric?: boolean | FabricOrderList$fabricArgs<ExtArgs>
    supplier?: boolean | FabricOrderList$supplierArgs<ExtArgs>
  }

  export type $FabricOrderListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FabricOrderList"
    objects: {
      fabric: Prisma.$FabricPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      fabric_id: number | null
      description: string | null
      supplier_name: string | null
      meters: Prisma.Decimal | null
      ordered_date: Date | null
      ordered_for: string | null
      supplier_id: number | null
    }, ExtArgs["result"]["fabricOrderList"]>
    composites: {}
  }

  type FabricOrderListGetPayload<S extends boolean | null | undefined | FabricOrderListDefaultArgs> = $Result.GetResult<Prisma.$FabricOrderListPayload, S>

  type FabricOrderListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FabricOrderListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FabricOrderListCountAggregateInputType | true
    }

  export interface FabricOrderListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FabricOrderList'], meta: { name: 'FabricOrderList' } }
    /**
     * Find zero or one FabricOrderList that matches the filter.
     * @param {FabricOrderListFindUniqueArgs} args - Arguments to find a FabricOrderList
     * @example
     * // Get one FabricOrderList
     * const fabricOrderList = await prisma.fabricOrderList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FabricOrderListFindUniqueArgs>(args: SelectSubset<T, FabricOrderListFindUniqueArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FabricOrderList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FabricOrderListFindUniqueOrThrowArgs} args - Arguments to find a FabricOrderList
     * @example
     * // Get one FabricOrderList
     * const fabricOrderList = await prisma.fabricOrderList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FabricOrderListFindUniqueOrThrowArgs>(args: SelectSubset<T, FabricOrderListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FabricOrderList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListFindFirstArgs} args - Arguments to find a FabricOrderList
     * @example
     * // Get one FabricOrderList
     * const fabricOrderList = await prisma.fabricOrderList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FabricOrderListFindFirstArgs>(args?: SelectSubset<T, FabricOrderListFindFirstArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FabricOrderList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListFindFirstOrThrowArgs} args - Arguments to find a FabricOrderList
     * @example
     * // Get one FabricOrderList
     * const fabricOrderList = await prisma.fabricOrderList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FabricOrderListFindFirstOrThrowArgs>(args?: SelectSubset<T, FabricOrderListFindFirstOrThrowArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FabricOrderLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FabricOrderLists
     * const fabricOrderLists = await prisma.fabricOrderList.findMany()
     * 
     * // Get first 10 FabricOrderLists
     * const fabricOrderLists = await prisma.fabricOrderList.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const fabricOrderListWithOrder_idOnly = await prisma.fabricOrderList.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends FabricOrderListFindManyArgs>(args?: SelectSubset<T, FabricOrderListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FabricOrderList.
     * @param {FabricOrderListCreateArgs} args - Arguments to create a FabricOrderList.
     * @example
     * // Create one FabricOrderList
     * const FabricOrderList = await prisma.fabricOrderList.create({
     *   data: {
     *     // ... data to create a FabricOrderList
     *   }
     * })
     * 
     */
    create<T extends FabricOrderListCreateArgs>(args: SelectSubset<T, FabricOrderListCreateArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FabricOrderLists.
     * @param {FabricOrderListCreateManyArgs} args - Arguments to create many FabricOrderLists.
     * @example
     * // Create many FabricOrderLists
     * const fabricOrderList = await prisma.fabricOrderList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FabricOrderListCreateManyArgs>(args?: SelectSubset<T, FabricOrderListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FabricOrderLists and returns the data saved in the database.
     * @param {FabricOrderListCreateManyAndReturnArgs} args - Arguments to create many FabricOrderLists.
     * @example
     * // Create many FabricOrderLists
     * const fabricOrderList = await prisma.fabricOrderList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FabricOrderLists and only return the `order_id`
     * const fabricOrderListWithOrder_idOnly = await prisma.fabricOrderList.createManyAndReturn({
     *   select: { order_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FabricOrderListCreateManyAndReturnArgs>(args?: SelectSubset<T, FabricOrderListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FabricOrderList.
     * @param {FabricOrderListDeleteArgs} args - Arguments to delete one FabricOrderList.
     * @example
     * // Delete one FabricOrderList
     * const FabricOrderList = await prisma.fabricOrderList.delete({
     *   where: {
     *     // ... filter to delete one FabricOrderList
     *   }
     * })
     * 
     */
    delete<T extends FabricOrderListDeleteArgs>(args: SelectSubset<T, FabricOrderListDeleteArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FabricOrderList.
     * @param {FabricOrderListUpdateArgs} args - Arguments to update one FabricOrderList.
     * @example
     * // Update one FabricOrderList
     * const fabricOrderList = await prisma.fabricOrderList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FabricOrderListUpdateArgs>(args: SelectSubset<T, FabricOrderListUpdateArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FabricOrderLists.
     * @param {FabricOrderListDeleteManyArgs} args - Arguments to filter FabricOrderLists to delete.
     * @example
     * // Delete a few FabricOrderLists
     * const { count } = await prisma.fabricOrderList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FabricOrderListDeleteManyArgs>(args?: SelectSubset<T, FabricOrderListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FabricOrderLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FabricOrderLists
     * const fabricOrderList = await prisma.fabricOrderList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FabricOrderListUpdateManyArgs>(args: SelectSubset<T, FabricOrderListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FabricOrderLists and returns the data updated in the database.
     * @param {FabricOrderListUpdateManyAndReturnArgs} args - Arguments to update many FabricOrderLists.
     * @example
     * // Update many FabricOrderLists
     * const fabricOrderList = await prisma.fabricOrderList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FabricOrderLists and only return the `order_id`
     * const fabricOrderListWithOrder_idOnly = await prisma.fabricOrderList.updateManyAndReturn({
     *   select: { order_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FabricOrderListUpdateManyAndReturnArgs>(args: SelectSubset<T, FabricOrderListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FabricOrderList.
     * @param {FabricOrderListUpsertArgs} args - Arguments to update or create a FabricOrderList.
     * @example
     * // Update or create a FabricOrderList
     * const fabricOrderList = await prisma.fabricOrderList.upsert({
     *   create: {
     *     // ... data to create a FabricOrderList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FabricOrderList we want to update
     *   }
     * })
     */
    upsert<T extends FabricOrderListUpsertArgs>(args: SelectSubset<T, FabricOrderListUpsertArgs<ExtArgs>>): Prisma__FabricOrderListClient<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FabricOrderLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListCountArgs} args - Arguments to filter FabricOrderLists to count.
     * @example
     * // Count the number of FabricOrderLists
     * const count = await prisma.fabricOrderList.count({
     *   where: {
     *     // ... the filter for the FabricOrderLists we want to count
     *   }
     * })
    **/
    count<T extends FabricOrderListCountArgs>(
      args?: Subset<T, FabricOrderListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FabricOrderListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FabricOrderList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FabricOrderListAggregateArgs>(args: Subset<T, FabricOrderListAggregateArgs>): Prisma.PrismaPromise<GetFabricOrderListAggregateType<T>>

    /**
     * Group by FabricOrderList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FabricOrderListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FabricOrderListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FabricOrderListGroupByArgs['orderBy'] }
        : { orderBy?: FabricOrderListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FabricOrderListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFabricOrderListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FabricOrderList model
   */
  readonly fields: FabricOrderListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FabricOrderList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FabricOrderListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fabric<T extends FabricOrderList$fabricArgs<ExtArgs> = {}>(args?: Subset<T, FabricOrderList$fabricArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supplier<T extends FabricOrderList$supplierArgs<ExtArgs> = {}>(args?: Subset<T, FabricOrderList$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FabricOrderList model
   */
  interface FabricOrderListFieldRefs {
    readonly order_id: FieldRef<"FabricOrderList", 'Int'>
    readonly fabric_id: FieldRef<"FabricOrderList", 'Int'>
    readonly description: FieldRef<"FabricOrderList", 'String'>
    readonly supplier_name: FieldRef<"FabricOrderList", 'String'>
    readonly meters: FieldRef<"FabricOrderList", 'Decimal'>
    readonly ordered_date: FieldRef<"FabricOrderList", 'DateTime'>
    readonly ordered_for: FieldRef<"FabricOrderList", 'String'>
    readonly supplier_id: FieldRef<"FabricOrderList", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FabricOrderList findUnique
   */
  export type FabricOrderListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * Filter, which FabricOrderList to fetch.
     */
    where: FabricOrderListWhereUniqueInput
  }

  /**
   * FabricOrderList findUniqueOrThrow
   */
  export type FabricOrderListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * Filter, which FabricOrderList to fetch.
     */
    where: FabricOrderListWhereUniqueInput
  }

  /**
   * FabricOrderList findFirst
   */
  export type FabricOrderListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * Filter, which FabricOrderList to fetch.
     */
    where?: FabricOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FabricOrderLists to fetch.
     */
    orderBy?: FabricOrderListOrderByWithRelationInput | FabricOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FabricOrderLists.
     */
    cursor?: FabricOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FabricOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FabricOrderLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FabricOrderLists.
     */
    distinct?: FabricOrderListScalarFieldEnum | FabricOrderListScalarFieldEnum[]
  }

  /**
   * FabricOrderList findFirstOrThrow
   */
  export type FabricOrderListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * Filter, which FabricOrderList to fetch.
     */
    where?: FabricOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FabricOrderLists to fetch.
     */
    orderBy?: FabricOrderListOrderByWithRelationInput | FabricOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FabricOrderLists.
     */
    cursor?: FabricOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FabricOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FabricOrderLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FabricOrderLists.
     */
    distinct?: FabricOrderListScalarFieldEnum | FabricOrderListScalarFieldEnum[]
  }

  /**
   * FabricOrderList findMany
   */
  export type FabricOrderListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * Filter, which FabricOrderLists to fetch.
     */
    where?: FabricOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FabricOrderLists to fetch.
     */
    orderBy?: FabricOrderListOrderByWithRelationInput | FabricOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FabricOrderLists.
     */
    cursor?: FabricOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FabricOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FabricOrderLists.
     */
    skip?: number
    distinct?: FabricOrderListScalarFieldEnum | FabricOrderListScalarFieldEnum[]
  }

  /**
   * FabricOrderList create
   */
  export type FabricOrderListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * The data needed to create a FabricOrderList.
     */
    data?: XOR<FabricOrderListCreateInput, FabricOrderListUncheckedCreateInput>
  }

  /**
   * FabricOrderList createMany
   */
  export type FabricOrderListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FabricOrderLists.
     */
    data: FabricOrderListCreateManyInput | FabricOrderListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FabricOrderList createManyAndReturn
   */
  export type FabricOrderListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * The data used to create many FabricOrderLists.
     */
    data: FabricOrderListCreateManyInput | FabricOrderListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FabricOrderList update
   */
  export type FabricOrderListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * The data needed to update a FabricOrderList.
     */
    data: XOR<FabricOrderListUpdateInput, FabricOrderListUncheckedUpdateInput>
    /**
     * Choose, which FabricOrderList to update.
     */
    where: FabricOrderListWhereUniqueInput
  }

  /**
   * FabricOrderList updateMany
   */
  export type FabricOrderListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FabricOrderLists.
     */
    data: XOR<FabricOrderListUpdateManyMutationInput, FabricOrderListUncheckedUpdateManyInput>
    /**
     * Filter which FabricOrderLists to update
     */
    where?: FabricOrderListWhereInput
    /**
     * Limit how many FabricOrderLists to update.
     */
    limit?: number
  }

  /**
   * FabricOrderList updateManyAndReturn
   */
  export type FabricOrderListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * The data used to update FabricOrderLists.
     */
    data: XOR<FabricOrderListUpdateManyMutationInput, FabricOrderListUncheckedUpdateManyInput>
    /**
     * Filter which FabricOrderLists to update
     */
    where?: FabricOrderListWhereInput
    /**
     * Limit how many FabricOrderLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FabricOrderList upsert
   */
  export type FabricOrderListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * The filter to search for the FabricOrderList to update in case it exists.
     */
    where: FabricOrderListWhereUniqueInput
    /**
     * In case the FabricOrderList found by the `where` argument doesn't exist, create a new FabricOrderList with this data.
     */
    create: XOR<FabricOrderListCreateInput, FabricOrderListUncheckedCreateInput>
    /**
     * In case the FabricOrderList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FabricOrderListUpdateInput, FabricOrderListUncheckedUpdateInput>
  }

  /**
   * FabricOrderList delete
   */
  export type FabricOrderListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    /**
     * Filter which FabricOrderList to delete.
     */
    where: FabricOrderListWhereUniqueInput
  }

  /**
   * FabricOrderList deleteMany
   */
  export type FabricOrderListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FabricOrderLists to delete
     */
    where?: FabricOrderListWhereInput
    /**
     * Limit how many FabricOrderLists to delete.
     */
    limit?: number
  }

  /**
   * FabricOrderList.fabric
   */
  export type FabricOrderList$fabricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    where?: FabricWhereInput
  }

  /**
   * FabricOrderList.supplier
   */
  export type FabricOrderList$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * FabricOrderList without action
   */
  export type FabricOrderListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
  }


  /**
   * Model FinalJacketMeasurement
   */

  export type AggregateFinalJacketMeasurement = {
    _count: FinalJacketMeasurementCountAggregateOutputType | null
    _avg: FinalJacketMeasurementAvgAggregateOutputType | null
    _sum: FinalJacketMeasurementSumAggregateOutputType | null
    _min: FinalJacketMeasurementMinAggregateOutputType | null
    _max: FinalJacketMeasurementMaxAggregateOutputType | null
  }

  export type FinalJacketMeasurementAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type FinalJacketMeasurementSumAggregateOutputType = {
    customer_id: number | null
  }

  export type FinalJacketMeasurementMinAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    jacket_length: string | null
    natural_length: string | null
    back_length: string | null
    x_back: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    waist_coat_length: string | null
    sherwani_length: string | null
    other_notes: string | null
  }

  export type FinalJacketMeasurementMaxAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    jacket_length: string | null
    natural_length: string | null
    back_length: string | null
    x_back: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    waist_coat_length: string | null
    sherwani_length: string | null
    other_notes: string | null
  }

  export type FinalJacketMeasurementCountAggregateOutputType = {
    measurement_id: number
    customer_id: number
    orderNo: number
    date: number
    jacket_length: number
    natural_length: number
    back_length: number
    x_back: number
    half_shoulder: number
    to_sleeve: number
    chest: number
    waist: number
    collar: number
    waist_coat_length: number
    sherwani_length: number
    other_notes: number
    _all: number
  }


  export type FinalJacketMeasurementAvgAggregateInputType = {
    customer_id?: true
  }

  export type FinalJacketMeasurementSumAggregateInputType = {
    customer_id?: true
  }

  export type FinalJacketMeasurementMinAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    jacket_length?: true
    natural_length?: true
    back_length?: true
    x_back?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    waist_coat_length?: true
    sherwani_length?: true
    other_notes?: true
  }

  export type FinalJacketMeasurementMaxAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    jacket_length?: true
    natural_length?: true
    back_length?: true
    x_back?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    waist_coat_length?: true
    sherwani_length?: true
    other_notes?: true
  }

  export type FinalJacketMeasurementCountAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    jacket_length?: true
    natural_length?: true
    back_length?: true
    x_back?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    waist_coat_length?: true
    sherwani_length?: true
    other_notes?: true
    _all?: true
  }

  export type FinalJacketMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalJacketMeasurement to aggregate.
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalJacketMeasurements to fetch.
     */
    orderBy?: FinalJacketMeasurementOrderByWithRelationInput | FinalJacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinalJacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalJacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalJacketMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinalJacketMeasurements
    **/
    _count?: true | FinalJacketMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinalJacketMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinalJacketMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinalJacketMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinalJacketMeasurementMaxAggregateInputType
  }

  export type GetFinalJacketMeasurementAggregateType<T extends FinalJacketMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateFinalJacketMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinalJacketMeasurement[P]>
      : GetScalarType<T[P], AggregateFinalJacketMeasurement[P]>
  }




  export type FinalJacketMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalJacketMeasurementWhereInput
    orderBy?: FinalJacketMeasurementOrderByWithAggregationInput | FinalJacketMeasurementOrderByWithAggregationInput[]
    by: FinalJacketMeasurementScalarFieldEnum[] | FinalJacketMeasurementScalarFieldEnum
    having?: FinalJacketMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinalJacketMeasurementCountAggregateInputType | true
    _avg?: FinalJacketMeasurementAvgAggregateInputType
    _sum?: FinalJacketMeasurementSumAggregateInputType
    _min?: FinalJacketMeasurementMinAggregateInputType
    _max?: FinalJacketMeasurementMaxAggregateInputType
  }

  export type FinalJacketMeasurementGroupByOutputType = {
    measurement_id: string
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    jacket_length: string | null
    natural_length: string | null
    back_length: string | null
    x_back: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    waist_coat_length: string | null
    sherwani_length: string | null
    other_notes: string | null
    _count: FinalJacketMeasurementCountAggregateOutputType | null
    _avg: FinalJacketMeasurementAvgAggregateOutputType | null
    _sum: FinalJacketMeasurementSumAggregateOutputType | null
    _min: FinalJacketMeasurementMinAggregateOutputType | null
    _max: FinalJacketMeasurementMaxAggregateOutputType | null
  }

  type GetFinalJacketMeasurementGroupByPayload<T extends FinalJacketMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinalJacketMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinalJacketMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinalJacketMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], FinalJacketMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type FinalJacketMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
    customer?: boolean | FinalJacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalJacketMeasurement$orderArgs<ExtArgs>
    Items?: boolean | FinalJacketMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | FinalJacketMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalJacketMeasurement"]>

  export type FinalJacketMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
    customer?: boolean | FinalJacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalJacketMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["finalJacketMeasurement"]>

  export type FinalJacketMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
    customer?: boolean | FinalJacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalJacketMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["finalJacketMeasurement"]>

  export type FinalJacketMeasurementSelectScalar = {
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
  }

  export type FinalJacketMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"measurement_id" | "customer_id" | "orderNo" | "date" | "jacket_length" | "natural_length" | "back_length" | "x_back" | "half_shoulder" | "to_sleeve" | "chest" | "waist" | "collar" | "waist_coat_length" | "sherwani_length" | "other_notes", ExtArgs["result"]["finalJacketMeasurement"]>
  export type FinalJacketMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalJacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalJacketMeasurement$orderArgs<ExtArgs>
    Items?: boolean | FinalJacketMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | FinalJacketMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinalJacketMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalJacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalJacketMeasurement$orderArgs<ExtArgs>
  }
  export type FinalJacketMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalJacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalJacketMeasurement$orderArgs<ExtArgs>
  }

  export type $FinalJacketMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinalJacketMeasurement"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs> | null
      Items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      measurement_id: string
      customer_id: number | null
      orderNo: string | null
      date: Date | null
      jacket_length: string | null
      natural_length: string | null
      back_length: string | null
      x_back: string | null
      half_shoulder: string | null
      to_sleeve: string | null
      chest: string | null
      waist: string | null
      collar: string | null
      waist_coat_length: string | null
      sherwani_length: string | null
      other_notes: string | null
    }, ExtArgs["result"]["finalJacketMeasurement"]>
    composites: {}
  }

  type FinalJacketMeasurementGetPayload<S extends boolean | null | undefined | FinalJacketMeasurementDefaultArgs> = $Result.GetResult<Prisma.$FinalJacketMeasurementPayload, S>

  type FinalJacketMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinalJacketMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinalJacketMeasurementCountAggregateInputType | true
    }

  export interface FinalJacketMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinalJacketMeasurement'], meta: { name: 'FinalJacketMeasurement' } }
    /**
     * Find zero or one FinalJacketMeasurement that matches the filter.
     * @param {FinalJacketMeasurementFindUniqueArgs} args - Arguments to find a FinalJacketMeasurement
     * @example
     * // Get one FinalJacketMeasurement
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinalJacketMeasurementFindUniqueArgs>(args: SelectSubset<T, FinalJacketMeasurementFindUniqueArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinalJacketMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinalJacketMeasurementFindUniqueOrThrowArgs} args - Arguments to find a FinalJacketMeasurement
     * @example
     * // Get one FinalJacketMeasurement
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinalJacketMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, FinalJacketMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalJacketMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementFindFirstArgs} args - Arguments to find a FinalJacketMeasurement
     * @example
     * // Get one FinalJacketMeasurement
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinalJacketMeasurementFindFirstArgs>(args?: SelectSubset<T, FinalJacketMeasurementFindFirstArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalJacketMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementFindFirstOrThrowArgs} args - Arguments to find a FinalJacketMeasurement
     * @example
     * // Get one FinalJacketMeasurement
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinalJacketMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, FinalJacketMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinalJacketMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinalJacketMeasurements
     * const finalJacketMeasurements = await prisma.finalJacketMeasurement.findMany()
     * 
     * // Get first 10 FinalJacketMeasurements
     * const finalJacketMeasurements = await prisma.finalJacketMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `measurement_id`
     * const finalJacketMeasurementWithMeasurement_idOnly = await prisma.finalJacketMeasurement.findMany({ select: { measurement_id: true } })
     * 
     */
    findMany<T extends FinalJacketMeasurementFindManyArgs>(args?: SelectSubset<T, FinalJacketMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinalJacketMeasurement.
     * @param {FinalJacketMeasurementCreateArgs} args - Arguments to create a FinalJacketMeasurement.
     * @example
     * // Create one FinalJacketMeasurement
     * const FinalJacketMeasurement = await prisma.finalJacketMeasurement.create({
     *   data: {
     *     // ... data to create a FinalJacketMeasurement
     *   }
     * })
     * 
     */
    create<T extends FinalJacketMeasurementCreateArgs>(args: SelectSubset<T, FinalJacketMeasurementCreateArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinalJacketMeasurements.
     * @param {FinalJacketMeasurementCreateManyArgs} args - Arguments to create many FinalJacketMeasurements.
     * @example
     * // Create many FinalJacketMeasurements
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinalJacketMeasurementCreateManyArgs>(args?: SelectSubset<T, FinalJacketMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinalJacketMeasurements and returns the data saved in the database.
     * @param {FinalJacketMeasurementCreateManyAndReturnArgs} args - Arguments to create many FinalJacketMeasurements.
     * @example
     * // Create many FinalJacketMeasurements
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinalJacketMeasurements and only return the `measurement_id`
     * const finalJacketMeasurementWithMeasurement_idOnly = await prisma.finalJacketMeasurement.createManyAndReturn({
     *   select: { measurement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinalJacketMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, FinalJacketMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinalJacketMeasurement.
     * @param {FinalJacketMeasurementDeleteArgs} args - Arguments to delete one FinalJacketMeasurement.
     * @example
     * // Delete one FinalJacketMeasurement
     * const FinalJacketMeasurement = await prisma.finalJacketMeasurement.delete({
     *   where: {
     *     // ... filter to delete one FinalJacketMeasurement
     *   }
     * })
     * 
     */
    delete<T extends FinalJacketMeasurementDeleteArgs>(args: SelectSubset<T, FinalJacketMeasurementDeleteArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinalJacketMeasurement.
     * @param {FinalJacketMeasurementUpdateArgs} args - Arguments to update one FinalJacketMeasurement.
     * @example
     * // Update one FinalJacketMeasurement
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinalJacketMeasurementUpdateArgs>(args: SelectSubset<T, FinalJacketMeasurementUpdateArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinalJacketMeasurements.
     * @param {FinalJacketMeasurementDeleteManyArgs} args - Arguments to filter FinalJacketMeasurements to delete.
     * @example
     * // Delete a few FinalJacketMeasurements
     * const { count } = await prisma.finalJacketMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinalJacketMeasurementDeleteManyArgs>(args?: SelectSubset<T, FinalJacketMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalJacketMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinalJacketMeasurements
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinalJacketMeasurementUpdateManyArgs>(args: SelectSubset<T, FinalJacketMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalJacketMeasurements and returns the data updated in the database.
     * @param {FinalJacketMeasurementUpdateManyAndReturnArgs} args - Arguments to update many FinalJacketMeasurements.
     * @example
     * // Update many FinalJacketMeasurements
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinalJacketMeasurements and only return the `measurement_id`
     * const finalJacketMeasurementWithMeasurement_idOnly = await prisma.finalJacketMeasurement.updateManyAndReturn({
     *   select: { measurement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinalJacketMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, FinalJacketMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinalJacketMeasurement.
     * @param {FinalJacketMeasurementUpsertArgs} args - Arguments to update or create a FinalJacketMeasurement.
     * @example
     * // Update or create a FinalJacketMeasurement
     * const finalJacketMeasurement = await prisma.finalJacketMeasurement.upsert({
     *   create: {
     *     // ... data to create a FinalJacketMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinalJacketMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends FinalJacketMeasurementUpsertArgs>(args: SelectSubset<T, FinalJacketMeasurementUpsertArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinalJacketMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementCountArgs} args - Arguments to filter FinalJacketMeasurements to count.
     * @example
     * // Count the number of FinalJacketMeasurements
     * const count = await prisma.finalJacketMeasurement.count({
     *   where: {
     *     // ... the filter for the FinalJacketMeasurements we want to count
     *   }
     * })
    **/
    count<T extends FinalJacketMeasurementCountArgs>(
      args?: Subset<T, FinalJacketMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinalJacketMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinalJacketMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinalJacketMeasurementAggregateArgs>(args: Subset<T, FinalJacketMeasurementAggregateArgs>): Prisma.PrismaPromise<GetFinalJacketMeasurementAggregateType<T>>

    /**
     * Group by FinalJacketMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalJacketMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinalJacketMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinalJacketMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: FinalJacketMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinalJacketMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinalJacketMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinalJacketMeasurement model
   */
  readonly fields: FinalJacketMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinalJacketMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinalJacketMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends FinalJacketMeasurement$customerArgs<ExtArgs> = {}>(args?: Subset<T, FinalJacketMeasurement$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends FinalJacketMeasurement$orderArgs<ExtArgs> = {}>(args?: Subset<T, FinalJacketMeasurement$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Items<T extends FinalJacketMeasurement$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, FinalJacketMeasurement$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinalJacketMeasurement model
   */
  interface FinalJacketMeasurementFieldRefs {
    readonly measurement_id: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly customer_id: FieldRef<"FinalJacketMeasurement", 'Int'>
    readonly orderNo: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly date: FieldRef<"FinalJacketMeasurement", 'DateTime'>
    readonly jacket_length: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly natural_length: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly back_length: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly x_back: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly half_shoulder: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly to_sleeve: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly chest: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly waist: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly collar: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly waist_coat_length: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly sherwani_length: FieldRef<"FinalJacketMeasurement", 'String'>
    readonly other_notes: FieldRef<"FinalJacketMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FinalJacketMeasurement findUnique
   */
  export type FinalJacketMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalJacketMeasurement to fetch.
     */
    where: FinalJacketMeasurementWhereUniqueInput
  }

  /**
   * FinalJacketMeasurement findUniqueOrThrow
   */
  export type FinalJacketMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalJacketMeasurement to fetch.
     */
    where: FinalJacketMeasurementWhereUniqueInput
  }

  /**
   * FinalJacketMeasurement findFirst
   */
  export type FinalJacketMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalJacketMeasurement to fetch.
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalJacketMeasurements to fetch.
     */
    orderBy?: FinalJacketMeasurementOrderByWithRelationInput | FinalJacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalJacketMeasurements.
     */
    cursor?: FinalJacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalJacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalJacketMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalJacketMeasurements.
     */
    distinct?: FinalJacketMeasurementScalarFieldEnum | FinalJacketMeasurementScalarFieldEnum[]
  }

  /**
   * FinalJacketMeasurement findFirstOrThrow
   */
  export type FinalJacketMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalJacketMeasurement to fetch.
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalJacketMeasurements to fetch.
     */
    orderBy?: FinalJacketMeasurementOrderByWithRelationInput | FinalJacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalJacketMeasurements.
     */
    cursor?: FinalJacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalJacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalJacketMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalJacketMeasurements.
     */
    distinct?: FinalJacketMeasurementScalarFieldEnum | FinalJacketMeasurementScalarFieldEnum[]
  }

  /**
   * FinalJacketMeasurement findMany
   */
  export type FinalJacketMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalJacketMeasurements to fetch.
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalJacketMeasurements to fetch.
     */
    orderBy?: FinalJacketMeasurementOrderByWithRelationInput | FinalJacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinalJacketMeasurements.
     */
    cursor?: FinalJacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalJacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalJacketMeasurements.
     */
    skip?: number
    distinct?: FinalJacketMeasurementScalarFieldEnum | FinalJacketMeasurementScalarFieldEnum[]
  }

  /**
   * FinalJacketMeasurement create
   */
  export type FinalJacketMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a FinalJacketMeasurement.
     */
    data?: XOR<FinalJacketMeasurementCreateInput, FinalJacketMeasurementUncheckedCreateInput>
  }

  /**
   * FinalJacketMeasurement createMany
   */
  export type FinalJacketMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinalJacketMeasurements.
     */
    data: FinalJacketMeasurementCreateManyInput | FinalJacketMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinalJacketMeasurement createManyAndReturn
   */
  export type FinalJacketMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many FinalJacketMeasurements.
     */
    data: FinalJacketMeasurementCreateManyInput | FinalJacketMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalJacketMeasurement update
   */
  export type FinalJacketMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a FinalJacketMeasurement.
     */
    data: XOR<FinalJacketMeasurementUpdateInput, FinalJacketMeasurementUncheckedUpdateInput>
    /**
     * Choose, which FinalJacketMeasurement to update.
     */
    where: FinalJacketMeasurementWhereUniqueInput
  }

  /**
   * FinalJacketMeasurement updateMany
   */
  export type FinalJacketMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinalJacketMeasurements.
     */
    data: XOR<FinalJacketMeasurementUpdateManyMutationInput, FinalJacketMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which FinalJacketMeasurements to update
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * Limit how many FinalJacketMeasurements to update.
     */
    limit?: number
  }

  /**
   * FinalJacketMeasurement updateManyAndReturn
   */
  export type FinalJacketMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update FinalJacketMeasurements.
     */
    data: XOR<FinalJacketMeasurementUpdateManyMutationInput, FinalJacketMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which FinalJacketMeasurements to update
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * Limit how many FinalJacketMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalJacketMeasurement upsert
   */
  export type FinalJacketMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the FinalJacketMeasurement to update in case it exists.
     */
    where: FinalJacketMeasurementWhereUniqueInput
    /**
     * In case the FinalJacketMeasurement found by the `where` argument doesn't exist, create a new FinalJacketMeasurement with this data.
     */
    create: XOR<FinalJacketMeasurementCreateInput, FinalJacketMeasurementUncheckedCreateInput>
    /**
     * In case the FinalJacketMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinalJacketMeasurementUpdateInput, FinalJacketMeasurementUncheckedUpdateInput>
  }

  /**
   * FinalJacketMeasurement delete
   */
  export type FinalJacketMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter which FinalJacketMeasurement to delete.
     */
    where: FinalJacketMeasurementWhereUniqueInput
  }

  /**
   * FinalJacketMeasurement deleteMany
   */
  export type FinalJacketMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalJacketMeasurements to delete
     */
    where?: FinalJacketMeasurementWhereInput
    /**
     * Limit how many FinalJacketMeasurements to delete.
     */
    limit?: number
  }

  /**
   * FinalJacketMeasurement.customer
   */
  export type FinalJacketMeasurement$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * FinalJacketMeasurement.order
   */
  export type FinalJacketMeasurement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * FinalJacketMeasurement.Items
   */
  export type FinalJacketMeasurement$ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * FinalJacketMeasurement without action
   */
  export type FinalJacketMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model JacketMeasurement
   */

  export type AggregateJacketMeasurement = {
    _count: JacketMeasurementCountAggregateOutputType | null
    _avg: JacketMeasurementAvgAggregateOutputType | null
    _sum: JacketMeasurementSumAggregateOutputType | null
    _min: JacketMeasurementMinAggregateOutputType | null
    _max: JacketMeasurementMaxAggregateOutputType | null
  }

  export type JacketMeasurementAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type JacketMeasurementSumAggregateOutputType = {
    customer_id: number | null
  }

  export type JacketMeasurementMinAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    jacket_length: string | null
    natural_length: string | null
    back_length: string | null
    x_back: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    waist_coat_length: string | null
    sherwani_length: string | null
    other_notes: string | null
  }

  export type JacketMeasurementMaxAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    jacket_length: string | null
    natural_length: string | null
    back_length: string | null
    x_back: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    waist_coat_length: string | null
    sherwani_length: string | null
    other_notes: string | null
  }

  export type JacketMeasurementCountAggregateOutputType = {
    measurement_id: number
    customer_id: number
    orderNo: number
    date: number
    jacket_length: number
    natural_length: number
    back_length: number
    x_back: number
    half_shoulder: number
    to_sleeve: number
    chest: number
    waist: number
    collar: number
    waist_coat_length: number
    sherwani_length: number
    other_notes: number
    _all: number
  }


  export type JacketMeasurementAvgAggregateInputType = {
    customer_id?: true
  }

  export type JacketMeasurementSumAggregateInputType = {
    customer_id?: true
  }

  export type JacketMeasurementMinAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    jacket_length?: true
    natural_length?: true
    back_length?: true
    x_back?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    waist_coat_length?: true
    sherwani_length?: true
    other_notes?: true
  }

  export type JacketMeasurementMaxAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    jacket_length?: true
    natural_length?: true
    back_length?: true
    x_back?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    waist_coat_length?: true
    sherwani_length?: true
    other_notes?: true
  }

  export type JacketMeasurementCountAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    jacket_length?: true
    natural_length?: true
    back_length?: true
    x_back?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    waist_coat_length?: true
    sherwani_length?: true
    other_notes?: true
    _all?: true
  }

  export type JacketMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JacketMeasurement to aggregate.
     */
    where?: JacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JacketMeasurements to fetch.
     */
    orderBy?: JacketMeasurementOrderByWithRelationInput | JacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JacketMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JacketMeasurements
    **/
    _count?: true | JacketMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JacketMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JacketMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JacketMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JacketMeasurementMaxAggregateInputType
  }

  export type GetJacketMeasurementAggregateType<T extends JacketMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateJacketMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJacketMeasurement[P]>
      : GetScalarType<T[P], AggregateJacketMeasurement[P]>
  }




  export type JacketMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JacketMeasurementWhereInput
    orderBy?: JacketMeasurementOrderByWithAggregationInput | JacketMeasurementOrderByWithAggregationInput[]
    by: JacketMeasurementScalarFieldEnum[] | JacketMeasurementScalarFieldEnum
    having?: JacketMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JacketMeasurementCountAggregateInputType | true
    _avg?: JacketMeasurementAvgAggregateInputType
    _sum?: JacketMeasurementSumAggregateInputType
    _min?: JacketMeasurementMinAggregateInputType
    _max?: JacketMeasurementMaxAggregateInputType
  }

  export type JacketMeasurementGroupByOutputType = {
    measurement_id: string
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    jacket_length: string | null
    natural_length: string | null
    back_length: string | null
    x_back: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    waist_coat_length: string | null
    sherwani_length: string | null
    other_notes: string | null
    _count: JacketMeasurementCountAggregateOutputType | null
    _avg: JacketMeasurementAvgAggregateOutputType | null
    _sum: JacketMeasurementSumAggregateOutputType | null
    _min: JacketMeasurementMinAggregateOutputType | null
    _max: JacketMeasurementMaxAggregateOutputType | null
  }

  type GetJacketMeasurementGroupByPayload<T extends JacketMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JacketMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JacketMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JacketMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], JacketMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type JacketMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
    customer?: boolean | JacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | JacketMeasurement$orderArgs<ExtArgs>
    Items?: boolean | JacketMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | JacketMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jacketMeasurement"]>

  export type JacketMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
    customer?: boolean | JacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | JacketMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["jacketMeasurement"]>

  export type JacketMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
    customer?: boolean | JacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | JacketMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["jacketMeasurement"]>

  export type JacketMeasurementSelectScalar = {
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    jacket_length?: boolean
    natural_length?: boolean
    back_length?: boolean
    x_back?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    waist_coat_length?: boolean
    sherwani_length?: boolean
    other_notes?: boolean
  }

  export type JacketMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"measurement_id" | "customer_id" | "orderNo" | "date" | "jacket_length" | "natural_length" | "back_length" | "x_back" | "half_shoulder" | "to_sleeve" | "chest" | "waist" | "collar" | "waist_coat_length" | "sherwani_length" | "other_notes", ExtArgs["result"]["jacketMeasurement"]>
  export type JacketMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | JacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | JacketMeasurement$orderArgs<ExtArgs>
    Items?: boolean | JacketMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | JacketMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JacketMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | JacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | JacketMeasurement$orderArgs<ExtArgs>
  }
  export type JacketMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | JacketMeasurement$customerArgs<ExtArgs>
    order?: boolean | JacketMeasurement$orderArgs<ExtArgs>
  }

  export type $JacketMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JacketMeasurement"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs> | null
      Items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      measurement_id: string
      customer_id: number | null
      orderNo: string | null
      date: Date | null
      jacket_length: string | null
      natural_length: string | null
      back_length: string | null
      x_back: string | null
      half_shoulder: string | null
      to_sleeve: string | null
      chest: string | null
      waist: string | null
      collar: string | null
      waist_coat_length: string | null
      sherwani_length: string | null
      other_notes: string | null
    }, ExtArgs["result"]["jacketMeasurement"]>
    composites: {}
  }

  type JacketMeasurementGetPayload<S extends boolean | null | undefined | JacketMeasurementDefaultArgs> = $Result.GetResult<Prisma.$JacketMeasurementPayload, S>

  type JacketMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JacketMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JacketMeasurementCountAggregateInputType | true
    }

  export interface JacketMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JacketMeasurement'], meta: { name: 'JacketMeasurement' } }
    /**
     * Find zero or one JacketMeasurement that matches the filter.
     * @param {JacketMeasurementFindUniqueArgs} args - Arguments to find a JacketMeasurement
     * @example
     * // Get one JacketMeasurement
     * const jacketMeasurement = await prisma.jacketMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JacketMeasurementFindUniqueArgs>(args: SelectSubset<T, JacketMeasurementFindUniqueArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JacketMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JacketMeasurementFindUniqueOrThrowArgs} args - Arguments to find a JacketMeasurement
     * @example
     * // Get one JacketMeasurement
     * const jacketMeasurement = await prisma.jacketMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JacketMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, JacketMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JacketMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementFindFirstArgs} args - Arguments to find a JacketMeasurement
     * @example
     * // Get one JacketMeasurement
     * const jacketMeasurement = await prisma.jacketMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JacketMeasurementFindFirstArgs>(args?: SelectSubset<T, JacketMeasurementFindFirstArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JacketMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementFindFirstOrThrowArgs} args - Arguments to find a JacketMeasurement
     * @example
     * // Get one JacketMeasurement
     * const jacketMeasurement = await prisma.jacketMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JacketMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, JacketMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JacketMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JacketMeasurements
     * const jacketMeasurements = await prisma.jacketMeasurement.findMany()
     * 
     * // Get first 10 JacketMeasurements
     * const jacketMeasurements = await prisma.jacketMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `measurement_id`
     * const jacketMeasurementWithMeasurement_idOnly = await prisma.jacketMeasurement.findMany({ select: { measurement_id: true } })
     * 
     */
    findMany<T extends JacketMeasurementFindManyArgs>(args?: SelectSubset<T, JacketMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JacketMeasurement.
     * @param {JacketMeasurementCreateArgs} args - Arguments to create a JacketMeasurement.
     * @example
     * // Create one JacketMeasurement
     * const JacketMeasurement = await prisma.jacketMeasurement.create({
     *   data: {
     *     // ... data to create a JacketMeasurement
     *   }
     * })
     * 
     */
    create<T extends JacketMeasurementCreateArgs>(args: SelectSubset<T, JacketMeasurementCreateArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JacketMeasurements.
     * @param {JacketMeasurementCreateManyArgs} args - Arguments to create many JacketMeasurements.
     * @example
     * // Create many JacketMeasurements
     * const jacketMeasurement = await prisma.jacketMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JacketMeasurementCreateManyArgs>(args?: SelectSubset<T, JacketMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JacketMeasurements and returns the data saved in the database.
     * @param {JacketMeasurementCreateManyAndReturnArgs} args - Arguments to create many JacketMeasurements.
     * @example
     * // Create many JacketMeasurements
     * const jacketMeasurement = await prisma.jacketMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JacketMeasurements and only return the `measurement_id`
     * const jacketMeasurementWithMeasurement_idOnly = await prisma.jacketMeasurement.createManyAndReturn({
     *   select: { measurement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JacketMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, JacketMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JacketMeasurement.
     * @param {JacketMeasurementDeleteArgs} args - Arguments to delete one JacketMeasurement.
     * @example
     * // Delete one JacketMeasurement
     * const JacketMeasurement = await prisma.jacketMeasurement.delete({
     *   where: {
     *     // ... filter to delete one JacketMeasurement
     *   }
     * })
     * 
     */
    delete<T extends JacketMeasurementDeleteArgs>(args: SelectSubset<T, JacketMeasurementDeleteArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JacketMeasurement.
     * @param {JacketMeasurementUpdateArgs} args - Arguments to update one JacketMeasurement.
     * @example
     * // Update one JacketMeasurement
     * const jacketMeasurement = await prisma.jacketMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JacketMeasurementUpdateArgs>(args: SelectSubset<T, JacketMeasurementUpdateArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JacketMeasurements.
     * @param {JacketMeasurementDeleteManyArgs} args - Arguments to filter JacketMeasurements to delete.
     * @example
     * // Delete a few JacketMeasurements
     * const { count } = await prisma.jacketMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JacketMeasurementDeleteManyArgs>(args?: SelectSubset<T, JacketMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JacketMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JacketMeasurements
     * const jacketMeasurement = await prisma.jacketMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JacketMeasurementUpdateManyArgs>(args: SelectSubset<T, JacketMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JacketMeasurements and returns the data updated in the database.
     * @param {JacketMeasurementUpdateManyAndReturnArgs} args - Arguments to update many JacketMeasurements.
     * @example
     * // Update many JacketMeasurements
     * const jacketMeasurement = await prisma.jacketMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JacketMeasurements and only return the `measurement_id`
     * const jacketMeasurementWithMeasurement_idOnly = await prisma.jacketMeasurement.updateManyAndReturn({
     *   select: { measurement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JacketMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, JacketMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JacketMeasurement.
     * @param {JacketMeasurementUpsertArgs} args - Arguments to update or create a JacketMeasurement.
     * @example
     * // Update or create a JacketMeasurement
     * const jacketMeasurement = await prisma.jacketMeasurement.upsert({
     *   create: {
     *     // ... data to create a JacketMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JacketMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends JacketMeasurementUpsertArgs>(args: SelectSubset<T, JacketMeasurementUpsertArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JacketMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementCountArgs} args - Arguments to filter JacketMeasurements to count.
     * @example
     * // Count the number of JacketMeasurements
     * const count = await prisma.jacketMeasurement.count({
     *   where: {
     *     // ... the filter for the JacketMeasurements we want to count
     *   }
     * })
    **/
    count<T extends JacketMeasurementCountArgs>(
      args?: Subset<T, JacketMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JacketMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JacketMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JacketMeasurementAggregateArgs>(args: Subset<T, JacketMeasurementAggregateArgs>): Prisma.PrismaPromise<GetJacketMeasurementAggregateType<T>>

    /**
     * Group by JacketMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JacketMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JacketMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JacketMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: JacketMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JacketMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJacketMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JacketMeasurement model
   */
  readonly fields: JacketMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JacketMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JacketMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends JacketMeasurement$customerArgs<ExtArgs> = {}>(args?: Subset<T, JacketMeasurement$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends JacketMeasurement$orderArgs<ExtArgs> = {}>(args?: Subset<T, JacketMeasurement$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Items<T extends JacketMeasurement$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, JacketMeasurement$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JacketMeasurement model
   */
  interface JacketMeasurementFieldRefs {
    readonly measurement_id: FieldRef<"JacketMeasurement", 'String'>
    readonly customer_id: FieldRef<"JacketMeasurement", 'Int'>
    readonly orderNo: FieldRef<"JacketMeasurement", 'String'>
    readonly date: FieldRef<"JacketMeasurement", 'DateTime'>
    readonly jacket_length: FieldRef<"JacketMeasurement", 'String'>
    readonly natural_length: FieldRef<"JacketMeasurement", 'String'>
    readonly back_length: FieldRef<"JacketMeasurement", 'String'>
    readonly x_back: FieldRef<"JacketMeasurement", 'String'>
    readonly half_shoulder: FieldRef<"JacketMeasurement", 'String'>
    readonly to_sleeve: FieldRef<"JacketMeasurement", 'String'>
    readonly chest: FieldRef<"JacketMeasurement", 'String'>
    readonly waist: FieldRef<"JacketMeasurement", 'String'>
    readonly collar: FieldRef<"JacketMeasurement", 'String'>
    readonly waist_coat_length: FieldRef<"JacketMeasurement", 'String'>
    readonly sherwani_length: FieldRef<"JacketMeasurement", 'String'>
    readonly other_notes: FieldRef<"JacketMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JacketMeasurement findUnique
   */
  export type JacketMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which JacketMeasurement to fetch.
     */
    where: JacketMeasurementWhereUniqueInput
  }

  /**
   * JacketMeasurement findUniqueOrThrow
   */
  export type JacketMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which JacketMeasurement to fetch.
     */
    where: JacketMeasurementWhereUniqueInput
  }

  /**
   * JacketMeasurement findFirst
   */
  export type JacketMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which JacketMeasurement to fetch.
     */
    where?: JacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JacketMeasurements to fetch.
     */
    orderBy?: JacketMeasurementOrderByWithRelationInput | JacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JacketMeasurements.
     */
    cursor?: JacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JacketMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JacketMeasurements.
     */
    distinct?: JacketMeasurementScalarFieldEnum | JacketMeasurementScalarFieldEnum[]
  }

  /**
   * JacketMeasurement findFirstOrThrow
   */
  export type JacketMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which JacketMeasurement to fetch.
     */
    where?: JacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JacketMeasurements to fetch.
     */
    orderBy?: JacketMeasurementOrderByWithRelationInput | JacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JacketMeasurements.
     */
    cursor?: JacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JacketMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JacketMeasurements.
     */
    distinct?: JacketMeasurementScalarFieldEnum | JacketMeasurementScalarFieldEnum[]
  }

  /**
   * JacketMeasurement findMany
   */
  export type JacketMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which JacketMeasurements to fetch.
     */
    where?: JacketMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JacketMeasurements to fetch.
     */
    orderBy?: JacketMeasurementOrderByWithRelationInput | JacketMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JacketMeasurements.
     */
    cursor?: JacketMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JacketMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JacketMeasurements.
     */
    skip?: number
    distinct?: JacketMeasurementScalarFieldEnum | JacketMeasurementScalarFieldEnum[]
  }

  /**
   * JacketMeasurement create
   */
  export type JacketMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a JacketMeasurement.
     */
    data?: XOR<JacketMeasurementCreateInput, JacketMeasurementUncheckedCreateInput>
  }

  /**
   * JacketMeasurement createMany
   */
  export type JacketMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JacketMeasurements.
     */
    data: JacketMeasurementCreateManyInput | JacketMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JacketMeasurement createManyAndReturn
   */
  export type JacketMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many JacketMeasurements.
     */
    data: JacketMeasurementCreateManyInput | JacketMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JacketMeasurement update
   */
  export type JacketMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a JacketMeasurement.
     */
    data: XOR<JacketMeasurementUpdateInput, JacketMeasurementUncheckedUpdateInput>
    /**
     * Choose, which JacketMeasurement to update.
     */
    where: JacketMeasurementWhereUniqueInput
  }

  /**
   * JacketMeasurement updateMany
   */
  export type JacketMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JacketMeasurements.
     */
    data: XOR<JacketMeasurementUpdateManyMutationInput, JacketMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which JacketMeasurements to update
     */
    where?: JacketMeasurementWhereInput
    /**
     * Limit how many JacketMeasurements to update.
     */
    limit?: number
  }

  /**
   * JacketMeasurement updateManyAndReturn
   */
  export type JacketMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update JacketMeasurements.
     */
    data: XOR<JacketMeasurementUpdateManyMutationInput, JacketMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which JacketMeasurements to update
     */
    where?: JacketMeasurementWhereInput
    /**
     * Limit how many JacketMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JacketMeasurement upsert
   */
  export type JacketMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the JacketMeasurement to update in case it exists.
     */
    where: JacketMeasurementWhereUniqueInput
    /**
     * In case the JacketMeasurement found by the `where` argument doesn't exist, create a new JacketMeasurement with this data.
     */
    create: XOR<JacketMeasurementCreateInput, JacketMeasurementUncheckedCreateInput>
    /**
     * In case the JacketMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JacketMeasurementUpdateInput, JacketMeasurementUncheckedUpdateInput>
  }

  /**
   * JacketMeasurement delete
   */
  export type JacketMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    /**
     * Filter which JacketMeasurement to delete.
     */
    where: JacketMeasurementWhereUniqueInput
  }

  /**
   * JacketMeasurement deleteMany
   */
  export type JacketMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JacketMeasurements to delete
     */
    where?: JacketMeasurementWhereInput
    /**
     * Limit how many JacketMeasurements to delete.
     */
    limit?: number
  }

  /**
   * JacketMeasurement.customer
   */
  export type JacketMeasurement$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * JacketMeasurement.order
   */
  export type JacketMeasurement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * JacketMeasurement.Items
   */
  export type JacketMeasurement$ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * JacketMeasurement without action
   */
  export type JacketMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model FinalPantMeasurement
   */

  export type AggregateFinalPantMeasurement = {
    _count: FinalPantMeasurementCountAggregateOutputType | null
    _avg: FinalPantMeasurementAvgAggregateOutputType | null
    _sum: FinalPantMeasurementSumAggregateOutputType | null
    _min: FinalPantMeasurementMinAggregateOutputType | null
    _max: FinalPantMeasurementMaxAggregateOutputType | null
  }

  export type FinalPantMeasurementAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type FinalPantMeasurementSumAggregateOutputType = {
    customer_id: number | null
  }

  export type FinalPantMeasurementMinAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    inseem: string | null
    waist: string | null
    hips: string | null
    bottom: string | null
    knee: string | null
    other_notes: string | null
  }

  export type FinalPantMeasurementMaxAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    inseem: string | null
    waist: string | null
    hips: string | null
    bottom: string | null
    knee: string | null
    other_notes: string | null
  }

  export type FinalPantMeasurementCountAggregateOutputType = {
    measurement_id: number
    customer_id: number
    orderNo: number
    date: number
    length: number
    inseem: number
    waist: number
    hips: number
    bottom: number
    knee: number
    other_notes: number
    _all: number
  }


  export type FinalPantMeasurementAvgAggregateInputType = {
    customer_id?: true
  }

  export type FinalPantMeasurementSumAggregateInputType = {
    customer_id?: true
  }

  export type FinalPantMeasurementMinAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    inseem?: true
    waist?: true
    hips?: true
    bottom?: true
    knee?: true
    other_notes?: true
  }

  export type FinalPantMeasurementMaxAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    inseem?: true
    waist?: true
    hips?: true
    bottom?: true
    knee?: true
    other_notes?: true
  }

  export type FinalPantMeasurementCountAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    inseem?: true
    waist?: true
    hips?: true
    bottom?: true
    knee?: true
    other_notes?: true
    _all?: true
  }

  export type FinalPantMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalPantMeasurement to aggregate.
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalPantMeasurements to fetch.
     */
    orderBy?: FinalPantMeasurementOrderByWithRelationInput | FinalPantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinalPantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalPantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalPantMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinalPantMeasurements
    **/
    _count?: true | FinalPantMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinalPantMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinalPantMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinalPantMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinalPantMeasurementMaxAggregateInputType
  }

  export type GetFinalPantMeasurementAggregateType<T extends FinalPantMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateFinalPantMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinalPantMeasurement[P]>
      : GetScalarType<T[P], AggregateFinalPantMeasurement[P]>
  }




  export type FinalPantMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalPantMeasurementWhereInput
    orderBy?: FinalPantMeasurementOrderByWithAggregationInput | FinalPantMeasurementOrderByWithAggregationInput[]
    by: FinalPantMeasurementScalarFieldEnum[] | FinalPantMeasurementScalarFieldEnum
    having?: FinalPantMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinalPantMeasurementCountAggregateInputType | true
    _avg?: FinalPantMeasurementAvgAggregateInputType
    _sum?: FinalPantMeasurementSumAggregateInputType
    _min?: FinalPantMeasurementMinAggregateInputType
    _max?: FinalPantMeasurementMaxAggregateInputType
  }

  export type FinalPantMeasurementGroupByOutputType = {
    measurement_id: string
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    inseem: string | null
    waist: string | null
    hips: string | null
    bottom: string | null
    knee: string | null
    other_notes: string | null
    _count: FinalPantMeasurementCountAggregateOutputType | null
    _avg: FinalPantMeasurementAvgAggregateOutputType | null
    _sum: FinalPantMeasurementSumAggregateOutputType | null
    _min: FinalPantMeasurementMinAggregateOutputType | null
    _max: FinalPantMeasurementMaxAggregateOutputType | null
  }

  type GetFinalPantMeasurementGroupByPayload<T extends FinalPantMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinalPantMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinalPantMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinalPantMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], FinalPantMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type FinalPantMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
    customer?: boolean | FinalPantMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalPantMeasurement$orderArgs<ExtArgs>
    Items?: boolean | FinalPantMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | FinalPantMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalPantMeasurement"]>

  export type FinalPantMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
    customer?: boolean | FinalPantMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalPantMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["finalPantMeasurement"]>

  export type FinalPantMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
    customer?: boolean | FinalPantMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalPantMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["finalPantMeasurement"]>

  export type FinalPantMeasurementSelectScalar = {
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
  }

  export type FinalPantMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"measurement_id" | "customer_id" | "orderNo" | "date" | "length" | "inseem" | "waist" | "hips" | "bottom" | "knee" | "other_notes", ExtArgs["result"]["finalPantMeasurement"]>
  export type FinalPantMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalPantMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalPantMeasurement$orderArgs<ExtArgs>
    Items?: boolean | FinalPantMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | FinalPantMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinalPantMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalPantMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalPantMeasurement$orderArgs<ExtArgs>
  }
  export type FinalPantMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalPantMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalPantMeasurement$orderArgs<ExtArgs>
  }

  export type $FinalPantMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinalPantMeasurement"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs> | null
      Items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      measurement_id: string
      customer_id: number | null
      orderNo: string | null
      date: Date | null
      length: string | null
      inseem: string | null
      waist: string | null
      hips: string | null
      bottom: string | null
      knee: string | null
      other_notes: string | null
    }, ExtArgs["result"]["finalPantMeasurement"]>
    composites: {}
  }

  type FinalPantMeasurementGetPayload<S extends boolean | null | undefined | FinalPantMeasurementDefaultArgs> = $Result.GetResult<Prisma.$FinalPantMeasurementPayload, S>

  type FinalPantMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinalPantMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinalPantMeasurementCountAggregateInputType | true
    }

  export interface FinalPantMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinalPantMeasurement'], meta: { name: 'FinalPantMeasurement' } }
    /**
     * Find zero or one FinalPantMeasurement that matches the filter.
     * @param {FinalPantMeasurementFindUniqueArgs} args - Arguments to find a FinalPantMeasurement
     * @example
     * // Get one FinalPantMeasurement
     * const finalPantMeasurement = await prisma.finalPantMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinalPantMeasurementFindUniqueArgs>(args: SelectSubset<T, FinalPantMeasurementFindUniqueArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinalPantMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinalPantMeasurementFindUniqueOrThrowArgs} args - Arguments to find a FinalPantMeasurement
     * @example
     * // Get one FinalPantMeasurement
     * const finalPantMeasurement = await prisma.finalPantMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinalPantMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, FinalPantMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalPantMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementFindFirstArgs} args - Arguments to find a FinalPantMeasurement
     * @example
     * // Get one FinalPantMeasurement
     * const finalPantMeasurement = await prisma.finalPantMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinalPantMeasurementFindFirstArgs>(args?: SelectSubset<T, FinalPantMeasurementFindFirstArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalPantMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementFindFirstOrThrowArgs} args - Arguments to find a FinalPantMeasurement
     * @example
     * // Get one FinalPantMeasurement
     * const finalPantMeasurement = await prisma.finalPantMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinalPantMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, FinalPantMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinalPantMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinalPantMeasurements
     * const finalPantMeasurements = await prisma.finalPantMeasurement.findMany()
     * 
     * // Get first 10 FinalPantMeasurements
     * const finalPantMeasurements = await prisma.finalPantMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `measurement_id`
     * const finalPantMeasurementWithMeasurement_idOnly = await prisma.finalPantMeasurement.findMany({ select: { measurement_id: true } })
     * 
     */
    findMany<T extends FinalPantMeasurementFindManyArgs>(args?: SelectSubset<T, FinalPantMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinalPantMeasurement.
     * @param {FinalPantMeasurementCreateArgs} args - Arguments to create a FinalPantMeasurement.
     * @example
     * // Create one FinalPantMeasurement
     * const FinalPantMeasurement = await prisma.finalPantMeasurement.create({
     *   data: {
     *     // ... data to create a FinalPantMeasurement
     *   }
     * })
     * 
     */
    create<T extends FinalPantMeasurementCreateArgs>(args: SelectSubset<T, FinalPantMeasurementCreateArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinalPantMeasurements.
     * @param {FinalPantMeasurementCreateManyArgs} args - Arguments to create many FinalPantMeasurements.
     * @example
     * // Create many FinalPantMeasurements
     * const finalPantMeasurement = await prisma.finalPantMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinalPantMeasurementCreateManyArgs>(args?: SelectSubset<T, FinalPantMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinalPantMeasurements and returns the data saved in the database.
     * @param {FinalPantMeasurementCreateManyAndReturnArgs} args - Arguments to create many FinalPantMeasurements.
     * @example
     * // Create many FinalPantMeasurements
     * const finalPantMeasurement = await prisma.finalPantMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinalPantMeasurements and only return the `measurement_id`
     * const finalPantMeasurementWithMeasurement_idOnly = await prisma.finalPantMeasurement.createManyAndReturn({
     *   select: { measurement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinalPantMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, FinalPantMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinalPantMeasurement.
     * @param {FinalPantMeasurementDeleteArgs} args - Arguments to delete one FinalPantMeasurement.
     * @example
     * // Delete one FinalPantMeasurement
     * const FinalPantMeasurement = await prisma.finalPantMeasurement.delete({
     *   where: {
     *     // ... filter to delete one FinalPantMeasurement
     *   }
     * })
     * 
     */
    delete<T extends FinalPantMeasurementDeleteArgs>(args: SelectSubset<T, FinalPantMeasurementDeleteArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinalPantMeasurement.
     * @param {FinalPantMeasurementUpdateArgs} args - Arguments to update one FinalPantMeasurement.
     * @example
     * // Update one FinalPantMeasurement
     * const finalPantMeasurement = await prisma.finalPantMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinalPantMeasurementUpdateArgs>(args: SelectSubset<T, FinalPantMeasurementUpdateArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinalPantMeasurements.
     * @param {FinalPantMeasurementDeleteManyArgs} args - Arguments to filter FinalPantMeasurements to delete.
     * @example
     * // Delete a few FinalPantMeasurements
     * const { count } = await prisma.finalPantMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinalPantMeasurementDeleteManyArgs>(args?: SelectSubset<T, FinalPantMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalPantMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinalPantMeasurements
     * const finalPantMeasurement = await prisma.finalPantMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinalPantMeasurementUpdateManyArgs>(args: SelectSubset<T, FinalPantMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalPantMeasurements and returns the data updated in the database.
     * @param {FinalPantMeasurementUpdateManyAndReturnArgs} args - Arguments to update many FinalPantMeasurements.
     * @example
     * // Update many FinalPantMeasurements
     * const finalPantMeasurement = await prisma.finalPantMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinalPantMeasurements and only return the `measurement_id`
     * const finalPantMeasurementWithMeasurement_idOnly = await prisma.finalPantMeasurement.updateManyAndReturn({
     *   select: { measurement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinalPantMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, FinalPantMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinalPantMeasurement.
     * @param {FinalPantMeasurementUpsertArgs} args - Arguments to update or create a FinalPantMeasurement.
     * @example
     * // Update or create a FinalPantMeasurement
     * const finalPantMeasurement = await prisma.finalPantMeasurement.upsert({
     *   create: {
     *     // ... data to create a FinalPantMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinalPantMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends FinalPantMeasurementUpsertArgs>(args: SelectSubset<T, FinalPantMeasurementUpsertArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinalPantMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementCountArgs} args - Arguments to filter FinalPantMeasurements to count.
     * @example
     * // Count the number of FinalPantMeasurements
     * const count = await prisma.finalPantMeasurement.count({
     *   where: {
     *     // ... the filter for the FinalPantMeasurements we want to count
     *   }
     * })
    **/
    count<T extends FinalPantMeasurementCountArgs>(
      args?: Subset<T, FinalPantMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinalPantMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinalPantMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinalPantMeasurementAggregateArgs>(args: Subset<T, FinalPantMeasurementAggregateArgs>): Prisma.PrismaPromise<GetFinalPantMeasurementAggregateType<T>>

    /**
     * Group by FinalPantMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalPantMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinalPantMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinalPantMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: FinalPantMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinalPantMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinalPantMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinalPantMeasurement model
   */
  readonly fields: FinalPantMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinalPantMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinalPantMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends FinalPantMeasurement$customerArgs<ExtArgs> = {}>(args?: Subset<T, FinalPantMeasurement$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends FinalPantMeasurement$orderArgs<ExtArgs> = {}>(args?: Subset<T, FinalPantMeasurement$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Items<T extends FinalPantMeasurement$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, FinalPantMeasurement$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinalPantMeasurement model
   */
  interface FinalPantMeasurementFieldRefs {
    readonly measurement_id: FieldRef<"FinalPantMeasurement", 'String'>
    readonly customer_id: FieldRef<"FinalPantMeasurement", 'Int'>
    readonly orderNo: FieldRef<"FinalPantMeasurement", 'String'>
    readonly date: FieldRef<"FinalPantMeasurement", 'DateTime'>
    readonly length: FieldRef<"FinalPantMeasurement", 'String'>
    readonly inseem: FieldRef<"FinalPantMeasurement", 'String'>
    readonly waist: FieldRef<"FinalPantMeasurement", 'String'>
    readonly hips: FieldRef<"FinalPantMeasurement", 'String'>
    readonly bottom: FieldRef<"FinalPantMeasurement", 'String'>
    readonly knee: FieldRef<"FinalPantMeasurement", 'String'>
    readonly other_notes: FieldRef<"FinalPantMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FinalPantMeasurement findUnique
   */
  export type FinalPantMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalPantMeasurement to fetch.
     */
    where: FinalPantMeasurementWhereUniqueInput
  }

  /**
   * FinalPantMeasurement findUniqueOrThrow
   */
  export type FinalPantMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalPantMeasurement to fetch.
     */
    where: FinalPantMeasurementWhereUniqueInput
  }

  /**
   * FinalPantMeasurement findFirst
   */
  export type FinalPantMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalPantMeasurement to fetch.
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalPantMeasurements to fetch.
     */
    orderBy?: FinalPantMeasurementOrderByWithRelationInput | FinalPantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalPantMeasurements.
     */
    cursor?: FinalPantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalPantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalPantMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalPantMeasurements.
     */
    distinct?: FinalPantMeasurementScalarFieldEnum | FinalPantMeasurementScalarFieldEnum[]
  }

  /**
   * FinalPantMeasurement findFirstOrThrow
   */
  export type FinalPantMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalPantMeasurement to fetch.
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalPantMeasurements to fetch.
     */
    orderBy?: FinalPantMeasurementOrderByWithRelationInput | FinalPantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalPantMeasurements.
     */
    cursor?: FinalPantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalPantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalPantMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalPantMeasurements.
     */
    distinct?: FinalPantMeasurementScalarFieldEnum | FinalPantMeasurementScalarFieldEnum[]
  }

  /**
   * FinalPantMeasurement findMany
   */
  export type FinalPantMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalPantMeasurements to fetch.
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalPantMeasurements to fetch.
     */
    orderBy?: FinalPantMeasurementOrderByWithRelationInput | FinalPantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinalPantMeasurements.
     */
    cursor?: FinalPantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalPantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalPantMeasurements.
     */
    skip?: number
    distinct?: FinalPantMeasurementScalarFieldEnum | FinalPantMeasurementScalarFieldEnum[]
  }

  /**
   * FinalPantMeasurement create
   */
  export type FinalPantMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a FinalPantMeasurement.
     */
    data?: XOR<FinalPantMeasurementCreateInput, FinalPantMeasurementUncheckedCreateInput>
  }

  /**
   * FinalPantMeasurement createMany
   */
  export type FinalPantMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinalPantMeasurements.
     */
    data: FinalPantMeasurementCreateManyInput | FinalPantMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinalPantMeasurement createManyAndReturn
   */
  export type FinalPantMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many FinalPantMeasurements.
     */
    data: FinalPantMeasurementCreateManyInput | FinalPantMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalPantMeasurement update
   */
  export type FinalPantMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a FinalPantMeasurement.
     */
    data: XOR<FinalPantMeasurementUpdateInput, FinalPantMeasurementUncheckedUpdateInput>
    /**
     * Choose, which FinalPantMeasurement to update.
     */
    where: FinalPantMeasurementWhereUniqueInput
  }

  /**
   * FinalPantMeasurement updateMany
   */
  export type FinalPantMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinalPantMeasurements.
     */
    data: XOR<FinalPantMeasurementUpdateManyMutationInput, FinalPantMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which FinalPantMeasurements to update
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * Limit how many FinalPantMeasurements to update.
     */
    limit?: number
  }

  /**
   * FinalPantMeasurement updateManyAndReturn
   */
  export type FinalPantMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update FinalPantMeasurements.
     */
    data: XOR<FinalPantMeasurementUpdateManyMutationInput, FinalPantMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which FinalPantMeasurements to update
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * Limit how many FinalPantMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalPantMeasurement upsert
   */
  export type FinalPantMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the FinalPantMeasurement to update in case it exists.
     */
    where: FinalPantMeasurementWhereUniqueInput
    /**
     * In case the FinalPantMeasurement found by the `where` argument doesn't exist, create a new FinalPantMeasurement with this data.
     */
    create: XOR<FinalPantMeasurementCreateInput, FinalPantMeasurementUncheckedCreateInput>
    /**
     * In case the FinalPantMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinalPantMeasurementUpdateInput, FinalPantMeasurementUncheckedUpdateInput>
  }

  /**
   * FinalPantMeasurement delete
   */
  export type FinalPantMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    /**
     * Filter which FinalPantMeasurement to delete.
     */
    where: FinalPantMeasurementWhereUniqueInput
  }

  /**
   * FinalPantMeasurement deleteMany
   */
  export type FinalPantMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalPantMeasurements to delete
     */
    where?: FinalPantMeasurementWhereInput
    /**
     * Limit how many FinalPantMeasurements to delete.
     */
    limit?: number
  }

  /**
   * FinalPantMeasurement.customer
   */
  export type FinalPantMeasurement$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * FinalPantMeasurement.order
   */
  export type FinalPantMeasurement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * FinalPantMeasurement.Items
   */
  export type FinalPantMeasurement$ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * FinalPantMeasurement without action
   */
  export type FinalPantMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model PantMeasurement
   */

  export type AggregatePantMeasurement = {
    _count: PantMeasurementCountAggregateOutputType | null
    _avg: PantMeasurementAvgAggregateOutputType | null
    _sum: PantMeasurementSumAggregateOutputType | null
    _min: PantMeasurementMinAggregateOutputType | null
    _max: PantMeasurementMaxAggregateOutputType | null
  }

  export type PantMeasurementAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type PantMeasurementSumAggregateOutputType = {
    customer_id: number | null
  }

  export type PantMeasurementMinAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    inseem: string | null
    waist: string | null
    hips: string | null
    bottom: string | null
    knee: string | null
    other_notes: string | null
  }

  export type PantMeasurementMaxAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    inseem: string | null
    waist: string | null
    hips: string | null
    bottom: string | null
    knee: string | null
    other_notes: string | null
  }

  export type PantMeasurementCountAggregateOutputType = {
    measurement_id: number
    customer_id: number
    orderNo: number
    date: number
    length: number
    inseem: number
    waist: number
    hips: number
    bottom: number
    knee: number
    other_notes: number
    _all: number
  }


  export type PantMeasurementAvgAggregateInputType = {
    customer_id?: true
  }

  export type PantMeasurementSumAggregateInputType = {
    customer_id?: true
  }

  export type PantMeasurementMinAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    inseem?: true
    waist?: true
    hips?: true
    bottom?: true
    knee?: true
    other_notes?: true
  }

  export type PantMeasurementMaxAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    inseem?: true
    waist?: true
    hips?: true
    bottom?: true
    knee?: true
    other_notes?: true
  }

  export type PantMeasurementCountAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    inseem?: true
    waist?: true
    hips?: true
    bottom?: true
    knee?: true
    other_notes?: true
    _all?: true
  }

  export type PantMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PantMeasurement to aggregate.
     */
    where?: PantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PantMeasurements to fetch.
     */
    orderBy?: PantMeasurementOrderByWithRelationInput | PantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PantMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PantMeasurements
    **/
    _count?: true | PantMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PantMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PantMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PantMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PantMeasurementMaxAggregateInputType
  }

  export type GetPantMeasurementAggregateType<T extends PantMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregatePantMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePantMeasurement[P]>
      : GetScalarType<T[P], AggregatePantMeasurement[P]>
  }




  export type PantMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PantMeasurementWhereInput
    orderBy?: PantMeasurementOrderByWithAggregationInput | PantMeasurementOrderByWithAggregationInput[]
    by: PantMeasurementScalarFieldEnum[] | PantMeasurementScalarFieldEnum
    having?: PantMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PantMeasurementCountAggregateInputType | true
    _avg?: PantMeasurementAvgAggregateInputType
    _sum?: PantMeasurementSumAggregateInputType
    _min?: PantMeasurementMinAggregateInputType
    _max?: PantMeasurementMaxAggregateInputType
  }

  export type PantMeasurementGroupByOutputType = {
    measurement_id: string
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    inseem: string | null
    waist: string | null
    hips: string | null
    bottom: string | null
    knee: string | null
    other_notes: string | null
    _count: PantMeasurementCountAggregateOutputType | null
    _avg: PantMeasurementAvgAggregateOutputType | null
    _sum: PantMeasurementSumAggregateOutputType | null
    _min: PantMeasurementMinAggregateOutputType | null
    _max: PantMeasurementMaxAggregateOutputType | null
  }

  type GetPantMeasurementGroupByPayload<T extends PantMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PantMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PantMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PantMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], PantMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type PantMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
    customer?: boolean | PantMeasurement$customerArgs<ExtArgs>
    order?: boolean | PantMeasurement$orderArgs<ExtArgs>
    Items?: boolean | PantMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | PantMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pantMeasurement"]>

  export type PantMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
    customer?: boolean | PantMeasurement$customerArgs<ExtArgs>
    order?: boolean | PantMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["pantMeasurement"]>

  export type PantMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
    customer?: boolean | PantMeasurement$customerArgs<ExtArgs>
    order?: boolean | PantMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["pantMeasurement"]>

  export type PantMeasurementSelectScalar = {
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    inseem?: boolean
    waist?: boolean
    hips?: boolean
    bottom?: boolean
    knee?: boolean
    other_notes?: boolean
  }

  export type PantMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"measurement_id" | "customer_id" | "orderNo" | "date" | "length" | "inseem" | "waist" | "hips" | "bottom" | "knee" | "other_notes", ExtArgs["result"]["pantMeasurement"]>
  export type PantMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PantMeasurement$customerArgs<ExtArgs>
    order?: boolean | PantMeasurement$orderArgs<ExtArgs>
    Items?: boolean | PantMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | PantMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PantMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PantMeasurement$customerArgs<ExtArgs>
    order?: boolean | PantMeasurement$orderArgs<ExtArgs>
  }
  export type PantMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PantMeasurement$customerArgs<ExtArgs>
    order?: boolean | PantMeasurement$orderArgs<ExtArgs>
  }

  export type $PantMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PantMeasurement"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs> | null
      Items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      measurement_id: string
      customer_id: number | null
      orderNo: string | null
      date: Date | null
      length: string | null
      inseem: string | null
      waist: string | null
      hips: string | null
      bottom: string | null
      knee: string | null
      other_notes: string | null
    }, ExtArgs["result"]["pantMeasurement"]>
    composites: {}
  }

  type PantMeasurementGetPayload<S extends boolean | null | undefined | PantMeasurementDefaultArgs> = $Result.GetResult<Prisma.$PantMeasurementPayload, S>

  type PantMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PantMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PantMeasurementCountAggregateInputType | true
    }

  export interface PantMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PantMeasurement'], meta: { name: 'PantMeasurement' } }
    /**
     * Find zero or one PantMeasurement that matches the filter.
     * @param {PantMeasurementFindUniqueArgs} args - Arguments to find a PantMeasurement
     * @example
     * // Get one PantMeasurement
     * const pantMeasurement = await prisma.pantMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PantMeasurementFindUniqueArgs>(args: SelectSubset<T, PantMeasurementFindUniqueArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PantMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PantMeasurementFindUniqueOrThrowArgs} args - Arguments to find a PantMeasurement
     * @example
     * // Get one PantMeasurement
     * const pantMeasurement = await prisma.pantMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PantMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, PantMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PantMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementFindFirstArgs} args - Arguments to find a PantMeasurement
     * @example
     * // Get one PantMeasurement
     * const pantMeasurement = await prisma.pantMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PantMeasurementFindFirstArgs>(args?: SelectSubset<T, PantMeasurementFindFirstArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PantMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementFindFirstOrThrowArgs} args - Arguments to find a PantMeasurement
     * @example
     * // Get one PantMeasurement
     * const pantMeasurement = await prisma.pantMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PantMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, PantMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PantMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PantMeasurements
     * const pantMeasurements = await prisma.pantMeasurement.findMany()
     * 
     * // Get first 10 PantMeasurements
     * const pantMeasurements = await prisma.pantMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `measurement_id`
     * const pantMeasurementWithMeasurement_idOnly = await prisma.pantMeasurement.findMany({ select: { measurement_id: true } })
     * 
     */
    findMany<T extends PantMeasurementFindManyArgs>(args?: SelectSubset<T, PantMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PantMeasurement.
     * @param {PantMeasurementCreateArgs} args - Arguments to create a PantMeasurement.
     * @example
     * // Create one PantMeasurement
     * const PantMeasurement = await prisma.pantMeasurement.create({
     *   data: {
     *     // ... data to create a PantMeasurement
     *   }
     * })
     * 
     */
    create<T extends PantMeasurementCreateArgs>(args: SelectSubset<T, PantMeasurementCreateArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PantMeasurements.
     * @param {PantMeasurementCreateManyArgs} args - Arguments to create many PantMeasurements.
     * @example
     * // Create many PantMeasurements
     * const pantMeasurement = await prisma.pantMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PantMeasurementCreateManyArgs>(args?: SelectSubset<T, PantMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PantMeasurements and returns the data saved in the database.
     * @param {PantMeasurementCreateManyAndReturnArgs} args - Arguments to create many PantMeasurements.
     * @example
     * // Create many PantMeasurements
     * const pantMeasurement = await prisma.pantMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PantMeasurements and only return the `measurement_id`
     * const pantMeasurementWithMeasurement_idOnly = await prisma.pantMeasurement.createManyAndReturn({
     *   select: { measurement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PantMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, PantMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PantMeasurement.
     * @param {PantMeasurementDeleteArgs} args - Arguments to delete one PantMeasurement.
     * @example
     * // Delete one PantMeasurement
     * const PantMeasurement = await prisma.pantMeasurement.delete({
     *   where: {
     *     // ... filter to delete one PantMeasurement
     *   }
     * })
     * 
     */
    delete<T extends PantMeasurementDeleteArgs>(args: SelectSubset<T, PantMeasurementDeleteArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PantMeasurement.
     * @param {PantMeasurementUpdateArgs} args - Arguments to update one PantMeasurement.
     * @example
     * // Update one PantMeasurement
     * const pantMeasurement = await prisma.pantMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PantMeasurementUpdateArgs>(args: SelectSubset<T, PantMeasurementUpdateArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PantMeasurements.
     * @param {PantMeasurementDeleteManyArgs} args - Arguments to filter PantMeasurements to delete.
     * @example
     * // Delete a few PantMeasurements
     * const { count } = await prisma.pantMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PantMeasurementDeleteManyArgs>(args?: SelectSubset<T, PantMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PantMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PantMeasurements
     * const pantMeasurement = await prisma.pantMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PantMeasurementUpdateManyArgs>(args: SelectSubset<T, PantMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PantMeasurements and returns the data updated in the database.
     * @param {PantMeasurementUpdateManyAndReturnArgs} args - Arguments to update many PantMeasurements.
     * @example
     * // Update many PantMeasurements
     * const pantMeasurement = await prisma.pantMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PantMeasurements and only return the `measurement_id`
     * const pantMeasurementWithMeasurement_idOnly = await prisma.pantMeasurement.updateManyAndReturn({
     *   select: { measurement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PantMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, PantMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PantMeasurement.
     * @param {PantMeasurementUpsertArgs} args - Arguments to update or create a PantMeasurement.
     * @example
     * // Update or create a PantMeasurement
     * const pantMeasurement = await prisma.pantMeasurement.upsert({
     *   create: {
     *     // ... data to create a PantMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PantMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends PantMeasurementUpsertArgs>(args: SelectSubset<T, PantMeasurementUpsertArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PantMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementCountArgs} args - Arguments to filter PantMeasurements to count.
     * @example
     * // Count the number of PantMeasurements
     * const count = await prisma.pantMeasurement.count({
     *   where: {
     *     // ... the filter for the PantMeasurements we want to count
     *   }
     * })
    **/
    count<T extends PantMeasurementCountArgs>(
      args?: Subset<T, PantMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PantMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PantMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PantMeasurementAggregateArgs>(args: Subset<T, PantMeasurementAggregateArgs>): Prisma.PrismaPromise<GetPantMeasurementAggregateType<T>>

    /**
     * Group by PantMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PantMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PantMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PantMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: PantMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PantMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPantMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PantMeasurement model
   */
  readonly fields: PantMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PantMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PantMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends PantMeasurement$customerArgs<ExtArgs> = {}>(args?: Subset<T, PantMeasurement$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends PantMeasurement$orderArgs<ExtArgs> = {}>(args?: Subset<T, PantMeasurement$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Items<T extends PantMeasurement$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, PantMeasurement$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PantMeasurement model
   */
  interface PantMeasurementFieldRefs {
    readonly measurement_id: FieldRef<"PantMeasurement", 'String'>
    readonly customer_id: FieldRef<"PantMeasurement", 'Int'>
    readonly orderNo: FieldRef<"PantMeasurement", 'String'>
    readonly date: FieldRef<"PantMeasurement", 'DateTime'>
    readonly length: FieldRef<"PantMeasurement", 'String'>
    readonly inseem: FieldRef<"PantMeasurement", 'String'>
    readonly waist: FieldRef<"PantMeasurement", 'String'>
    readonly hips: FieldRef<"PantMeasurement", 'String'>
    readonly bottom: FieldRef<"PantMeasurement", 'String'>
    readonly knee: FieldRef<"PantMeasurement", 'String'>
    readonly other_notes: FieldRef<"PantMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PantMeasurement findUnique
   */
  export type PantMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which PantMeasurement to fetch.
     */
    where: PantMeasurementWhereUniqueInput
  }

  /**
   * PantMeasurement findUniqueOrThrow
   */
  export type PantMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which PantMeasurement to fetch.
     */
    where: PantMeasurementWhereUniqueInput
  }

  /**
   * PantMeasurement findFirst
   */
  export type PantMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which PantMeasurement to fetch.
     */
    where?: PantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PantMeasurements to fetch.
     */
    orderBy?: PantMeasurementOrderByWithRelationInput | PantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PantMeasurements.
     */
    cursor?: PantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PantMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PantMeasurements.
     */
    distinct?: PantMeasurementScalarFieldEnum | PantMeasurementScalarFieldEnum[]
  }

  /**
   * PantMeasurement findFirstOrThrow
   */
  export type PantMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which PantMeasurement to fetch.
     */
    where?: PantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PantMeasurements to fetch.
     */
    orderBy?: PantMeasurementOrderByWithRelationInput | PantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PantMeasurements.
     */
    cursor?: PantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PantMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PantMeasurements.
     */
    distinct?: PantMeasurementScalarFieldEnum | PantMeasurementScalarFieldEnum[]
  }

  /**
   * PantMeasurement findMany
   */
  export type PantMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which PantMeasurements to fetch.
     */
    where?: PantMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PantMeasurements to fetch.
     */
    orderBy?: PantMeasurementOrderByWithRelationInput | PantMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PantMeasurements.
     */
    cursor?: PantMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PantMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PantMeasurements.
     */
    skip?: number
    distinct?: PantMeasurementScalarFieldEnum | PantMeasurementScalarFieldEnum[]
  }

  /**
   * PantMeasurement create
   */
  export type PantMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a PantMeasurement.
     */
    data?: XOR<PantMeasurementCreateInput, PantMeasurementUncheckedCreateInput>
  }

  /**
   * PantMeasurement createMany
   */
  export type PantMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PantMeasurements.
     */
    data: PantMeasurementCreateManyInput | PantMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PantMeasurement createManyAndReturn
   */
  export type PantMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many PantMeasurements.
     */
    data: PantMeasurementCreateManyInput | PantMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PantMeasurement update
   */
  export type PantMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a PantMeasurement.
     */
    data: XOR<PantMeasurementUpdateInput, PantMeasurementUncheckedUpdateInput>
    /**
     * Choose, which PantMeasurement to update.
     */
    where: PantMeasurementWhereUniqueInput
  }

  /**
   * PantMeasurement updateMany
   */
  export type PantMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PantMeasurements.
     */
    data: XOR<PantMeasurementUpdateManyMutationInput, PantMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which PantMeasurements to update
     */
    where?: PantMeasurementWhereInput
    /**
     * Limit how many PantMeasurements to update.
     */
    limit?: number
  }

  /**
   * PantMeasurement updateManyAndReturn
   */
  export type PantMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update PantMeasurements.
     */
    data: XOR<PantMeasurementUpdateManyMutationInput, PantMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which PantMeasurements to update
     */
    where?: PantMeasurementWhereInput
    /**
     * Limit how many PantMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PantMeasurement upsert
   */
  export type PantMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the PantMeasurement to update in case it exists.
     */
    where: PantMeasurementWhereUniqueInput
    /**
     * In case the PantMeasurement found by the `where` argument doesn't exist, create a new PantMeasurement with this data.
     */
    create: XOR<PantMeasurementCreateInput, PantMeasurementUncheckedCreateInput>
    /**
     * In case the PantMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PantMeasurementUpdateInput, PantMeasurementUncheckedUpdateInput>
  }

  /**
   * PantMeasurement delete
   */
  export type PantMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    /**
     * Filter which PantMeasurement to delete.
     */
    where: PantMeasurementWhereUniqueInput
  }

  /**
   * PantMeasurement deleteMany
   */
  export type PantMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PantMeasurements to delete
     */
    where?: PantMeasurementWhereInput
    /**
     * Limit how many PantMeasurements to delete.
     */
    limit?: number
  }

  /**
   * PantMeasurement.customer
   */
  export type PantMeasurement$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * PantMeasurement.order
   */
  export type PantMeasurement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * PantMeasurement.Items
   */
  export type PantMeasurement$ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * PantMeasurement without action
   */
  export type PantMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model FinalShirtMeasurement
   */

  export type AggregateFinalShirtMeasurement = {
    _count: FinalShirtMeasurementCountAggregateOutputType | null
    _avg: FinalShirtMeasurementAvgAggregateOutputType | null
    _sum: FinalShirtMeasurementSumAggregateOutputType | null
    _min: FinalShirtMeasurementMinAggregateOutputType | null
    _max: FinalShirtMeasurementMaxAggregateOutputType | null
  }

  export type FinalShirtMeasurementAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type FinalShirtMeasurementSumAggregateOutputType = {
    customer_id: number | null
  }

  export type FinalShirtMeasurementMinAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    other_notes: string | null
  }

  export type FinalShirtMeasurementMaxAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    other_notes: string | null
  }

  export type FinalShirtMeasurementCountAggregateOutputType = {
    measurement_id: number
    customer_id: number
    orderNo: number
    date: number
    length: number
    half_shoulder: number
    to_sleeve: number
    chest: number
    waist: number
    collar: number
    other_notes: number
    _all: number
  }


  export type FinalShirtMeasurementAvgAggregateInputType = {
    customer_id?: true
  }

  export type FinalShirtMeasurementSumAggregateInputType = {
    customer_id?: true
  }

  export type FinalShirtMeasurementMinAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    other_notes?: true
  }

  export type FinalShirtMeasurementMaxAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    other_notes?: true
  }

  export type FinalShirtMeasurementCountAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    other_notes?: true
    _all?: true
  }

  export type FinalShirtMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalShirtMeasurement to aggregate.
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalShirtMeasurements to fetch.
     */
    orderBy?: FinalShirtMeasurementOrderByWithRelationInput | FinalShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinalShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalShirtMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinalShirtMeasurements
    **/
    _count?: true | FinalShirtMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinalShirtMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinalShirtMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinalShirtMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinalShirtMeasurementMaxAggregateInputType
  }

  export type GetFinalShirtMeasurementAggregateType<T extends FinalShirtMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateFinalShirtMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinalShirtMeasurement[P]>
      : GetScalarType<T[P], AggregateFinalShirtMeasurement[P]>
  }




  export type FinalShirtMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalShirtMeasurementWhereInput
    orderBy?: FinalShirtMeasurementOrderByWithAggregationInput | FinalShirtMeasurementOrderByWithAggregationInput[]
    by: FinalShirtMeasurementScalarFieldEnum[] | FinalShirtMeasurementScalarFieldEnum
    having?: FinalShirtMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinalShirtMeasurementCountAggregateInputType | true
    _avg?: FinalShirtMeasurementAvgAggregateInputType
    _sum?: FinalShirtMeasurementSumAggregateInputType
    _min?: FinalShirtMeasurementMinAggregateInputType
    _max?: FinalShirtMeasurementMaxAggregateInputType
  }

  export type FinalShirtMeasurementGroupByOutputType = {
    measurement_id: string
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    other_notes: string | null
    _count: FinalShirtMeasurementCountAggregateOutputType | null
    _avg: FinalShirtMeasurementAvgAggregateOutputType | null
    _sum: FinalShirtMeasurementSumAggregateOutputType | null
    _min: FinalShirtMeasurementMinAggregateOutputType | null
    _max: FinalShirtMeasurementMaxAggregateOutputType | null
  }

  type GetFinalShirtMeasurementGroupByPayload<T extends FinalShirtMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinalShirtMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinalShirtMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinalShirtMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], FinalShirtMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type FinalShirtMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
    customer?: boolean | FinalShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalShirtMeasurement$orderArgs<ExtArgs>
    Items?: boolean | FinalShirtMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | FinalShirtMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalShirtMeasurement"]>

  export type FinalShirtMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
    customer?: boolean | FinalShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalShirtMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["finalShirtMeasurement"]>

  export type FinalShirtMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
    customer?: boolean | FinalShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalShirtMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["finalShirtMeasurement"]>

  export type FinalShirtMeasurementSelectScalar = {
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
  }

  export type FinalShirtMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"measurement_id" | "customer_id" | "orderNo" | "date" | "length" | "half_shoulder" | "to_sleeve" | "chest" | "waist" | "collar" | "other_notes", ExtArgs["result"]["finalShirtMeasurement"]>
  export type FinalShirtMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalShirtMeasurement$orderArgs<ExtArgs>
    Items?: boolean | FinalShirtMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | FinalShirtMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FinalShirtMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalShirtMeasurement$orderArgs<ExtArgs>
  }
  export type FinalShirtMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | FinalShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | FinalShirtMeasurement$orderArgs<ExtArgs>
  }

  export type $FinalShirtMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinalShirtMeasurement"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs> | null
      Items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      measurement_id: string
      customer_id: number | null
      orderNo: string | null
      date: Date | null
      length: string | null
      half_shoulder: string | null
      to_sleeve: string | null
      chest: string | null
      waist: string | null
      collar: string | null
      other_notes: string | null
    }, ExtArgs["result"]["finalShirtMeasurement"]>
    composites: {}
  }

  type FinalShirtMeasurementGetPayload<S extends boolean | null | undefined | FinalShirtMeasurementDefaultArgs> = $Result.GetResult<Prisma.$FinalShirtMeasurementPayload, S>

  type FinalShirtMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinalShirtMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinalShirtMeasurementCountAggregateInputType | true
    }

  export interface FinalShirtMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinalShirtMeasurement'], meta: { name: 'FinalShirtMeasurement' } }
    /**
     * Find zero or one FinalShirtMeasurement that matches the filter.
     * @param {FinalShirtMeasurementFindUniqueArgs} args - Arguments to find a FinalShirtMeasurement
     * @example
     * // Get one FinalShirtMeasurement
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinalShirtMeasurementFindUniqueArgs>(args: SelectSubset<T, FinalShirtMeasurementFindUniqueArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinalShirtMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinalShirtMeasurementFindUniqueOrThrowArgs} args - Arguments to find a FinalShirtMeasurement
     * @example
     * // Get one FinalShirtMeasurement
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinalShirtMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, FinalShirtMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalShirtMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementFindFirstArgs} args - Arguments to find a FinalShirtMeasurement
     * @example
     * // Get one FinalShirtMeasurement
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinalShirtMeasurementFindFirstArgs>(args?: SelectSubset<T, FinalShirtMeasurementFindFirstArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalShirtMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementFindFirstOrThrowArgs} args - Arguments to find a FinalShirtMeasurement
     * @example
     * // Get one FinalShirtMeasurement
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinalShirtMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, FinalShirtMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinalShirtMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinalShirtMeasurements
     * const finalShirtMeasurements = await prisma.finalShirtMeasurement.findMany()
     * 
     * // Get first 10 FinalShirtMeasurements
     * const finalShirtMeasurements = await prisma.finalShirtMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `measurement_id`
     * const finalShirtMeasurementWithMeasurement_idOnly = await prisma.finalShirtMeasurement.findMany({ select: { measurement_id: true } })
     * 
     */
    findMany<T extends FinalShirtMeasurementFindManyArgs>(args?: SelectSubset<T, FinalShirtMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinalShirtMeasurement.
     * @param {FinalShirtMeasurementCreateArgs} args - Arguments to create a FinalShirtMeasurement.
     * @example
     * // Create one FinalShirtMeasurement
     * const FinalShirtMeasurement = await prisma.finalShirtMeasurement.create({
     *   data: {
     *     // ... data to create a FinalShirtMeasurement
     *   }
     * })
     * 
     */
    create<T extends FinalShirtMeasurementCreateArgs>(args: SelectSubset<T, FinalShirtMeasurementCreateArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinalShirtMeasurements.
     * @param {FinalShirtMeasurementCreateManyArgs} args - Arguments to create many FinalShirtMeasurements.
     * @example
     * // Create many FinalShirtMeasurements
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinalShirtMeasurementCreateManyArgs>(args?: SelectSubset<T, FinalShirtMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinalShirtMeasurements and returns the data saved in the database.
     * @param {FinalShirtMeasurementCreateManyAndReturnArgs} args - Arguments to create many FinalShirtMeasurements.
     * @example
     * // Create many FinalShirtMeasurements
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinalShirtMeasurements and only return the `measurement_id`
     * const finalShirtMeasurementWithMeasurement_idOnly = await prisma.finalShirtMeasurement.createManyAndReturn({
     *   select: { measurement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinalShirtMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, FinalShirtMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinalShirtMeasurement.
     * @param {FinalShirtMeasurementDeleteArgs} args - Arguments to delete one FinalShirtMeasurement.
     * @example
     * // Delete one FinalShirtMeasurement
     * const FinalShirtMeasurement = await prisma.finalShirtMeasurement.delete({
     *   where: {
     *     // ... filter to delete one FinalShirtMeasurement
     *   }
     * })
     * 
     */
    delete<T extends FinalShirtMeasurementDeleteArgs>(args: SelectSubset<T, FinalShirtMeasurementDeleteArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinalShirtMeasurement.
     * @param {FinalShirtMeasurementUpdateArgs} args - Arguments to update one FinalShirtMeasurement.
     * @example
     * // Update one FinalShirtMeasurement
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinalShirtMeasurementUpdateArgs>(args: SelectSubset<T, FinalShirtMeasurementUpdateArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinalShirtMeasurements.
     * @param {FinalShirtMeasurementDeleteManyArgs} args - Arguments to filter FinalShirtMeasurements to delete.
     * @example
     * // Delete a few FinalShirtMeasurements
     * const { count } = await prisma.finalShirtMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinalShirtMeasurementDeleteManyArgs>(args?: SelectSubset<T, FinalShirtMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalShirtMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinalShirtMeasurements
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinalShirtMeasurementUpdateManyArgs>(args: SelectSubset<T, FinalShirtMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalShirtMeasurements and returns the data updated in the database.
     * @param {FinalShirtMeasurementUpdateManyAndReturnArgs} args - Arguments to update many FinalShirtMeasurements.
     * @example
     * // Update many FinalShirtMeasurements
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinalShirtMeasurements and only return the `measurement_id`
     * const finalShirtMeasurementWithMeasurement_idOnly = await prisma.finalShirtMeasurement.updateManyAndReturn({
     *   select: { measurement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinalShirtMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, FinalShirtMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinalShirtMeasurement.
     * @param {FinalShirtMeasurementUpsertArgs} args - Arguments to update or create a FinalShirtMeasurement.
     * @example
     * // Update or create a FinalShirtMeasurement
     * const finalShirtMeasurement = await prisma.finalShirtMeasurement.upsert({
     *   create: {
     *     // ... data to create a FinalShirtMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinalShirtMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends FinalShirtMeasurementUpsertArgs>(args: SelectSubset<T, FinalShirtMeasurementUpsertArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinalShirtMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementCountArgs} args - Arguments to filter FinalShirtMeasurements to count.
     * @example
     * // Count the number of FinalShirtMeasurements
     * const count = await prisma.finalShirtMeasurement.count({
     *   where: {
     *     // ... the filter for the FinalShirtMeasurements we want to count
     *   }
     * })
    **/
    count<T extends FinalShirtMeasurementCountArgs>(
      args?: Subset<T, FinalShirtMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinalShirtMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinalShirtMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinalShirtMeasurementAggregateArgs>(args: Subset<T, FinalShirtMeasurementAggregateArgs>): Prisma.PrismaPromise<GetFinalShirtMeasurementAggregateType<T>>

    /**
     * Group by FinalShirtMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalShirtMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinalShirtMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinalShirtMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: FinalShirtMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinalShirtMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinalShirtMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinalShirtMeasurement model
   */
  readonly fields: FinalShirtMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinalShirtMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinalShirtMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends FinalShirtMeasurement$customerArgs<ExtArgs> = {}>(args?: Subset<T, FinalShirtMeasurement$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends FinalShirtMeasurement$orderArgs<ExtArgs> = {}>(args?: Subset<T, FinalShirtMeasurement$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Items<T extends FinalShirtMeasurement$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, FinalShirtMeasurement$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinalShirtMeasurement model
   */
  interface FinalShirtMeasurementFieldRefs {
    readonly measurement_id: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly customer_id: FieldRef<"FinalShirtMeasurement", 'Int'>
    readonly orderNo: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly date: FieldRef<"FinalShirtMeasurement", 'DateTime'>
    readonly length: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly half_shoulder: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly to_sleeve: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly chest: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly waist: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly collar: FieldRef<"FinalShirtMeasurement", 'String'>
    readonly other_notes: FieldRef<"FinalShirtMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FinalShirtMeasurement findUnique
   */
  export type FinalShirtMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalShirtMeasurement to fetch.
     */
    where: FinalShirtMeasurementWhereUniqueInput
  }

  /**
   * FinalShirtMeasurement findUniqueOrThrow
   */
  export type FinalShirtMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalShirtMeasurement to fetch.
     */
    where: FinalShirtMeasurementWhereUniqueInput
  }

  /**
   * FinalShirtMeasurement findFirst
   */
  export type FinalShirtMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalShirtMeasurement to fetch.
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalShirtMeasurements to fetch.
     */
    orderBy?: FinalShirtMeasurementOrderByWithRelationInput | FinalShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalShirtMeasurements.
     */
    cursor?: FinalShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalShirtMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalShirtMeasurements.
     */
    distinct?: FinalShirtMeasurementScalarFieldEnum | FinalShirtMeasurementScalarFieldEnum[]
  }

  /**
   * FinalShirtMeasurement findFirstOrThrow
   */
  export type FinalShirtMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalShirtMeasurement to fetch.
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalShirtMeasurements to fetch.
     */
    orderBy?: FinalShirtMeasurementOrderByWithRelationInput | FinalShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalShirtMeasurements.
     */
    cursor?: FinalShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalShirtMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalShirtMeasurements.
     */
    distinct?: FinalShirtMeasurementScalarFieldEnum | FinalShirtMeasurementScalarFieldEnum[]
  }

  /**
   * FinalShirtMeasurement findMany
   */
  export type FinalShirtMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which FinalShirtMeasurements to fetch.
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalShirtMeasurements to fetch.
     */
    orderBy?: FinalShirtMeasurementOrderByWithRelationInput | FinalShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinalShirtMeasurements.
     */
    cursor?: FinalShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalShirtMeasurements.
     */
    skip?: number
    distinct?: FinalShirtMeasurementScalarFieldEnum | FinalShirtMeasurementScalarFieldEnum[]
  }

  /**
   * FinalShirtMeasurement create
   */
  export type FinalShirtMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a FinalShirtMeasurement.
     */
    data?: XOR<FinalShirtMeasurementCreateInput, FinalShirtMeasurementUncheckedCreateInput>
  }

  /**
   * FinalShirtMeasurement createMany
   */
  export type FinalShirtMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinalShirtMeasurements.
     */
    data: FinalShirtMeasurementCreateManyInput | FinalShirtMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinalShirtMeasurement createManyAndReturn
   */
  export type FinalShirtMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many FinalShirtMeasurements.
     */
    data: FinalShirtMeasurementCreateManyInput | FinalShirtMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalShirtMeasurement update
   */
  export type FinalShirtMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a FinalShirtMeasurement.
     */
    data: XOR<FinalShirtMeasurementUpdateInput, FinalShirtMeasurementUncheckedUpdateInput>
    /**
     * Choose, which FinalShirtMeasurement to update.
     */
    where: FinalShirtMeasurementWhereUniqueInput
  }

  /**
   * FinalShirtMeasurement updateMany
   */
  export type FinalShirtMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinalShirtMeasurements.
     */
    data: XOR<FinalShirtMeasurementUpdateManyMutationInput, FinalShirtMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which FinalShirtMeasurements to update
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * Limit how many FinalShirtMeasurements to update.
     */
    limit?: number
  }

  /**
   * FinalShirtMeasurement updateManyAndReturn
   */
  export type FinalShirtMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update FinalShirtMeasurements.
     */
    data: XOR<FinalShirtMeasurementUpdateManyMutationInput, FinalShirtMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which FinalShirtMeasurements to update
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * Limit how many FinalShirtMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalShirtMeasurement upsert
   */
  export type FinalShirtMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the FinalShirtMeasurement to update in case it exists.
     */
    where: FinalShirtMeasurementWhereUniqueInput
    /**
     * In case the FinalShirtMeasurement found by the `where` argument doesn't exist, create a new FinalShirtMeasurement with this data.
     */
    create: XOR<FinalShirtMeasurementCreateInput, FinalShirtMeasurementUncheckedCreateInput>
    /**
     * In case the FinalShirtMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinalShirtMeasurementUpdateInput, FinalShirtMeasurementUncheckedUpdateInput>
  }

  /**
   * FinalShirtMeasurement delete
   */
  export type FinalShirtMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter which FinalShirtMeasurement to delete.
     */
    where: FinalShirtMeasurementWhereUniqueInput
  }

  /**
   * FinalShirtMeasurement deleteMany
   */
  export type FinalShirtMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalShirtMeasurements to delete
     */
    where?: FinalShirtMeasurementWhereInput
    /**
     * Limit how many FinalShirtMeasurements to delete.
     */
    limit?: number
  }

  /**
   * FinalShirtMeasurement.customer
   */
  export type FinalShirtMeasurement$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * FinalShirtMeasurement.order
   */
  export type FinalShirtMeasurement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * FinalShirtMeasurement.Items
   */
  export type FinalShirtMeasurement$ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * FinalShirtMeasurement without action
   */
  export type FinalShirtMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model ShirtMeasurement
   */

  export type AggregateShirtMeasurement = {
    _count: ShirtMeasurementCountAggregateOutputType | null
    _avg: ShirtMeasurementAvgAggregateOutputType | null
    _sum: ShirtMeasurementSumAggregateOutputType | null
    _min: ShirtMeasurementMinAggregateOutputType | null
    _max: ShirtMeasurementMaxAggregateOutputType | null
  }

  export type ShirtMeasurementAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type ShirtMeasurementSumAggregateOutputType = {
    customer_id: number | null
  }

  export type ShirtMeasurementMinAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    other_notes: string | null
  }

  export type ShirtMeasurementMaxAggregateOutputType = {
    measurement_id: string | null
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    other_notes: string | null
  }

  export type ShirtMeasurementCountAggregateOutputType = {
    measurement_id: number
    customer_id: number
    orderNo: number
    date: number
    length: number
    half_shoulder: number
    to_sleeve: number
    chest: number
    waist: number
    collar: number
    other_notes: number
    _all: number
  }


  export type ShirtMeasurementAvgAggregateInputType = {
    customer_id?: true
  }

  export type ShirtMeasurementSumAggregateInputType = {
    customer_id?: true
  }

  export type ShirtMeasurementMinAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    other_notes?: true
  }

  export type ShirtMeasurementMaxAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    other_notes?: true
  }

  export type ShirtMeasurementCountAggregateInputType = {
    measurement_id?: true
    customer_id?: true
    orderNo?: true
    date?: true
    length?: true
    half_shoulder?: true
    to_sleeve?: true
    chest?: true
    waist?: true
    collar?: true
    other_notes?: true
    _all?: true
  }

  export type ShirtMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShirtMeasurement to aggregate.
     */
    where?: ShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShirtMeasurements to fetch.
     */
    orderBy?: ShirtMeasurementOrderByWithRelationInput | ShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShirtMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShirtMeasurements
    **/
    _count?: true | ShirtMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShirtMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShirtMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShirtMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShirtMeasurementMaxAggregateInputType
  }

  export type GetShirtMeasurementAggregateType<T extends ShirtMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateShirtMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShirtMeasurement[P]>
      : GetScalarType<T[P], AggregateShirtMeasurement[P]>
  }




  export type ShirtMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShirtMeasurementWhereInput
    orderBy?: ShirtMeasurementOrderByWithAggregationInput | ShirtMeasurementOrderByWithAggregationInput[]
    by: ShirtMeasurementScalarFieldEnum[] | ShirtMeasurementScalarFieldEnum
    having?: ShirtMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShirtMeasurementCountAggregateInputType | true
    _avg?: ShirtMeasurementAvgAggregateInputType
    _sum?: ShirtMeasurementSumAggregateInputType
    _min?: ShirtMeasurementMinAggregateInputType
    _max?: ShirtMeasurementMaxAggregateInputType
  }

  export type ShirtMeasurementGroupByOutputType = {
    measurement_id: string
    customer_id: number | null
    orderNo: string | null
    date: Date | null
    length: string | null
    half_shoulder: string | null
    to_sleeve: string | null
    chest: string | null
    waist: string | null
    collar: string | null
    other_notes: string | null
    _count: ShirtMeasurementCountAggregateOutputType | null
    _avg: ShirtMeasurementAvgAggregateOutputType | null
    _sum: ShirtMeasurementSumAggregateOutputType | null
    _min: ShirtMeasurementMinAggregateOutputType | null
    _max: ShirtMeasurementMaxAggregateOutputType | null
  }

  type GetShirtMeasurementGroupByPayload<T extends ShirtMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShirtMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShirtMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShirtMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], ShirtMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type ShirtMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
    customer?: boolean | ShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | ShirtMeasurement$orderArgs<ExtArgs>
    Items?: boolean | ShirtMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | ShirtMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shirtMeasurement"]>

  export type ShirtMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
    customer?: boolean | ShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | ShirtMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["shirtMeasurement"]>

  export type ShirtMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
    customer?: boolean | ShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | ShirtMeasurement$orderArgs<ExtArgs>
  }, ExtArgs["result"]["shirtMeasurement"]>

  export type ShirtMeasurementSelectScalar = {
    measurement_id?: boolean
    customer_id?: boolean
    orderNo?: boolean
    date?: boolean
    length?: boolean
    half_shoulder?: boolean
    to_sleeve?: boolean
    chest?: boolean
    waist?: boolean
    collar?: boolean
    other_notes?: boolean
  }

  export type ShirtMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"measurement_id" | "customer_id" | "orderNo" | "date" | "length" | "half_shoulder" | "to_sleeve" | "chest" | "waist" | "collar" | "other_notes", ExtArgs["result"]["shirtMeasurement"]>
  export type ShirtMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | ShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | ShirtMeasurement$orderArgs<ExtArgs>
    Items?: boolean | ShirtMeasurement$ItemsArgs<ExtArgs>
    _count?: boolean | ShirtMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShirtMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | ShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | ShirtMeasurement$orderArgs<ExtArgs>
  }
  export type ShirtMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | ShirtMeasurement$customerArgs<ExtArgs>
    order?: boolean | ShirtMeasurement$orderArgs<ExtArgs>
  }

  export type $ShirtMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShirtMeasurement"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$OrdersPayload<ExtArgs> | null
      Items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      measurement_id: string
      customer_id: number | null
      orderNo: string | null
      date: Date | null
      length: string | null
      half_shoulder: string | null
      to_sleeve: string | null
      chest: string | null
      waist: string | null
      collar: string | null
      other_notes: string | null
    }, ExtArgs["result"]["shirtMeasurement"]>
    composites: {}
  }

  type ShirtMeasurementGetPayload<S extends boolean | null | undefined | ShirtMeasurementDefaultArgs> = $Result.GetResult<Prisma.$ShirtMeasurementPayload, S>

  type ShirtMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShirtMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShirtMeasurementCountAggregateInputType | true
    }

  export interface ShirtMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShirtMeasurement'], meta: { name: 'ShirtMeasurement' } }
    /**
     * Find zero or one ShirtMeasurement that matches the filter.
     * @param {ShirtMeasurementFindUniqueArgs} args - Arguments to find a ShirtMeasurement
     * @example
     * // Get one ShirtMeasurement
     * const shirtMeasurement = await prisma.shirtMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShirtMeasurementFindUniqueArgs>(args: SelectSubset<T, ShirtMeasurementFindUniqueArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShirtMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShirtMeasurementFindUniqueOrThrowArgs} args - Arguments to find a ShirtMeasurement
     * @example
     * // Get one ShirtMeasurement
     * const shirtMeasurement = await prisma.shirtMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShirtMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, ShirtMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShirtMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementFindFirstArgs} args - Arguments to find a ShirtMeasurement
     * @example
     * // Get one ShirtMeasurement
     * const shirtMeasurement = await prisma.shirtMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShirtMeasurementFindFirstArgs>(args?: SelectSubset<T, ShirtMeasurementFindFirstArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShirtMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementFindFirstOrThrowArgs} args - Arguments to find a ShirtMeasurement
     * @example
     * // Get one ShirtMeasurement
     * const shirtMeasurement = await prisma.shirtMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShirtMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, ShirtMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShirtMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShirtMeasurements
     * const shirtMeasurements = await prisma.shirtMeasurement.findMany()
     * 
     * // Get first 10 ShirtMeasurements
     * const shirtMeasurements = await prisma.shirtMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `measurement_id`
     * const shirtMeasurementWithMeasurement_idOnly = await prisma.shirtMeasurement.findMany({ select: { measurement_id: true } })
     * 
     */
    findMany<T extends ShirtMeasurementFindManyArgs>(args?: SelectSubset<T, ShirtMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShirtMeasurement.
     * @param {ShirtMeasurementCreateArgs} args - Arguments to create a ShirtMeasurement.
     * @example
     * // Create one ShirtMeasurement
     * const ShirtMeasurement = await prisma.shirtMeasurement.create({
     *   data: {
     *     // ... data to create a ShirtMeasurement
     *   }
     * })
     * 
     */
    create<T extends ShirtMeasurementCreateArgs>(args: SelectSubset<T, ShirtMeasurementCreateArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShirtMeasurements.
     * @param {ShirtMeasurementCreateManyArgs} args - Arguments to create many ShirtMeasurements.
     * @example
     * // Create many ShirtMeasurements
     * const shirtMeasurement = await prisma.shirtMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShirtMeasurementCreateManyArgs>(args?: SelectSubset<T, ShirtMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShirtMeasurements and returns the data saved in the database.
     * @param {ShirtMeasurementCreateManyAndReturnArgs} args - Arguments to create many ShirtMeasurements.
     * @example
     * // Create many ShirtMeasurements
     * const shirtMeasurement = await prisma.shirtMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShirtMeasurements and only return the `measurement_id`
     * const shirtMeasurementWithMeasurement_idOnly = await prisma.shirtMeasurement.createManyAndReturn({
     *   select: { measurement_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShirtMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, ShirtMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShirtMeasurement.
     * @param {ShirtMeasurementDeleteArgs} args - Arguments to delete one ShirtMeasurement.
     * @example
     * // Delete one ShirtMeasurement
     * const ShirtMeasurement = await prisma.shirtMeasurement.delete({
     *   where: {
     *     // ... filter to delete one ShirtMeasurement
     *   }
     * })
     * 
     */
    delete<T extends ShirtMeasurementDeleteArgs>(args: SelectSubset<T, ShirtMeasurementDeleteArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShirtMeasurement.
     * @param {ShirtMeasurementUpdateArgs} args - Arguments to update one ShirtMeasurement.
     * @example
     * // Update one ShirtMeasurement
     * const shirtMeasurement = await prisma.shirtMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShirtMeasurementUpdateArgs>(args: SelectSubset<T, ShirtMeasurementUpdateArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShirtMeasurements.
     * @param {ShirtMeasurementDeleteManyArgs} args - Arguments to filter ShirtMeasurements to delete.
     * @example
     * // Delete a few ShirtMeasurements
     * const { count } = await prisma.shirtMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShirtMeasurementDeleteManyArgs>(args?: SelectSubset<T, ShirtMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShirtMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShirtMeasurements
     * const shirtMeasurement = await prisma.shirtMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShirtMeasurementUpdateManyArgs>(args: SelectSubset<T, ShirtMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShirtMeasurements and returns the data updated in the database.
     * @param {ShirtMeasurementUpdateManyAndReturnArgs} args - Arguments to update many ShirtMeasurements.
     * @example
     * // Update many ShirtMeasurements
     * const shirtMeasurement = await prisma.shirtMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShirtMeasurements and only return the `measurement_id`
     * const shirtMeasurementWithMeasurement_idOnly = await prisma.shirtMeasurement.updateManyAndReturn({
     *   select: { measurement_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShirtMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, ShirtMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShirtMeasurement.
     * @param {ShirtMeasurementUpsertArgs} args - Arguments to update or create a ShirtMeasurement.
     * @example
     * // Update or create a ShirtMeasurement
     * const shirtMeasurement = await prisma.shirtMeasurement.upsert({
     *   create: {
     *     // ... data to create a ShirtMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShirtMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends ShirtMeasurementUpsertArgs>(args: SelectSubset<T, ShirtMeasurementUpsertArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShirtMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementCountArgs} args - Arguments to filter ShirtMeasurements to count.
     * @example
     * // Count the number of ShirtMeasurements
     * const count = await prisma.shirtMeasurement.count({
     *   where: {
     *     // ... the filter for the ShirtMeasurements we want to count
     *   }
     * })
    **/
    count<T extends ShirtMeasurementCountArgs>(
      args?: Subset<T, ShirtMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShirtMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShirtMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShirtMeasurementAggregateArgs>(args: Subset<T, ShirtMeasurementAggregateArgs>): Prisma.PrismaPromise<GetShirtMeasurementAggregateType<T>>

    /**
     * Group by ShirtMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShirtMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShirtMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShirtMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: ShirtMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShirtMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShirtMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShirtMeasurement model
   */
  readonly fields: ShirtMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShirtMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShirtMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends ShirtMeasurement$customerArgs<ExtArgs> = {}>(args?: Subset<T, ShirtMeasurement$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends ShirtMeasurement$orderArgs<ExtArgs> = {}>(args?: Subset<T, ShirtMeasurement$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Items<T extends ShirtMeasurement$ItemsArgs<ExtArgs> = {}>(args?: Subset<T, ShirtMeasurement$ItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShirtMeasurement model
   */
  interface ShirtMeasurementFieldRefs {
    readonly measurement_id: FieldRef<"ShirtMeasurement", 'String'>
    readonly customer_id: FieldRef<"ShirtMeasurement", 'Int'>
    readonly orderNo: FieldRef<"ShirtMeasurement", 'String'>
    readonly date: FieldRef<"ShirtMeasurement", 'DateTime'>
    readonly length: FieldRef<"ShirtMeasurement", 'String'>
    readonly half_shoulder: FieldRef<"ShirtMeasurement", 'String'>
    readonly to_sleeve: FieldRef<"ShirtMeasurement", 'String'>
    readonly chest: FieldRef<"ShirtMeasurement", 'String'>
    readonly waist: FieldRef<"ShirtMeasurement", 'String'>
    readonly collar: FieldRef<"ShirtMeasurement", 'String'>
    readonly other_notes: FieldRef<"ShirtMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShirtMeasurement findUnique
   */
  export type ShirtMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ShirtMeasurement to fetch.
     */
    where: ShirtMeasurementWhereUniqueInput
  }

  /**
   * ShirtMeasurement findUniqueOrThrow
   */
  export type ShirtMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ShirtMeasurement to fetch.
     */
    where: ShirtMeasurementWhereUniqueInput
  }

  /**
   * ShirtMeasurement findFirst
   */
  export type ShirtMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ShirtMeasurement to fetch.
     */
    where?: ShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShirtMeasurements to fetch.
     */
    orderBy?: ShirtMeasurementOrderByWithRelationInput | ShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShirtMeasurements.
     */
    cursor?: ShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShirtMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShirtMeasurements.
     */
    distinct?: ShirtMeasurementScalarFieldEnum | ShirtMeasurementScalarFieldEnum[]
  }

  /**
   * ShirtMeasurement findFirstOrThrow
   */
  export type ShirtMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ShirtMeasurement to fetch.
     */
    where?: ShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShirtMeasurements to fetch.
     */
    orderBy?: ShirtMeasurementOrderByWithRelationInput | ShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShirtMeasurements.
     */
    cursor?: ShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShirtMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShirtMeasurements.
     */
    distinct?: ShirtMeasurementScalarFieldEnum | ShirtMeasurementScalarFieldEnum[]
  }

  /**
   * ShirtMeasurement findMany
   */
  export type ShirtMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which ShirtMeasurements to fetch.
     */
    where?: ShirtMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShirtMeasurements to fetch.
     */
    orderBy?: ShirtMeasurementOrderByWithRelationInput | ShirtMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShirtMeasurements.
     */
    cursor?: ShirtMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShirtMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShirtMeasurements.
     */
    skip?: number
    distinct?: ShirtMeasurementScalarFieldEnum | ShirtMeasurementScalarFieldEnum[]
  }

  /**
   * ShirtMeasurement create
   */
  export type ShirtMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a ShirtMeasurement.
     */
    data?: XOR<ShirtMeasurementCreateInput, ShirtMeasurementUncheckedCreateInput>
  }

  /**
   * ShirtMeasurement createMany
   */
  export type ShirtMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShirtMeasurements.
     */
    data: ShirtMeasurementCreateManyInput | ShirtMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShirtMeasurement createManyAndReturn
   */
  export type ShirtMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many ShirtMeasurements.
     */
    data: ShirtMeasurementCreateManyInput | ShirtMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShirtMeasurement update
   */
  export type ShirtMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a ShirtMeasurement.
     */
    data: XOR<ShirtMeasurementUpdateInput, ShirtMeasurementUncheckedUpdateInput>
    /**
     * Choose, which ShirtMeasurement to update.
     */
    where: ShirtMeasurementWhereUniqueInput
  }

  /**
   * ShirtMeasurement updateMany
   */
  export type ShirtMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShirtMeasurements.
     */
    data: XOR<ShirtMeasurementUpdateManyMutationInput, ShirtMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which ShirtMeasurements to update
     */
    where?: ShirtMeasurementWhereInput
    /**
     * Limit how many ShirtMeasurements to update.
     */
    limit?: number
  }

  /**
   * ShirtMeasurement updateManyAndReturn
   */
  export type ShirtMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update ShirtMeasurements.
     */
    data: XOR<ShirtMeasurementUpdateManyMutationInput, ShirtMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which ShirtMeasurements to update
     */
    where?: ShirtMeasurementWhereInput
    /**
     * Limit how many ShirtMeasurements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShirtMeasurement upsert
   */
  export type ShirtMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the ShirtMeasurement to update in case it exists.
     */
    where: ShirtMeasurementWhereUniqueInput
    /**
     * In case the ShirtMeasurement found by the `where` argument doesn't exist, create a new ShirtMeasurement with this data.
     */
    create: XOR<ShirtMeasurementCreateInput, ShirtMeasurementUncheckedCreateInput>
    /**
     * In case the ShirtMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShirtMeasurementUpdateInput, ShirtMeasurementUncheckedUpdateInput>
  }

  /**
   * ShirtMeasurement delete
   */
  export type ShirtMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    /**
     * Filter which ShirtMeasurement to delete.
     */
    where: ShirtMeasurementWhereUniqueInput
  }

  /**
   * ShirtMeasurement deleteMany
   */
  export type ShirtMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShirtMeasurements to delete
     */
    where?: ShirtMeasurementWhereInput
    /**
     * Limit how many ShirtMeasurements to delete.
     */
    limit?: number
  }

  /**
   * ShirtMeasurement.customer
   */
  export type ShirtMeasurement$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * ShirtMeasurement.order
   */
  export type ShirtMeasurement$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * ShirtMeasurement.Items
   */
  export type ShirtMeasurement$ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * ShirtMeasurement without action
   */
  export type ShirtMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model OrderPhotos
   */

  export type AggregateOrderPhotos = {
    _count: OrderPhotosCountAggregateOutputType | null
    _avg: OrderPhotosAvgAggregateOutputType | null
    _sum: OrderPhotosSumAggregateOutputType | null
    _min: OrderPhotosMinAggregateOutputType | null
    _max: OrderPhotosMaxAggregateOutputType | null
  }

  export type OrderPhotosAvgAggregateOutputType = {
    photo_id: number | null
  }

  export type OrderPhotosSumAggregateOutputType = {
    photo_id: number | null
  }

  export type OrderPhotosMinAggregateOutputType = {
    photo_id: number | null
    orderNo: string | null
    s3_key: string | null
    uploaded_at: Date | null
  }

  export type OrderPhotosMaxAggregateOutputType = {
    photo_id: number | null
    orderNo: string | null
    s3_key: string | null
    uploaded_at: Date | null
  }

  export type OrderPhotosCountAggregateOutputType = {
    photo_id: number
    orderNo: number
    s3_key: number
    uploaded_at: number
    _all: number
  }


  export type OrderPhotosAvgAggregateInputType = {
    photo_id?: true
  }

  export type OrderPhotosSumAggregateInputType = {
    photo_id?: true
  }

  export type OrderPhotosMinAggregateInputType = {
    photo_id?: true
    orderNo?: true
    s3_key?: true
    uploaded_at?: true
  }

  export type OrderPhotosMaxAggregateInputType = {
    photo_id?: true
    orderNo?: true
    s3_key?: true
    uploaded_at?: true
  }

  export type OrderPhotosCountAggregateInputType = {
    photo_id?: true
    orderNo?: true
    s3_key?: true
    uploaded_at?: true
    _all?: true
  }

  export type OrderPhotosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderPhotos to aggregate.
     */
    where?: OrderPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPhotos to fetch.
     */
    orderBy?: OrderPhotosOrderByWithRelationInput | OrderPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderPhotos
    **/
    _count?: true | OrderPhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderPhotosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderPhotosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderPhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderPhotosMaxAggregateInputType
  }

  export type GetOrderPhotosAggregateType<T extends OrderPhotosAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderPhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderPhotos[P]>
      : GetScalarType<T[P], AggregateOrderPhotos[P]>
  }




  export type OrderPhotosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderPhotosWhereInput
    orderBy?: OrderPhotosOrderByWithAggregationInput | OrderPhotosOrderByWithAggregationInput[]
    by: OrderPhotosScalarFieldEnum[] | OrderPhotosScalarFieldEnum
    having?: OrderPhotosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderPhotosCountAggregateInputType | true
    _avg?: OrderPhotosAvgAggregateInputType
    _sum?: OrderPhotosSumAggregateInputType
    _min?: OrderPhotosMinAggregateInputType
    _max?: OrderPhotosMaxAggregateInputType
  }

  export type OrderPhotosGroupByOutputType = {
    photo_id: number
    orderNo: string | null
    s3_key: string | null
    uploaded_at: Date
    _count: OrderPhotosCountAggregateOutputType | null
    _avg: OrderPhotosAvgAggregateOutputType | null
    _sum: OrderPhotosSumAggregateOutputType | null
    _min: OrderPhotosMinAggregateOutputType | null
    _max: OrderPhotosMaxAggregateOutputType | null
  }

  type GetOrderPhotosGroupByPayload<T extends OrderPhotosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderPhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderPhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderPhotosGroupByOutputType[P]>
            : GetScalarType<T[P], OrderPhotosGroupByOutputType[P]>
        }
      >
    >


  export type OrderPhotosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    photo_id?: boolean
    orderNo?: boolean
    s3_key?: boolean
    uploaded_at?: boolean
    order?: boolean | OrderPhotos$orderArgs<ExtArgs>
  }, ExtArgs["result"]["orderPhotos"]>

  export type OrderPhotosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    photo_id?: boolean
    orderNo?: boolean
    s3_key?: boolean
    uploaded_at?: boolean
    order?: boolean | OrderPhotos$orderArgs<ExtArgs>
  }, ExtArgs["result"]["orderPhotos"]>

  export type OrderPhotosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    photo_id?: boolean
    orderNo?: boolean
    s3_key?: boolean
    uploaded_at?: boolean
    order?: boolean | OrderPhotos$orderArgs<ExtArgs>
  }, ExtArgs["result"]["orderPhotos"]>

  export type OrderPhotosSelectScalar = {
    photo_id?: boolean
    orderNo?: boolean
    s3_key?: boolean
    uploaded_at?: boolean
  }

  export type OrderPhotosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"photo_id" | "orderNo" | "s3_key" | "uploaded_at", ExtArgs["result"]["orderPhotos"]>
  export type OrderPhotosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderPhotos$orderArgs<ExtArgs>
  }
  export type OrderPhotosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderPhotos$orderArgs<ExtArgs>
  }
  export type OrderPhotosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderPhotos$orderArgs<ExtArgs>
  }

  export type $OrderPhotosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderPhotos"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      photo_id: number
      orderNo: string | null
      s3_key: string | null
      uploaded_at: Date
    }, ExtArgs["result"]["orderPhotos"]>
    composites: {}
  }

  type OrderPhotosGetPayload<S extends boolean | null | undefined | OrderPhotosDefaultArgs> = $Result.GetResult<Prisma.$OrderPhotosPayload, S>

  type OrderPhotosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderPhotosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderPhotosCountAggregateInputType | true
    }

  export interface OrderPhotosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderPhotos'], meta: { name: 'OrderPhotos' } }
    /**
     * Find zero or one OrderPhotos that matches the filter.
     * @param {OrderPhotosFindUniqueArgs} args - Arguments to find a OrderPhotos
     * @example
     * // Get one OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderPhotosFindUniqueArgs>(args: SelectSubset<T, OrderPhotosFindUniqueArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderPhotos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderPhotosFindUniqueOrThrowArgs} args - Arguments to find a OrderPhotos
     * @example
     * // Get one OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderPhotosFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderPhotosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosFindFirstArgs} args - Arguments to find a OrderPhotos
     * @example
     * // Get one OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderPhotosFindFirstArgs>(args?: SelectSubset<T, OrderPhotosFindFirstArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderPhotos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosFindFirstOrThrowArgs} args - Arguments to find a OrderPhotos
     * @example
     * // Get one OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderPhotosFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderPhotosFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.findMany()
     * 
     * // Get first 10 OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.findMany({ take: 10 })
     * 
     * // Only select the `photo_id`
     * const orderPhotosWithPhoto_idOnly = await prisma.orderPhotos.findMany({ select: { photo_id: true } })
     * 
     */
    findMany<T extends OrderPhotosFindManyArgs>(args?: SelectSubset<T, OrderPhotosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderPhotos.
     * @param {OrderPhotosCreateArgs} args - Arguments to create a OrderPhotos.
     * @example
     * // Create one OrderPhotos
     * const OrderPhotos = await prisma.orderPhotos.create({
     *   data: {
     *     // ... data to create a OrderPhotos
     *   }
     * })
     * 
     */
    create<T extends OrderPhotosCreateArgs>(args: SelectSubset<T, OrderPhotosCreateArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderPhotos.
     * @param {OrderPhotosCreateManyArgs} args - Arguments to create many OrderPhotos.
     * @example
     * // Create many OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderPhotosCreateManyArgs>(args?: SelectSubset<T, OrderPhotosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderPhotos and returns the data saved in the database.
     * @param {OrderPhotosCreateManyAndReturnArgs} args - Arguments to create many OrderPhotos.
     * @example
     * // Create many OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderPhotos and only return the `photo_id`
     * const orderPhotosWithPhoto_idOnly = await prisma.orderPhotos.createManyAndReturn({
     *   select: { photo_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderPhotosCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderPhotosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderPhotos.
     * @param {OrderPhotosDeleteArgs} args - Arguments to delete one OrderPhotos.
     * @example
     * // Delete one OrderPhotos
     * const OrderPhotos = await prisma.orderPhotos.delete({
     *   where: {
     *     // ... filter to delete one OrderPhotos
     *   }
     * })
     * 
     */
    delete<T extends OrderPhotosDeleteArgs>(args: SelectSubset<T, OrderPhotosDeleteArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderPhotos.
     * @param {OrderPhotosUpdateArgs} args - Arguments to update one OrderPhotos.
     * @example
     * // Update one OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderPhotosUpdateArgs>(args: SelectSubset<T, OrderPhotosUpdateArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderPhotos.
     * @param {OrderPhotosDeleteManyArgs} args - Arguments to filter OrderPhotos to delete.
     * @example
     * // Delete a few OrderPhotos
     * const { count } = await prisma.orderPhotos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderPhotosDeleteManyArgs>(args?: SelectSubset<T, OrderPhotosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderPhotosUpdateManyArgs>(args: SelectSubset<T, OrderPhotosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPhotos and returns the data updated in the database.
     * @param {OrderPhotosUpdateManyAndReturnArgs} args - Arguments to update many OrderPhotos.
     * @example
     * // Update many OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderPhotos and only return the `photo_id`
     * const orderPhotosWithPhoto_idOnly = await prisma.orderPhotos.updateManyAndReturn({
     *   select: { photo_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderPhotosUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderPhotosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderPhotos.
     * @param {OrderPhotosUpsertArgs} args - Arguments to update or create a OrderPhotos.
     * @example
     * // Update or create a OrderPhotos
     * const orderPhotos = await prisma.orderPhotos.upsert({
     *   create: {
     *     // ... data to create a OrderPhotos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderPhotos we want to update
     *   }
     * })
     */
    upsert<T extends OrderPhotosUpsertArgs>(args: SelectSubset<T, OrderPhotosUpsertArgs<ExtArgs>>): Prisma__OrderPhotosClient<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosCountArgs} args - Arguments to filter OrderPhotos to count.
     * @example
     * // Count the number of OrderPhotos
     * const count = await prisma.orderPhotos.count({
     *   where: {
     *     // ... the filter for the OrderPhotos we want to count
     *   }
     * })
    **/
    count<T extends OrderPhotosCountArgs>(
      args?: Subset<T, OrderPhotosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderPhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderPhotosAggregateArgs>(args: Subset<T, OrderPhotosAggregateArgs>): Prisma.PrismaPromise<GetOrderPhotosAggregateType<T>>

    /**
     * Group by OrderPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPhotosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderPhotosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderPhotosGroupByArgs['orderBy'] }
        : { orderBy?: OrderPhotosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderPhotosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderPhotos model
   */
  readonly fields: OrderPhotosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderPhotos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderPhotosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderPhotos$orderArgs<ExtArgs> = {}>(args?: Subset<T, OrderPhotos$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderPhotos model
   */
  interface OrderPhotosFieldRefs {
    readonly photo_id: FieldRef<"OrderPhotos", 'Int'>
    readonly orderNo: FieldRef<"OrderPhotos", 'String'>
    readonly s3_key: FieldRef<"OrderPhotos", 'String'>
    readonly uploaded_at: FieldRef<"OrderPhotos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderPhotos findUnique
   */
  export type OrderPhotosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * Filter, which OrderPhotos to fetch.
     */
    where: OrderPhotosWhereUniqueInput
  }

  /**
   * OrderPhotos findUniqueOrThrow
   */
  export type OrderPhotosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * Filter, which OrderPhotos to fetch.
     */
    where: OrderPhotosWhereUniqueInput
  }

  /**
   * OrderPhotos findFirst
   */
  export type OrderPhotosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * Filter, which OrderPhotos to fetch.
     */
    where?: OrderPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPhotos to fetch.
     */
    orderBy?: OrderPhotosOrderByWithRelationInput | OrderPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderPhotos.
     */
    cursor?: OrderPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderPhotos.
     */
    distinct?: OrderPhotosScalarFieldEnum | OrderPhotosScalarFieldEnum[]
  }

  /**
   * OrderPhotos findFirstOrThrow
   */
  export type OrderPhotosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * Filter, which OrderPhotos to fetch.
     */
    where?: OrderPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPhotos to fetch.
     */
    orderBy?: OrderPhotosOrderByWithRelationInput | OrderPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderPhotos.
     */
    cursor?: OrderPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderPhotos.
     */
    distinct?: OrderPhotosScalarFieldEnum | OrderPhotosScalarFieldEnum[]
  }

  /**
   * OrderPhotos findMany
   */
  export type OrderPhotosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * Filter, which OrderPhotos to fetch.
     */
    where?: OrderPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPhotos to fetch.
     */
    orderBy?: OrderPhotosOrderByWithRelationInput | OrderPhotosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderPhotos.
     */
    cursor?: OrderPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPhotos.
     */
    skip?: number
    distinct?: OrderPhotosScalarFieldEnum | OrderPhotosScalarFieldEnum[]
  }

  /**
   * OrderPhotos create
   */
  export type OrderPhotosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderPhotos.
     */
    data?: XOR<OrderPhotosCreateInput, OrderPhotosUncheckedCreateInput>
  }

  /**
   * OrderPhotos createMany
   */
  export type OrderPhotosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderPhotos.
     */
    data: OrderPhotosCreateManyInput | OrderPhotosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderPhotos createManyAndReturn
   */
  export type OrderPhotosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * The data used to create many OrderPhotos.
     */
    data: OrderPhotosCreateManyInput | OrderPhotosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderPhotos update
   */
  export type OrderPhotosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderPhotos.
     */
    data: XOR<OrderPhotosUpdateInput, OrderPhotosUncheckedUpdateInput>
    /**
     * Choose, which OrderPhotos to update.
     */
    where: OrderPhotosWhereUniqueInput
  }

  /**
   * OrderPhotos updateMany
   */
  export type OrderPhotosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderPhotos.
     */
    data: XOR<OrderPhotosUpdateManyMutationInput, OrderPhotosUncheckedUpdateManyInput>
    /**
     * Filter which OrderPhotos to update
     */
    where?: OrderPhotosWhereInput
    /**
     * Limit how many OrderPhotos to update.
     */
    limit?: number
  }

  /**
   * OrderPhotos updateManyAndReturn
   */
  export type OrderPhotosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * The data used to update OrderPhotos.
     */
    data: XOR<OrderPhotosUpdateManyMutationInput, OrderPhotosUncheckedUpdateManyInput>
    /**
     * Filter which OrderPhotos to update
     */
    where?: OrderPhotosWhereInput
    /**
     * Limit how many OrderPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderPhotos upsert
   */
  export type OrderPhotosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderPhotos to update in case it exists.
     */
    where: OrderPhotosWhereUniqueInput
    /**
     * In case the OrderPhotos found by the `where` argument doesn't exist, create a new OrderPhotos with this data.
     */
    create: XOR<OrderPhotosCreateInput, OrderPhotosUncheckedCreateInput>
    /**
     * In case the OrderPhotos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderPhotosUpdateInput, OrderPhotosUncheckedUpdateInput>
  }

  /**
   * OrderPhotos delete
   */
  export type OrderPhotosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    /**
     * Filter which OrderPhotos to delete.
     */
    where: OrderPhotosWhereUniqueInput
  }

  /**
   * OrderPhotos deleteMany
   */
  export type OrderPhotosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderPhotos to delete
     */
    where?: OrderPhotosWhereInput
    /**
     * Limit how many OrderPhotos to delete.
     */
    limit?: number
  }

  /**
   * OrderPhotos.order
   */
  export type OrderPhotos$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * OrderPhotos without action
   */
  export type OrderPhotosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
  }


  /**
   * Model Orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    customer_id: number | null
  }

  export type OrdersSumAggregateOutputType = {
    customer_id: number | null
  }

  export type OrdersMinAggregateOutputType = {
    orderNo: string | null
    customer_id: number | null
    date: Date | null
    onote: string | null
  }

  export type OrdersMaxAggregateOutputType = {
    orderNo: string | null
    customer_id: number | null
    date: Date | null
    onote: string | null
  }

  export type OrdersCountAggregateOutputType = {
    orderNo: number
    customer_id: number
    date: number
    onote: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    customer_id?: true
  }

  export type OrdersSumAggregateInputType = {
    customer_id?: true
  }

  export type OrdersMinAggregateInputType = {
    orderNo?: true
    customer_id?: true
    date?: true
    onote?: true
  }

  export type OrdersMaxAggregateInputType = {
    orderNo?: true
    customer_id?: true
    date?: true
    onote?: true
  }

  export type OrdersCountAggregateInputType = {
    orderNo?: true
    customer_id?: true
    date?: true
    onote?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to aggregate.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithAggregationInput | OrdersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    orderNo: string
    customer_id: number | null
    date: Date | null
    onote: string | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderNo?: boolean
    customer_id?: boolean
    date?: boolean
    onote?: boolean
    customer?: boolean | Orders$customerArgs<ExtArgs>
    items?: boolean | Orders$itemsArgs<ExtArgs>
    FinalJacketMeasurement?: boolean | Orders$FinalJacketMeasurementArgs<ExtArgs>
    FinalPantMeasurement?: boolean | Orders$FinalPantMeasurementArgs<ExtArgs>
    FinalShirtMeasurement?: boolean | Orders$FinalShirtMeasurementArgs<ExtArgs>
    JacketMeasurement?: boolean | Orders$JacketMeasurementArgs<ExtArgs>
    PantMeasurement?: boolean | Orders$PantMeasurementArgs<ExtArgs>
    ShirtMeasurement?: boolean | Orders$ShirtMeasurementArgs<ExtArgs>
    OrderPhotos?: boolean | Orders$OrderPhotosArgs<ExtArgs>
    tailors?: boolean | Orders$tailorsArgs<ExtArgs>
    production?: boolean | Orders$productionArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderNo?: boolean
    customer_id?: boolean
    date?: boolean
    onote?: boolean
    customer?: boolean | Orders$customerArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderNo?: boolean
    customer_id?: boolean
    date?: boolean
    onote?: boolean
    customer?: boolean | Orders$customerArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectScalar = {
    orderNo?: boolean
    customer_id?: boolean
    date?: boolean
    onote?: boolean
  }

  export type OrdersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"orderNo" | "customer_id" | "date" | "onote", ExtArgs["result"]["orders"]>
  export type OrdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Orders$customerArgs<ExtArgs>
    items?: boolean | Orders$itemsArgs<ExtArgs>
    FinalJacketMeasurement?: boolean | Orders$FinalJacketMeasurementArgs<ExtArgs>
    FinalPantMeasurement?: boolean | Orders$FinalPantMeasurementArgs<ExtArgs>
    FinalShirtMeasurement?: boolean | Orders$FinalShirtMeasurementArgs<ExtArgs>
    JacketMeasurement?: boolean | Orders$JacketMeasurementArgs<ExtArgs>
    PantMeasurement?: boolean | Orders$PantMeasurementArgs<ExtArgs>
    ShirtMeasurement?: boolean | Orders$ShirtMeasurementArgs<ExtArgs>
    OrderPhotos?: boolean | Orders$OrderPhotosArgs<ExtArgs>
    tailors?: boolean | Orders$tailorsArgs<ExtArgs>
    production?: boolean | Orders$productionArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrdersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Orders$customerArgs<ExtArgs>
  }
  export type OrdersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Orders$customerArgs<ExtArgs>
  }

  export type $OrdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orders"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$ItemsPayload<ExtArgs>[]
      FinalJacketMeasurement: Prisma.$FinalJacketMeasurementPayload<ExtArgs>[]
      FinalPantMeasurement: Prisma.$FinalPantMeasurementPayload<ExtArgs>[]
      FinalShirtMeasurement: Prisma.$FinalShirtMeasurementPayload<ExtArgs>[]
      JacketMeasurement: Prisma.$JacketMeasurementPayload<ExtArgs>[]
      PantMeasurement: Prisma.$PantMeasurementPayload<ExtArgs>[]
      ShirtMeasurement: Prisma.$ShirtMeasurementPayload<ExtArgs>[]
      OrderPhotos: Prisma.$OrderPhotosPayload<ExtArgs>[]
      tailors: Prisma.$OrderTailorPayload<ExtArgs>[]
      production: Prisma.$OrderProductionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      orderNo: string
      customer_id: number | null
      date: Date | null
      onote: string | null
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type OrdersGetPayload<S extends boolean | null | undefined | OrdersDefaultArgs> = $Result.GetResult<Prisma.$OrdersPayload, S>

  type OrdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrdersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface OrdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orders'], meta: { name: 'Orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdersFindUniqueArgs>(args: SelectSubset<T, OrdersFindUniqueArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdersFindFirstArgs>(args?: SelectSubset<T, OrdersFindFirstArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdersFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `orderNo`
     * const ordersWithOrderNoOnly = await prisma.orders.findMany({ select: { orderNo: true } })
     * 
     */
    findMany<T extends OrdersFindManyArgs>(args?: SelectSubset<T, OrdersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends OrdersCreateArgs>(args: SelectSubset<T, OrdersCreateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdersCreateManyArgs>(args?: SelectSubset<T, OrdersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrdersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `orderNo`
     * const ordersWithOrderNoOnly = await prisma.orders.createManyAndReturn({
     *   select: { orderNo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdersCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends OrdersDeleteArgs>(args: SelectSubset<T, OrdersDeleteArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdersUpdateArgs>(args: SelectSubset<T, OrdersUpdateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdersDeleteManyArgs>(args?: SelectSubset<T, OrdersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdersUpdateManyArgs>(args: SelectSubset<T, OrdersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrdersUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `orderNo`
     * const ordersWithOrderNoOnly = await prisma.orders.updateManyAndReturn({
     *   select: { orderNo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrdersUpdateManyAndReturnArgs>(args: SelectSubset<T, OrdersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends OrdersUpsertArgs>(args: SelectSubset<T, OrdersUpsertArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orders model
   */
  readonly fields: OrdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Orders$customerArgs<ExtArgs> = {}>(args?: Subset<T, Orders$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Orders$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FinalJacketMeasurement<T extends Orders$FinalJacketMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Orders$FinalJacketMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FinalPantMeasurement<T extends Orders$FinalPantMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Orders$FinalPantMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FinalShirtMeasurement<T extends Orders$FinalShirtMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Orders$FinalShirtMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    JacketMeasurement<T extends Orders$JacketMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Orders$JacketMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PantMeasurement<T extends Orders$PantMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Orders$PantMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShirtMeasurement<T extends Orders$ShirtMeasurementArgs<ExtArgs> = {}>(args?: Subset<T, Orders$ShirtMeasurementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderPhotos<T extends Orders$OrderPhotosArgs<ExtArgs> = {}>(args?: Subset<T, Orders$OrderPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPhotosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tailors<T extends Orders$tailorsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$tailorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    production<T extends Orders$productionArgs<ExtArgs> = {}>(args?: Subset<T, Orders$productionArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Orders model
   */
  interface OrdersFieldRefs {
    readonly orderNo: FieldRef<"Orders", 'String'>
    readonly customer_id: FieldRef<"Orders", 'Int'>
    readonly date: FieldRef<"Orders", 'DateTime'>
    readonly onote: FieldRef<"Orders", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Orders findUnique
   */
  export type OrdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findFirst
   */
  export type OrdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders create
   */
  export type OrdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to create a Orders.
     */
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }

  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Orders createManyAndReturn
   */
  export type OrdersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orders update
   */
  export type OrdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to update a Orders.
     */
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Orders updateManyAndReturn
   */
  export type OrdersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The filter to search for the Orders to update in case it exists.
     */
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     */
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }

  /**
   * Orders delete
   */
  export type OrdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter which Orders to delete.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrdersWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Orders.customer
   */
  export type Orders$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Orders.items
   */
  export type Orders$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * Orders.FinalJacketMeasurement
   */
  export type Orders$FinalJacketMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    where?: FinalJacketMeasurementWhereInput
    orderBy?: FinalJacketMeasurementOrderByWithRelationInput | FinalJacketMeasurementOrderByWithRelationInput[]
    cursor?: FinalJacketMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalJacketMeasurementScalarFieldEnum | FinalJacketMeasurementScalarFieldEnum[]
  }

  /**
   * Orders.FinalPantMeasurement
   */
  export type Orders$FinalPantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    where?: FinalPantMeasurementWhereInput
    orderBy?: FinalPantMeasurementOrderByWithRelationInput | FinalPantMeasurementOrderByWithRelationInput[]
    cursor?: FinalPantMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalPantMeasurementScalarFieldEnum | FinalPantMeasurementScalarFieldEnum[]
  }

  /**
   * Orders.FinalShirtMeasurement
   */
  export type Orders$FinalShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    where?: FinalShirtMeasurementWhereInput
    orderBy?: FinalShirtMeasurementOrderByWithRelationInput | FinalShirtMeasurementOrderByWithRelationInput[]
    cursor?: FinalShirtMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalShirtMeasurementScalarFieldEnum | FinalShirtMeasurementScalarFieldEnum[]
  }

  /**
   * Orders.JacketMeasurement
   */
  export type Orders$JacketMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    where?: JacketMeasurementWhereInput
    orderBy?: JacketMeasurementOrderByWithRelationInput | JacketMeasurementOrderByWithRelationInput[]
    cursor?: JacketMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JacketMeasurementScalarFieldEnum | JacketMeasurementScalarFieldEnum[]
  }

  /**
   * Orders.PantMeasurement
   */
  export type Orders$PantMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    where?: PantMeasurementWhereInput
    orderBy?: PantMeasurementOrderByWithRelationInput | PantMeasurementOrderByWithRelationInput[]
    cursor?: PantMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PantMeasurementScalarFieldEnum | PantMeasurementScalarFieldEnum[]
  }

  /**
   * Orders.ShirtMeasurement
   */
  export type Orders$ShirtMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    where?: ShirtMeasurementWhereInput
    orderBy?: ShirtMeasurementOrderByWithRelationInput | ShirtMeasurementOrderByWithRelationInput[]
    cursor?: ShirtMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShirtMeasurementScalarFieldEnum | ShirtMeasurementScalarFieldEnum[]
  }

  /**
   * Orders.OrderPhotos
   */
  export type Orders$OrderPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderPhotos
     */
    select?: OrderPhotosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderPhotos
     */
    omit?: OrderPhotosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderPhotosInclude<ExtArgs> | null
    where?: OrderPhotosWhereInput
    orderBy?: OrderPhotosOrderByWithRelationInput | OrderPhotosOrderByWithRelationInput[]
    cursor?: OrderPhotosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderPhotosScalarFieldEnum | OrderPhotosScalarFieldEnum[]
  }

  /**
   * Orders.tailors
   */
  export type Orders$tailorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    where?: OrderTailorWhereInput
    orderBy?: OrderTailorOrderByWithRelationInput | OrderTailorOrderByWithRelationInput[]
    cursor?: OrderTailorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTailorScalarFieldEnum | OrderTailorScalarFieldEnum[]
  }

  /**
   * Orders.production
   */
  export type Orders$productionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    where?: OrderProductionWhereInput
  }

  /**
   * Orders without action
   */
  export type OrdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
  }


  /**
   * Model Items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    item_id: number | null
    fabric_id: number | null
    lining_fabric_id: number | null
  }

  export type ItemsSumAggregateOutputType = {
    item_id: number | null
    fabric_id: number | null
    lining_fabric_id: number | null
  }

  export type ItemsMinAggregateOutputType = {
    item_id: number | null
    orderNo: string | null
    item_name: string | null
    item_type: $Enums.ItemType | null
    fabric_id: number | null
    lining_fabric_id: number | null
    jacket_measurement_id: string | null
    shirt_measurement_id: string | null
    pant_measurement_id: string | null
    final_jacket_measurement_id: string | null
    final_shirt_measurement_id: string | null
    final_pant_measurement_id: string | null
  }

  export type ItemsMaxAggregateOutputType = {
    item_id: number | null
    orderNo: string | null
    item_name: string | null
    item_type: $Enums.ItemType | null
    fabric_id: number | null
    lining_fabric_id: number | null
    jacket_measurement_id: string | null
    shirt_measurement_id: string | null
    pant_measurement_id: string | null
    final_jacket_measurement_id: string | null
    final_shirt_measurement_id: string | null
    final_pant_measurement_id: string | null
  }

  export type ItemsCountAggregateOutputType = {
    item_id: number
    orderNo: number
    item_name: number
    item_type: number
    fabric_id: number
    lining_fabric_id: number
    jacket_measurement_id: number
    shirt_measurement_id: number
    pant_measurement_id: number
    final_jacket_measurement_id: number
    final_shirt_measurement_id: number
    final_pant_measurement_id: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    item_id?: true
    fabric_id?: true
    lining_fabric_id?: true
  }

  export type ItemsSumAggregateInputType = {
    item_id?: true
    fabric_id?: true
    lining_fabric_id?: true
  }

  export type ItemsMinAggregateInputType = {
    item_id?: true
    orderNo?: true
    item_name?: true
    item_type?: true
    fabric_id?: true
    lining_fabric_id?: true
    jacket_measurement_id?: true
    shirt_measurement_id?: true
    pant_measurement_id?: true
    final_jacket_measurement_id?: true
    final_shirt_measurement_id?: true
    final_pant_measurement_id?: true
  }

  export type ItemsMaxAggregateInputType = {
    item_id?: true
    orderNo?: true
    item_name?: true
    item_type?: true
    fabric_id?: true
    lining_fabric_id?: true
    jacket_measurement_id?: true
    shirt_measurement_id?: true
    pant_measurement_id?: true
    final_jacket_measurement_id?: true
    final_shirt_measurement_id?: true
    final_pant_measurement_id?: true
  }

  export type ItemsCountAggregateInputType = {
    item_id?: true
    orderNo?: true
    item_name?: true
    item_type?: true
    fabric_id?: true
    lining_fabric_id?: true
    jacket_measurement_id?: true
    shirt_measurement_id?: true
    pant_measurement_id?: true
    final_jacket_measurement_id?: true
    final_shirt_measurement_id?: true
    final_pant_measurement_id?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to aggregate.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type ItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithAggregationInput | ItemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: ItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    item_id: number
    orderNo: string | null
    item_name: string | null
    item_type: $Enums.ItemType | null
    fabric_id: number | null
    lining_fabric_id: number | null
    jacket_measurement_id: string | null
    shirt_measurement_id: string | null
    pant_measurement_id: string | null
    final_jacket_measurement_id: string | null
    final_shirt_measurement_id: string | null
    final_pant_measurement_id: string | null
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends ItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type ItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    orderNo?: boolean
    item_name?: boolean
    item_type?: boolean
    fabric_id?: boolean
    lining_fabric_id?: boolean
    jacket_measurement_id?: boolean
    shirt_measurement_id?: boolean
    pant_measurement_id?: boolean
    final_jacket_measurement_id?: boolean
    final_shirt_measurement_id?: boolean
    final_pant_measurement_id?: boolean
    order?: boolean | Items$orderArgs<ExtArgs>
    fabric?: boolean | Items$fabricArgs<ExtArgs>
    lining_fabric?: boolean | Items$lining_fabricArgs<ExtArgs>
    jacket_measurement?: boolean | Items$jacket_measurementArgs<ExtArgs>
    shirt_measurement?: boolean | Items$shirt_measurementArgs<ExtArgs>
    pant_measurement?: boolean | Items$pant_measurementArgs<ExtArgs>
    final_jacket_measurement?: boolean | Items$final_jacket_measurementArgs<ExtArgs>
    final_shirt_measurement?: boolean | Items$final_shirt_measurementArgs<ExtArgs>
    final_pant_measurement?: boolean | Items$final_pant_measurementArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type ItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    orderNo?: boolean
    item_name?: boolean
    item_type?: boolean
    fabric_id?: boolean
    lining_fabric_id?: boolean
    jacket_measurement_id?: boolean
    shirt_measurement_id?: boolean
    pant_measurement_id?: boolean
    final_jacket_measurement_id?: boolean
    final_shirt_measurement_id?: boolean
    final_pant_measurement_id?: boolean
    order?: boolean | Items$orderArgs<ExtArgs>
    fabric?: boolean | Items$fabricArgs<ExtArgs>
    lining_fabric?: boolean | Items$lining_fabricArgs<ExtArgs>
    jacket_measurement?: boolean | Items$jacket_measurementArgs<ExtArgs>
    shirt_measurement?: boolean | Items$shirt_measurementArgs<ExtArgs>
    pant_measurement?: boolean | Items$pant_measurementArgs<ExtArgs>
    final_jacket_measurement?: boolean | Items$final_jacket_measurementArgs<ExtArgs>
    final_shirt_measurement?: boolean | Items$final_shirt_measurementArgs<ExtArgs>
    final_pant_measurement?: boolean | Items$final_pant_measurementArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type ItemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    item_id?: boolean
    orderNo?: boolean
    item_name?: boolean
    item_type?: boolean
    fabric_id?: boolean
    lining_fabric_id?: boolean
    jacket_measurement_id?: boolean
    shirt_measurement_id?: boolean
    pant_measurement_id?: boolean
    final_jacket_measurement_id?: boolean
    final_shirt_measurement_id?: boolean
    final_pant_measurement_id?: boolean
    order?: boolean | Items$orderArgs<ExtArgs>
    fabric?: boolean | Items$fabricArgs<ExtArgs>
    lining_fabric?: boolean | Items$lining_fabricArgs<ExtArgs>
    jacket_measurement?: boolean | Items$jacket_measurementArgs<ExtArgs>
    shirt_measurement?: boolean | Items$shirt_measurementArgs<ExtArgs>
    pant_measurement?: boolean | Items$pant_measurementArgs<ExtArgs>
    final_jacket_measurement?: boolean | Items$final_jacket_measurementArgs<ExtArgs>
    final_shirt_measurement?: boolean | Items$final_shirt_measurementArgs<ExtArgs>
    final_pant_measurement?: boolean | Items$final_pant_measurementArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type ItemsSelectScalar = {
    item_id?: boolean
    orderNo?: boolean
    item_name?: boolean
    item_type?: boolean
    fabric_id?: boolean
    lining_fabric_id?: boolean
    jacket_measurement_id?: boolean
    shirt_measurement_id?: boolean
    pant_measurement_id?: boolean
    final_jacket_measurement_id?: boolean
    final_shirt_measurement_id?: boolean
    final_pant_measurement_id?: boolean
  }

  export type ItemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"item_id" | "orderNo" | "item_name" | "item_type" | "fabric_id" | "lining_fabric_id" | "jacket_measurement_id" | "shirt_measurement_id" | "pant_measurement_id" | "final_jacket_measurement_id" | "final_shirt_measurement_id" | "final_pant_measurement_id", ExtArgs["result"]["items"]>
  export type ItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Items$orderArgs<ExtArgs>
    fabric?: boolean | Items$fabricArgs<ExtArgs>
    lining_fabric?: boolean | Items$lining_fabricArgs<ExtArgs>
    jacket_measurement?: boolean | Items$jacket_measurementArgs<ExtArgs>
    shirt_measurement?: boolean | Items$shirt_measurementArgs<ExtArgs>
    pant_measurement?: boolean | Items$pant_measurementArgs<ExtArgs>
    final_jacket_measurement?: boolean | Items$final_jacket_measurementArgs<ExtArgs>
    final_shirt_measurement?: boolean | Items$final_shirt_measurementArgs<ExtArgs>
    final_pant_measurement?: boolean | Items$final_pant_measurementArgs<ExtArgs>
  }
  export type ItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Items$orderArgs<ExtArgs>
    fabric?: boolean | Items$fabricArgs<ExtArgs>
    lining_fabric?: boolean | Items$lining_fabricArgs<ExtArgs>
    jacket_measurement?: boolean | Items$jacket_measurementArgs<ExtArgs>
    shirt_measurement?: boolean | Items$shirt_measurementArgs<ExtArgs>
    pant_measurement?: boolean | Items$pant_measurementArgs<ExtArgs>
    final_jacket_measurement?: boolean | Items$final_jacket_measurementArgs<ExtArgs>
    final_shirt_measurement?: boolean | Items$final_shirt_measurementArgs<ExtArgs>
    final_pant_measurement?: boolean | Items$final_pant_measurementArgs<ExtArgs>
  }
  export type ItemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Items$orderArgs<ExtArgs>
    fabric?: boolean | Items$fabricArgs<ExtArgs>
    lining_fabric?: boolean | Items$lining_fabricArgs<ExtArgs>
    jacket_measurement?: boolean | Items$jacket_measurementArgs<ExtArgs>
    shirt_measurement?: boolean | Items$shirt_measurementArgs<ExtArgs>
    pant_measurement?: boolean | Items$pant_measurementArgs<ExtArgs>
    final_jacket_measurement?: boolean | Items$final_jacket_measurementArgs<ExtArgs>
    final_shirt_measurement?: boolean | Items$final_shirt_measurementArgs<ExtArgs>
    final_pant_measurement?: boolean | Items$final_pant_measurementArgs<ExtArgs>
  }

  export type $ItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Items"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs> | null
      fabric: Prisma.$FabricPayload<ExtArgs> | null
      lining_fabric: Prisma.$FabricPayload<ExtArgs> | null
      jacket_measurement: Prisma.$JacketMeasurementPayload<ExtArgs> | null
      shirt_measurement: Prisma.$ShirtMeasurementPayload<ExtArgs> | null
      pant_measurement: Prisma.$PantMeasurementPayload<ExtArgs> | null
      final_jacket_measurement: Prisma.$FinalJacketMeasurementPayload<ExtArgs> | null
      final_shirt_measurement: Prisma.$FinalShirtMeasurementPayload<ExtArgs> | null
      final_pant_measurement: Prisma.$FinalPantMeasurementPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      item_id: number
      orderNo: string | null
      item_name: string | null
      item_type: $Enums.ItemType | null
      fabric_id: number | null
      lining_fabric_id: number | null
      jacket_measurement_id: string | null
      shirt_measurement_id: string | null
      pant_measurement_id: string | null
      final_jacket_measurement_id: string | null
      final_shirt_measurement_id: string | null
      final_pant_measurement_id: string | null
    }, ExtArgs["result"]["items"]>
    composites: {}
  }

  type ItemsGetPayload<S extends boolean | null | undefined | ItemsDefaultArgs> = $Result.GetResult<Prisma.$ItemsPayload, S>

  type ItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface ItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Items'], meta: { name: 'Items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {ItemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemsFindUniqueArgs>(args: SelectSubset<T, ItemsFindUniqueArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemsFindFirstArgs>(args?: SelectSubset<T, ItemsFindFirstArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `item_id`
     * const itemsWithItem_idOnly = await prisma.items.findMany({ select: { item_id: true } })
     * 
     */
    findMany<T extends ItemsFindManyArgs>(args?: SelectSubset<T, ItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Items.
     * @param {ItemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
     */
    create<T extends ItemsCreateArgs>(args: SelectSubset<T, ItemsCreateArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemsCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemsCreateManyArgs>(args?: SelectSubset<T, ItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemsCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `item_id`
     * const itemsWithItem_idOnly = await prisma.items.createManyAndReturn({
     *   select: { item_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Items.
     * @param {ItemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
     */
    delete<T extends ItemsDeleteArgs>(args: SelectSubset<T, ItemsDeleteArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Items.
     * @param {ItemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemsUpdateArgs>(args: SelectSubset<T, ItemsUpdateArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemsDeleteManyArgs>(args?: SelectSubset<T, ItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemsUpdateManyArgs>(args: SelectSubset<T, ItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemsUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `item_id`
     * const itemsWithItem_idOnly = await prisma.items.updateManyAndReturn({
     *   select: { item_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemsUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Items.
     * @param {ItemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
     */
    upsert<T extends ItemsUpsertArgs>(args: SelectSubset<T, ItemsUpsertArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemsCountArgs>(
      args?: Subset<T, ItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemsGroupByArgs['orderBy'] }
        : { orderBy?: ItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Items model
   */
  readonly fields: ItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Items$orderArgs<ExtArgs> = {}>(args?: Subset<T, Items$orderArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fabric<T extends Items$fabricArgs<ExtArgs> = {}>(args?: Subset<T, Items$fabricArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lining_fabric<T extends Items$lining_fabricArgs<ExtArgs> = {}>(args?: Subset<T, Items$lining_fabricArgs<ExtArgs>>): Prisma__FabricClient<$Result.GetResult<Prisma.$FabricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jacket_measurement<T extends Items$jacket_measurementArgs<ExtArgs> = {}>(args?: Subset<T, Items$jacket_measurementArgs<ExtArgs>>): Prisma__JacketMeasurementClient<$Result.GetResult<Prisma.$JacketMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shirt_measurement<T extends Items$shirt_measurementArgs<ExtArgs> = {}>(args?: Subset<T, Items$shirt_measurementArgs<ExtArgs>>): Prisma__ShirtMeasurementClient<$Result.GetResult<Prisma.$ShirtMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pant_measurement<T extends Items$pant_measurementArgs<ExtArgs> = {}>(args?: Subset<T, Items$pant_measurementArgs<ExtArgs>>): Prisma__PantMeasurementClient<$Result.GetResult<Prisma.$PantMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    final_jacket_measurement<T extends Items$final_jacket_measurementArgs<ExtArgs> = {}>(args?: Subset<T, Items$final_jacket_measurementArgs<ExtArgs>>): Prisma__FinalJacketMeasurementClient<$Result.GetResult<Prisma.$FinalJacketMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    final_shirt_measurement<T extends Items$final_shirt_measurementArgs<ExtArgs> = {}>(args?: Subset<T, Items$final_shirt_measurementArgs<ExtArgs>>): Prisma__FinalShirtMeasurementClient<$Result.GetResult<Prisma.$FinalShirtMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    final_pant_measurement<T extends Items$final_pant_measurementArgs<ExtArgs> = {}>(args?: Subset<T, Items$final_pant_measurementArgs<ExtArgs>>): Prisma__FinalPantMeasurementClient<$Result.GetResult<Prisma.$FinalPantMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Items model
   */
  interface ItemsFieldRefs {
    readonly item_id: FieldRef<"Items", 'Int'>
    readonly orderNo: FieldRef<"Items", 'String'>
    readonly item_name: FieldRef<"Items", 'String'>
    readonly item_type: FieldRef<"Items", 'ItemType'>
    readonly fabric_id: FieldRef<"Items", 'Int'>
    readonly lining_fabric_id: FieldRef<"Items", 'Int'>
    readonly jacket_measurement_id: FieldRef<"Items", 'String'>
    readonly shirt_measurement_id: FieldRef<"Items", 'String'>
    readonly pant_measurement_id: FieldRef<"Items", 'String'>
    readonly final_jacket_measurement_id: FieldRef<"Items", 'String'>
    readonly final_shirt_measurement_id: FieldRef<"Items", 'String'>
    readonly final_pant_measurement_id: FieldRef<"Items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Items findUnique
   */
  export type ItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where: ItemsWhereUniqueInput
  }

  /**
   * Items findUniqueOrThrow
   */
  export type ItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where: ItemsWhereUniqueInput
  }

  /**
   * Items findFirst
   */
  export type ItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * Items findFirstOrThrow
   */
  export type ItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * Items findMany
   */
  export type ItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * Items create
   */
  export type ItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a Items.
     */
    data?: XOR<ItemsCreateInput, ItemsUncheckedCreateInput>
  }

  /**
   * Items createMany
   */
  export type ItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemsCreateManyInput | ItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Items createManyAndReturn
   */
  export type ItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemsCreateManyInput | ItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Items update
   */
  export type ItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a Items.
     */
    data: XOR<ItemsUpdateInput, ItemsUncheckedUpdateInput>
    /**
     * Choose, which Items to update.
     */
    where: ItemsWhereUniqueInput
  }

  /**
   * Items updateMany
   */
  export type ItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemsWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Items updateManyAndReturn
   */
  export type ItemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemsWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Items upsert
   */
  export type ItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the Items to update in case it exists.
     */
    where: ItemsWhereUniqueInput
    /**
     * In case the Items found by the `where` argument doesn't exist, create a new Items with this data.
     */
    create: XOR<ItemsCreateInput, ItemsUncheckedCreateInput>
    /**
     * In case the Items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemsUpdateInput, ItemsUncheckedUpdateInput>
  }

  /**
   * Items delete
   */
  export type ItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter which Items to delete.
     */
    where: ItemsWhereUniqueInput
  }

  /**
   * Items deleteMany
   */
  export type ItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemsWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Items.order
   */
  export type Items$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Orders
     */
    omit?: OrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * Items.fabric
   */
  export type Items$fabricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    where?: FabricWhereInput
  }

  /**
   * Items.lining_fabric
   */
  export type Items$lining_fabricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fabric
     */
    select?: FabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fabric
     */
    omit?: FabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricInclude<ExtArgs> | null
    where?: FabricWhereInput
  }

  /**
   * Items.jacket_measurement
   */
  export type Items$jacket_measurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JacketMeasurement
     */
    select?: JacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JacketMeasurement
     */
    omit?: JacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JacketMeasurementInclude<ExtArgs> | null
    where?: JacketMeasurementWhereInput
  }

  /**
   * Items.shirt_measurement
   */
  export type Items$shirt_measurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShirtMeasurement
     */
    select?: ShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShirtMeasurement
     */
    omit?: ShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShirtMeasurementInclude<ExtArgs> | null
    where?: ShirtMeasurementWhereInput
  }

  /**
   * Items.pant_measurement
   */
  export type Items$pant_measurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PantMeasurement
     */
    select?: PantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PantMeasurement
     */
    omit?: PantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PantMeasurementInclude<ExtArgs> | null
    where?: PantMeasurementWhereInput
  }

  /**
   * Items.final_jacket_measurement
   */
  export type Items$final_jacket_measurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalJacketMeasurement
     */
    select?: FinalJacketMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalJacketMeasurement
     */
    omit?: FinalJacketMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalJacketMeasurementInclude<ExtArgs> | null
    where?: FinalJacketMeasurementWhereInput
  }

  /**
   * Items.final_shirt_measurement
   */
  export type Items$final_shirt_measurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalShirtMeasurement
     */
    select?: FinalShirtMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalShirtMeasurement
     */
    omit?: FinalShirtMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalShirtMeasurementInclude<ExtArgs> | null
    where?: FinalShirtMeasurementWhereInput
  }

  /**
   * Items.final_pant_measurement
   */
  export type Items$final_pant_measurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalPantMeasurement
     */
    select?: FinalPantMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalPantMeasurement
     */
    omit?: FinalPantMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalPantMeasurementInclude<ExtArgs> | null
    where?: FinalPantMeasurementWhereInput
  }

  /**
   * Items without action
   */
  export type ItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Items
     */
    omit?: ItemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemsInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    supplier_id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    supplier_id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    supplier_id: number | null
    supplier_name: string | null
    add1: string | null
    add2: string | null
    add3: string | null
    phone_number1: string | null
    phone_number2: string | null
    phone_number3: string | null
    email: string | null
    primary_contact_name1: string | null
    primary_contact_name2: string | null
    primary_contact_name3: string | null
    notes: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    supplier_id: number | null
    supplier_name: string | null
    add1: string | null
    add2: string | null
    add3: string | null
    phone_number1: string | null
    phone_number2: string | null
    phone_number3: string | null
    email: string | null
    primary_contact_name1: string | null
    primary_contact_name2: string | null
    primary_contact_name3: string | null
    notes: string | null
  }

  export type SupplierCountAggregateOutputType = {
    supplier_id: number
    supplier_name: number
    add1: number
    add2: number
    add3: number
    phone_number1: number
    phone_number2: number
    phone_number3: number
    email: number
    primary_contact_name1: number
    primary_contact_name2: number
    primary_contact_name3: number
    notes: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    supplier_id?: true
  }

  export type SupplierSumAggregateInputType = {
    supplier_id?: true
  }

  export type SupplierMinAggregateInputType = {
    supplier_id?: true
    supplier_name?: true
    add1?: true
    add2?: true
    add3?: true
    phone_number1?: true
    phone_number2?: true
    phone_number3?: true
    email?: true
    primary_contact_name1?: true
    primary_contact_name2?: true
    primary_contact_name3?: true
    notes?: true
  }

  export type SupplierMaxAggregateInputType = {
    supplier_id?: true
    supplier_name?: true
    add1?: true
    add2?: true
    add3?: true
    phone_number1?: true
    phone_number2?: true
    phone_number3?: true
    email?: true
    primary_contact_name1?: true
    primary_contact_name2?: true
    primary_contact_name3?: true
    notes?: true
  }

  export type SupplierCountAggregateInputType = {
    supplier_id?: true
    supplier_name?: true
    add1?: true
    add2?: true
    add3?: true
    phone_number1?: true
    phone_number2?: true
    phone_number3?: true
    email?: true
    primary_contact_name1?: true
    primary_contact_name2?: true
    primary_contact_name3?: true
    notes?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    supplier_id: number
    supplier_name: string
    add1: string | null
    add2: string | null
    add3: string | null
    phone_number1: string | null
    phone_number2: string | null
    phone_number3: string | null
    email: string | null
    primary_contact_name1: string | null
    primary_contact_name2: string | null
    primary_contact_name3: string | null
    notes: string | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplier_id?: boolean
    supplier_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    phone_number1?: boolean
    phone_number2?: boolean
    phone_number3?: boolean
    email?: boolean
    primary_contact_name1?: boolean
    primary_contact_name2?: boolean
    primary_contact_name3?: boolean
    notes?: boolean
    FabricOrderList?: boolean | Supplier$FabricOrderListArgs<ExtArgs>
    RawMaterialsOrderList?: boolean | Supplier$RawMaterialsOrderListArgs<ExtArgs>
    ItemSupplier?: boolean | Supplier$ItemSupplierArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplier_id?: boolean
    supplier_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    phone_number1?: boolean
    phone_number2?: boolean
    phone_number3?: boolean
    email?: boolean
    primary_contact_name1?: boolean
    primary_contact_name2?: boolean
    primary_contact_name3?: boolean
    notes?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplier_id?: boolean
    supplier_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    phone_number1?: boolean
    phone_number2?: boolean
    phone_number3?: boolean
    email?: boolean
    primary_contact_name1?: boolean
    primary_contact_name2?: boolean
    primary_contact_name3?: boolean
    notes?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    supplier_id?: boolean
    supplier_name?: boolean
    add1?: boolean
    add2?: boolean
    add3?: boolean
    phone_number1?: boolean
    phone_number2?: boolean
    phone_number3?: boolean
    email?: boolean
    primary_contact_name1?: boolean
    primary_contact_name2?: boolean
    primary_contact_name3?: boolean
    notes?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"supplier_id" | "supplier_name" | "add1" | "add2" | "add3" | "phone_number1" | "phone_number2" | "phone_number3" | "email" | "primary_contact_name1" | "primary_contact_name2" | "primary_contact_name3" | "notes", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FabricOrderList?: boolean | Supplier$FabricOrderListArgs<ExtArgs>
    RawMaterialsOrderList?: boolean | Supplier$RawMaterialsOrderListArgs<ExtArgs>
    ItemSupplier?: boolean | Supplier$ItemSupplierArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      FabricOrderList: Prisma.$FabricOrderListPayload<ExtArgs>[]
      RawMaterialsOrderList: Prisma.$RawMaterialsOrderListPayload<ExtArgs>[]
      ItemSupplier: Prisma.$ItemSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      supplier_id: number
      supplier_name: string
      add1: string | null
      add2: string | null
      add3: string | null
      phone_number1: string | null
      phone_number2: string | null
      phone_number3: string | null
      email: string | null
      primary_contact_name1: string | null
      primary_contact_name2: string | null
      primary_contact_name3: string | null
      notes: string | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `supplier_id`
     * const supplierWithSupplier_idOnly = await prisma.supplier.findMany({ select: { supplier_id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `supplier_id`
     * const supplierWithSupplier_idOnly = await prisma.supplier.createManyAndReturn({
     *   select: { supplier_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `supplier_id`
     * const supplierWithSupplier_idOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { supplier_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FabricOrderList<T extends Supplier$FabricOrderListArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$FabricOrderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FabricOrderListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RawMaterialsOrderList<T extends Supplier$RawMaterialsOrderListArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$RawMaterialsOrderListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ItemSupplier<T extends Supplier$ItemSupplierArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$ItemSupplierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly supplier_id: FieldRef<"Supplier", 'Int'>
    readonly supplier_name: FieldRef<"Supplier", 'String'>
    readonly add1: FieldRef<"Supplier", 'String'>
    readonly add2: FieldRef<"Supplier", 'String'>
    readonly add3: FieldRef<"Supplier", 'String'>
    readonly phone_number1: FieldRef<"Supplier", 'String'>
    readonly phone_number2: FieldRef<"Supplier", 'String'>
    readonly phone_number3: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly primary_contact_name1: FieldRef<"Supplier", 'String'>
    readonly primary_contact_name2: FieldRef<"Supplier", 'String'>
    readonly primary_contact_name3: FieldRef<"Supplier", 'String'>
    readonly notes: FieldRef<"Supplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.FabricOrderList
   */
  export type Supplier$FabricOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FabricOrderList
     */
    select?: FabricOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FabricOrderList
     */
    omit?: FabricOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FabricOrderListInclude<ExtArgs> | null
    where?: FabricOrderListWhereInput
    orderBy?: FabricOrderListOrderByWithRelationInput | FabricOrderListOrderByWithRelationInput[]
    cursor?: FabricOrderListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FabricOrderListScalarFieldEnum | FabricOrderListScalarFieldEnum[]
  }

  /**
   * Supplier.RawMaterialsOrderList
   */
  export type Supplier$RawMaterialsOrderListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    where?: RawMaterialsOrderListWhereInput
    orderBy?: RawMaterialsOrderListOrderByWithRelationInput | RawMaterialsOrderListOrderByWithRelationInput[]
    cursor?: RawMaterialsOrderListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RawMaterialsOrderListScalarFieldEnum | RawMaterialsOrderListScalarFieldEnum[]
  }

  /**
   * Supplier.ItemSupplier
   */
  export type Supplier$ItemSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemSupplier
     */
    select?: ItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemSupplier
     */
    omit?: ItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemSupplierInclude<ExtArgs> | null
    where?: ItemSupplierWhereInput
    orderBy?: ItemSupplierOrderByWithRelationInput | ItemSupplierOrderByWithRelationInput[]
    cursor?: ItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemSupplierScalarFieldEnum | ItemSupplierScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Tailor
   */

  export type AggregateTailor = {
    _count: TailorCountAggregateOutputType | null
    _avg: TailorAvgAggregateOutputType | null
    _sum: TailorSumAggregateOutputType | null
    _min: TailorMinAggregateOutputType | null
    _max: TailorMaxAggregateOutputType | null
  }

  export type TailorAvgAggregateOutputType = {
    tailor_id: number | null
    experience_years: number | null
    hourly_rate: Decimal | null
  }

  export type TailorSumAggregateOutputType = {
    tailor_id: number | null
    experience_years: number | null
    hourly_rate: Decimal | null
  }

  export type TailorMinAggregateOutputType = {
    tailor_id: number | null
    first_name: string | null
    last_name: string | null
    specialization: string | null
    experience_years: number | null
    joining_date: Date | null
    address: string | null
    phone_number: string | null
    email: string | null
    emergency_contact: string | null
    status: string | null
    hourly_rate: Decimal | null
    notes: string | null
  }

  export type TailorMaxAggregateOutputType = {
    tailor_id: number | null
    first_name: string | null
    last_name: string | null
    specialization: string | null
    experience_years: number | null
    joining_date: Date | null
    address: string | null
    phone_number: string | null
    email: string | null
    emergency_contact: string | null
    status: string | null
    hourly_rate: Decimal | null
    notes: string | null
  }

  export type TailorCountAggregateOutputType = {
    tailor_id: number
    first_name: number
    last_name: number
    specialization: number
    experience_years: number
    joining_date: number
    address: number
    phone_number: number
    email: number
    emergency_contact: number
    status: number
    hourly_rate: number
    notes: number
    _all: number
  }


  export type TailorAvgAggregateInputType = {
    tailor_id?: true
    experience_years?: true
    hourly_rate?: true
  }

  export type TailorSumAggregateInputType = {
    tailor_id?: true
    experience_years?: true
    hourly_rate?: true
  }

  export type TailorMinAggregateInputType = {
    tailor_id?: true
    first_name?: true
    last_name?: true
    specialization?: true
    experience_years?: true
    joining_date?: true
    address?: true
    phone_number?: true
    email?: true
    emergency_contact?: true
    status?: true
    hourly_rate?: true
    notes?: true
  }

  export type TailorMaxAggregateInputType = {
    tailor_id?: true
    first_name?: true
    last_name?: true
    specialization?: true
    experience_years?: true
    joining_date?: true
    address?: true
    phone_number?: true
    email?: true
    emergency_contact?: true
    status?: true
    hourly_rate?: true
    notes?: true
  }

  export type TailorCountAggregateInputType = {
    tailor_id?: true
    first_name?: true
    last_name?: true
    specialization?: true
    experience_years?: true
    joining_date?: true
    address?: true
    phone_number?: true
    email?: true
    emergency_contact?: true
    status?: true
    hourly_rate?: true
    notes?: true
    _all?: true
  }

  export type TailorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tailor to aggregate.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tailors
    **/
    _count?: true | TailorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailorMaxAggregateInputType
  }

  export type GetTailorAggregateType<T extends TailorAggregateArgs> = {
        [P in keyof T & keyof AggregateTailor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailor[P]>
      : GetScalarType<T[P], AggregateTailor[P]>
  }




  export type TailorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailorWhereInput
    orderBy?: TailorOrderByWithAggregationInput | TailorOrderByWithAggregationInput[]
    by: TailorScalarFieldEnum[] | TailorScalarFieldEnum
    having?: TailorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailorCountAggregateInputType | true
    _avg?: TailorAvgAggregateInputType
    _sum?: TailorSumAggregateInputType
    _min?: TailorMinAggregateInputType
    _max?: TailorMaxAggregateInputType
  }

  export type TailorGroupByOutputType = {
    tailor_id: number
    first_name: string
    last_name: string | null
    specialization: string | null
    experience_years: number | null
    joining_date: Date
    address: string | null
    phone_number: string | null
    email: string | null
    emergency_contact: string | null
    status: string
    hourly_rate: Decimal | null
    notes: string | null
    _count: TailorCountAggregateOutputType | null
    _avg: TailorAvgAggregateOutputType | null
    _sum: TailorSumAggregateOutputType | null
    _min: TailorMinAggregateOutputType | null
    _max: TailorMaxAggregateOutputType | null
  }

  type GetTailorGroupByPayload<T extends TailorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailorGroupByOutputType[P]>
            : GetScalarType<T[P], TailorGroupByOutputType[P]>
        }
      >
    >


  export type TailorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tailor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialization?: boolean
    experience_years?: boolean
    joining_date?: boolean
    address?: boolean
    phone_number?: boolean
    email?: boolean
    emergency_contact?: boolean
    status?: boolean
    hourly_rate?: boolean
    notes?: boolean
    orders?: boolean | Tailor$ordersArgs<ExtArgs>
    _count?: boolean | TailorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailor"]>

  export type TailorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tailor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialization?: boolean
    experience_years?: boolean
    joining_date?: boolean
    address?: boolean
    phone_number?: boolean
    email?: boolean
    emergency_contact?: boolean
    status?: boolean
    hourly_rate?: boolean
    notes?: boolean
  }, ExtArgs["result"]["tailor"]>

  export type TailorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tailor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialization?: boolean
    experience_years?: boolean
    joining_date?: boolean
    address?: boolean
    phone_number?: boolean
    email?: boolean
    emergency_contact?: boolean
    status?: boolean
    hourly_rate?: boolean
    notes?: boolean
  }, ExtArgs["result"]["tailor"]>

  export type TailorSelectScalar = {
    tailor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialization?: boolean
    experience_years?: boolean
    joining_date?: boolean
    address?: boolean
    phone_number?: boolean
    email?: boolean
    emergency_contact?: boolean
    status?: boolean
    hourly_rate?: boolean
    notes?: boolean
  }

  export type TailorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tailor_id" | "first_name" | "last_name" | "specialization" | "experience_years" | "joining_date" | "address" | "phone_number" | "email" | "emergency_contact" | "status" | "hourly_rate" | "notes", ExtArgs["result"]["tailor"]>
  export type TailorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Tailor$ordersArgs<ExtArgs>
    _count?: boolean | TailorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TailorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TailorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TailorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tailor"
    objects: {
      orders: Prisma.$OrderTailorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tailor_id: number
      first_name: string
      last_name: string | null
      specialization: string | null
      experience_years: number | null
      joining_date: Date
      address: string | null
      phone_number: string | null
      email: string | null
      emergency_contact: string | null
      status: string
      hourly_rate: Prisma.Decimal | null
      notes: string | null
    }, ExtArgs["result"]["tailor"]>
    composites: {}
  }

  type TailorGetPayload<S extends boolean | null | undefined | TailorDefaultArgs> = $Result.GetResult<Prisma.$TailorPayload, S>

  type TailorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TailorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TailorCountAggregateInputType | true
    }

  export interface TailorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tailor'], meta: { name: 'Tailor' } }
    /**
     * Find zero or one Tailor that matches the filter.
     * @param {TailorFindUniqueArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailorFindUniqueArgs>(args: SelectSubset<T, TailorFindUniqueArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tailor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TailorFindUniqueOrThrowArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailorFindUniqueOrThrowArgs>(args: SelectSubset<T, TailorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tailor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorFindFirstArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailorFindFirstArgs>(args?: SelectSubset<T, TailorFindFirstArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tailor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorFindFirstOrThrowArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailorFindFirstOrThrowArgs>(args?: SelectSubset<T, TailorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tailors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tailors
     * const tailors = await prisma.tailor.findMany()
     * 
     * // Get first 10 Tailors
     * const tailors = await prisma.tailor.findMany({ take: 10 })
     * 
     * // Only select the `tailor_id`
     * const tailorWithTailor_idOnly = await prisma.tailor.findMany({ select: { tailor_id: true } })
     * 
     */
    findMany<T extends TailorFindManyArgs>(args?: SelectSubset<T, TailorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tailor.
     * @param {TailorCreateArgs} args - Arguments to create a Tailor.
     * @example
     * // Create one Tailor
     * const Tailor = await prisma.tailor.create({
     *   data: {
     *     // ... data to create a Tailor
     *   }
     * })
     * 
     */
    create<T extends TailorCreateArgs>(args: SelectSubset<T, TailorCreateArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tailors.
     * @param {TailorCreateManyArgs} args - Arguments to create many Tailors.
     * @example
     * // Create many Tailors
     * const tailor = await prisma.tailor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailorCreateManyArgs>(args?: SelectSubset<T, TailorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tailors and returns the data saved in the database.
     * @param {TailorCreateManyAndReturnArgs} args - Arguments to create many Tailors.
     * @example
     * // Create many Tailors
     * const tailor = await prisma.tailor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tailors and only return the `tailor_id`
     * const tailorWithTailor_idOnly = await prisma.tailor.createManyAndReturn({
     *   select: { tailor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailorCreateManyAndReturnArgs>(args?: SelectSubset<T, TailorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tailor.
     * @param {TailorDeleteArgs} args - Arguments to delete one Tailor.
     * @example
     * // Delete one Tailor
     * const Tailor = await prisma.tailor.delete({
     *   where: {
     *     // ... filter to delete one Tailor
     *   }
     * })
     * 
     */
    delete<T extends TailorDeleteArgs>(args: SelectSubset<T, TailorDeleteArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tailor.
     * @param {TailorUpdateArgs} args - Arguments to update one Tailor.
     * @example
     * // Update one Tailor
     * const tailor = await prisma.tailor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailorUpdateArgs>(args: SelectSubset<T, TailorUpdateArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tailors.
     * @param {TailorDeleteManyArgs} args - Arguments to filter Tailors to delete.
     * @example
     * // Delete a few Tailors
     * const { count } = await prisma.tailor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailorDeleteManyArgs>(args?: SelectSubset<T, TailorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tailors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tailors
     * const tailor = await prisma.tailor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailorUpdateManyArgs>(args: SelectSubset<T, TailorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tailors and returns the data updated in the database.
     * @param {TailorUpdateManyAndReturnArgs} args - Arguments to update many Tailors.
     * @example
     * // Update many Tailors
     * const tailor = await prisma.tailor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tailors and only return the `tailor_id`
     * const tailorWithTailor_idOnly = await prisma.tailor.updateManyAndReturn({
     *   select: { tailor_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TailorUpdateManyAndReturnArgs>(args: SelectSubset<T, TailorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tailor.
     * @param {TailorUpsertArgs} args - Arguments to update or create a Tailor.
     * @example
     * // Update or create a Tailor
     * const tailor = await prisma.tailor.upsert({
     *   create: {
     *     // ... data to create a Tailor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tailor we want to update
     *   }
     * })
     */
    upsert<T extends TailorUpsertArgs>(args: SelectSubset<T, TailorUpsertArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tailors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorCountArgs} args - Arguments to filter Tailors to count.
     * @example
     * // Count the number of Tailors
     * const count = await prisma.tailor.count({
     *   where: {
     *     // ... the filter for the Tailors we want to count
     *   }
     * })
    **/
    count<T extends TailorCountArgs>(
      args?: Subset<T, TailorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tailor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailorAggregateArgs>(args: Subset<T, TailorAggregateArgs>): Prisma.PrismaPromise<GetTailorAggregateType<T>>

    /**
     * Group by Tailor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailorGroupByArgs['orderBy'] }
        : { orderBy?: TailorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tailor model
   */
  readonly fields: TailorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tailor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Tailor$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Tailor$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tailor model
   */
  interface TailorFieldRefs {
    readonly tailor_id: FieldRef<"Tailor", 'Int'>
    readonly first_name: FieldRef<"Tailor", 'String'>
    readonly last_name: FieldRef<"Tailor", 'String'>
    readonly specialization: FieldRef<"Tailor", 'String'>
    readonly experience_years: FieldRef<"Tailor", 'Int'>
    readonly joining_date: FieldRef<"Tailor", 'DateTime'>
    readonly address: FieldRef<"Tailor", 'String'>
    readonly phone_number: FieldRef<"Tailor", 'String'>
    readonly email: FieldRef<"Tailor", 'String'>
    readonly emergency_contact: FieldRef<"Tailor", 'String'>
    readonly status: FieldRef<"Tailor", 'String'>
    readonly hourly_rate: FieldRef<"Tailor", 'Decimal'>
    readonly notes: FieldRef<"Tailor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tailor findUnique
   */
  export type TailorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor findUniqueOrThrow
   */
  export type TailorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor findFirst
   */
  export type TailorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tailors.
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tailors.
     */
    distinct?: TailorScalarFieldEnum | TailorScalarFieldEnum[]
  }

  /**
   * Tailor findFirstOrThrow
   */
  export type TailorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tailors.
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tailors.
     */
    distinct?: TailorScalarFieldEnum | TailorScalarFieldEnum[]
  }

  /**
   * Tailor findMany
   */
  export type TailorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailors to fetch.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tailors.
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    distinct?: TailorScalarFieldEnum | TailorScalarFieldEnum[]
  }

  /**
   * Tailor create
   */
  export type TailorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * The data needed to create a Tailor.
     */
    data: XOR<TailorCreateInput, TailorUncheckedCreateInput>
  }

  /**
   * Tailor createMany
   */
  export type TailorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tailors.
     */
    data: TailorCreateManyInput | TailorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tailor createManyAndReturn
   */
  export type TailorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * The data used to create many Tailors.
     */
    data: TailorCreateManyInput | TailorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tailor update
   */
  export type TailorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * The data needed to update a Tailor.
     */
    data: XOR<TailorUpdateInput, TailorUncheckedUpdateInput>
    /**
     * Choose, which Tailor to update.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor updateMany
   */
  export type TailorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tailors.
     */
    data: XOR<TailorUpdateManyMutationInput, TailorUncheckedUpdateManyInput>
    /**
     * Filter which Tailors to update
     */
    where?: TailorWhereInput
    /**
     * Limit how many Tailors to update.
     */
    limit?: number
  }

  /**
   * Tailor updateManyAndReturn
   */
  export type TailorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * The data used to update Tailors.
     */
    data: XOR<TailorUpdateManyMutationInput, TailorUncheckedUpdateManyInput>
    /**
     * Filter which Tailors to update
     */
    where?: TailorWhereInput
    /**
     * Limit how many Tailors to update.
     */
    limit?: number
  }

  /**
   * Tailor upsert
   */
  export type TailorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * The filter to search for the Tailor to update in case it exists.
     */
    where: TailorWhereUniqueInput
    /**
     * In case the Tailor found by the `where` argument doesn't exist, create a new Tailor with this data.
     */
    create: XOR<TailorCreateInput, TailorUncheckedCreateInput>
    /**
     * In case the Tailor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailorUpdateInput, TailorUncheckedUpdateInput>
  }

  /**
   * Tailor delete
   */
  export type TailorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter which Tailor to delete.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor deleteMany
   */
  export type TailorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tailors to delete
     */
    where?: TailorWhereInput
    /**
     * Limit how many Tailors to delete.
     */
    limit?: number
  }

  /**
   * Tailor.orders
   */
  export type Tailor$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    where?: OrderTailorWhereInput
    orderBy?: OrderTailorOrderByWithRelationInput | OrderTailorOrderByWithRelationInput[]
    cursor?: OrderTailorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTailorScalarFieldEnum | OrderTailorScalarFieldEnum[]
  }

  /**
   * Tailor without action
   */
  export type TailorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tailor
     */
    omit?: TailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
  }


  /**
   * Model OrderTailor
   */

  export type AggregateOrderTailor = {
    _count: OrderTailorCountAggregateOutputType | null
    _avg: OrderTailorAvgAggregateOutputType | null
    _sum: OrderTailorSumAggregateOutputType | null
    _min: OrderTailorMinAggregateOutputType | null
    _max: OrderTailorMaxAggregateOutputType | null
  }

  export type OrderTailorAvgAggregateOutputType = {
    id: number | null
    tailor_id: number | null
  }

  export type OrderTailorSumAggregateOutputType = {
    id: number | null
    tailor_id: number | null
  }

  export type OrderTailorMinAggregateOutputType = {
    id: number | null
    orderNo: string | null
    tailor_id: number | null
    assigned_at: Date | null
    status: string | null
    due_date: Date | null
    notes: string | null
  }

  export type OrderTailorMaxAggregateOutputType = {
    id: number | null
    orderNo: string | null
    tailor_id: number | null
    assigned_at: Date | null
    status: string | null
    due_date: Date | null
    notes: string | null
  }

  export type OrderTailorCountAggregateOutputType = {
    id: number
    orderNo: number
    tailor_id: number
    assigned_at: number
    status: number
    due_date: number
    notes: number
    _all: number
  }


  export type OrderTailorAvgAggregateInputType = {
    id?: true
    tailor_id?: true
  }

  export type OrderTailorSumAggregateInputType = {
    id?: true
    tailor_id?: true
  }

  export type OrderTailorMinAggregateInputType = {
    id?: true
    orderNo?: true
    tailor_id?: true
    assigned_at?: true
    status?: true
    due_date?: true
    notes?: true
  }

  export type OrderTailorMaxAggregateInputType = {
    id?: true
    orderNo?: true
    tailor_id?: true
    assigned_at?: true
    status?: true
    due_date?: true
    notes?: true
  }

  export type OrderTailorCountAggregateInputType = {
    id?: true
    orderNo?: true
    tailor_id?: true
    assigned_at?: true
    status?: true
    due_date?: true
    notes?: true
    _all?: true
  }

  export type OrderTailorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderTailor to aggregate.
     */
    where?: OrderTailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTailors to fetch.
     */
    orderBy?: OrderTailorOrderByWithRelationInput | OrderTailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderTailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderTailors
    **/
    _count?: true | OrderTailorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderTailorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderTailorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderTailorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderTailorMaxAggregateInputType
  }

  export type GetOrderTailorAggregateType<T extends OrderTailorAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderTailor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderTailor[P]>
      : GetScalarType<T[P], AggregateOrderTailor[P]>
  }




  export type OrderTailorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTailorWhereInput
    orderBy?: OrderTailorOrderByWithAggregationInput | OrderTailorOrderByWithAggregationInput[]
    by: OrderTailorScalarFieldEnum[] | OrderTailorScalarFieldEnum
    having?: OrderTailorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderTailorCountAggregateInputType | true
    _avg?: OrderTailorAvgAggregateInputType
    _sum?: OrderTailorSumAggregateInputType
    _min?: OrderTailorMinAggregateInputType
    _max?: OrderTailorMaxAggregateInputType
  }

  export type OrderTailorGroupByOutputType = {
    id: number
    orderNo: string
    tailor_id: number
    assigned_at: Date
    status: string
    due_date: Date | null
    notes: string | null
    _count: OrderTailorCountAggregateOutputType | null
    _avg: OrderTailorAvgAggregateOutputType | null
    _sum: OrderTailorSumAggregateOutputType | null
    _min: OrderTailorMinAggregateOutputType | null
    _max: OrderTailorMaxAggregateOutputType | null
  }

  type GetOrderTailorGroupByPayload<T extends OrderTailorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderTailorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderTailorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderTailorGroupByOutputType[P]>
            : GetScalarType<T[P], OrderTailorGroupByOutputType[P]>
        }
      >
    >


  export type OrderTailorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    tailor_id?: boolean
    assigned_at?: boolean
    status?: boolean
    due_date?: boolean
    notes?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderTailor"]>

  export type OrderTailorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    tailor_id?: boolean
    assigned_at?: boolean
    status?: boolean
    due_date?: boolean
    notes?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderTailor"]>

  export type OrderTailorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    tailor_id?: boolean
    assigned_at?: boolean
    status?: boolean
    due_date?: boolean
    notes?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderTailor"]>

  export type OrderTailorSelectScalar = {
    id?: boolean
    orderNo?: boolean
    tailor_id?: boolean
    assigned_at?: boolean
    status?: boolean
    due_date?: boolean
    notes?: boolean
  }

  export type OrderTailorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNo" | "tailor_id" | "assigned_at" | "status" | "due_date" | "notes", ExtArgs["result"]["orderTailor"]>
  export type OrderTailorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }
  export type OrderTailorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }
  export type OrderTailorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }

  export type $OrderTailorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderTailor"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
      tailor: Prisma.$TailorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNo: string
      tailor_id: number
      assigned_at: Date
      status: string
      due_date: Date | null
      notes: string | null
    }, ExtArgs["result"]["orderTailor"]>
    composites: {}
  }

  type OrderTailorGetPayload<S extends boolean | null | undefined | OrderTailorDefaultArgs> = $Result.GetResult<Prisma.$OrderTailorPayload, S>

  type OrderTailorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderTailorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderTailorCountAggregateInputType | true
    }

  export interface OrderTailorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderTailor'], meta: { name: 'OrderTailor' } }
    /**
     * Find zero or one OrderTailor that matches the filter.
     * @param {OrderTailorFindUniqueArgs} args - Arguments to find a OrderTailor
     * @example
     * // Get one OrderTailor
     * const orderTailor = await prisma.orderTailor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderTailorFindUniqueArgs>(args: SelectSubset<T, OrderTailorFindUniqueArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderTailor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderTailorFindUniqueOrThrowArgs} args - Arguments to find a OrderTailor
     * @example
     * // Get one OrderTailor
     * const orderTailor = await prisma.orderTailor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderTailorFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderTailorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderTailor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorFindFirstArgs} args - Arguments to find a OrderTailor
     * @example
     * // Get one OrderTailor
     * const orderTailor = await prisma.orderTailor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderTailorFindFirstArgs>(args?: SelectSubset<T, OrderTailorFindFirstArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderTailor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorFindFirstOrThrowArgs} args - Arguments to find a OrderTailor
     * @example
     * // Get one OrderTailor
     * const orderTailor = await prisma.orderTailor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderTailorFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderTailorFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderTailors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderTailors
     * const orderTailors = await prisma.orderTailor.findMany()
     * 
     * // Get first 10 OrderTailors
     * const orderTailors = await prisma.orderTailor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderTailorWithIdOnly = await prisma.orderTailor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderTailorFindManyArgs>(args?: SelectSubset<T, OrderTailorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderTailor.
     * @param {OrderTailorCreateArgs} args - Arguments to create a OrderTailor.
     * @example
     * // Create one OrderTailor
     * const OrderTailor = await prisma.orderTailor.create({
     *   data: {
     *     // ... data to create a OrderTailor
     *   }
     * })
     * 
     */
    create<T extends OrderTailorCreateArgs>(args: SelectSubset<T, OrderTailorCreateArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderTailors.
     * @param {OrderTailorCreateManyArgs} args - Arguments to create many OrderTailors.
     * @example
     * // Create many OrderTailors
     * const orderTailor = await prisma.orderTailor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderTailorCreateManyArgs>(args?: SelectSubset<T, OrderTailorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderTailors and returns the data saved in the database.
     * @param {OrderTailorCreateManyAndReturnArgs} args - Arguments to create many OrderTailors.
     * @example
     * // Create many OrderTailors
     * const orderTailor = await prisma.orderTailor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderTailors and only return the `id`
     * const orderTailorWithIdOnly = await prisma.orderTailor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderTailorCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderTailorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderTailor.
     * @param {OrderTailorDeleteArgs} args - Arguments to delete one OrderTailor.
     * @example
     * // Delete one OrderTailor
     * const OrderTailor = await prisma.orderTailor.delete({
     *   where: {
     *     // ... filter to delete one OrderTailor
     *   }
     * })
     * 
     */
    delete<T extends OrderTailorDeleteArgs>(args: SelectSubset<T, OrderTailorDeleteArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderTailor.
     * @param {OrderTailorUpdateArgs} args - Arguments to update one OrderTailor.
     * @example
     * // Update one OrderTailor
     * const orderTailor = await prisma.orderTailor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderTailorUpdateArgs>(args: SelectSubset<T, OrderTailorUpdateArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderTailors.
     * @param {OrderTailorDeleteManyArgs} args - Arguments to filter OrderTailors to delete.
     * @example
     * // Delete a few OrderTailors
     * const { count } = await prisma.orderTailor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderTailorDeleteManyArgs>(args?: SelectSubset<T, OrderTailorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTailors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderTailors
     * const orderTailor = await prisma.orderTailor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderTailorUpdateManyArgs>(args: SelectSubset<T, OrderTailorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTailors and returns the data updated in the database.
     * @param {OrderTailorUpdateManyAndReturnArgs} args - Arguments to update many OrderTailors.
     * @example
     * // Update many OrderTailors
     * const orderTailor = await prisma.orderTailor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderTailors and only return the `id`
     * const orderTailorWithIdOnly = await prisma.orderTailor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderTailorUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderTailorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderTailor.
     * @param {OrderTailorUpsertArgs} args - Arguments to update or create a OrderTailor.
     * @example
     * // Update or create a OrderTailor
     * const orderTailor = await prisma.orderTailor.upsert({
     *   create: {
     *     // ... data to create a OrderTailor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderTailor we want to update
     *   }
     * })
     */
    upsert<T extends OrderTailorUpsertArgs>(args: SelectSubset<T, OrderTailorUpsertArgs<ExtArgs>>): Prisma__OrderTailorClient<$Result.GetResult<Prisma.$OrderTailorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderTailors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorCountArgs} args - Arguments to filter OrderTailors to count.
     * @example
     * // Count the number of OrderTailors
     * const count = await prisma.orderTailor.count({
     *   where: {
     *     // ... the filter for the OrderTailors we want to count
     *   }
     * })
    **/
    count<T extends OrderTailorCountArgs>(
      args?: Subset<T, OrderTailorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderTailorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderTailor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderTailorAggregateArgs>(args: Subset<T, OrderTailorAggregateArgs>): Prisma.PrismaPromise<GetOrderTailorAggregateType<T>>

    /**
     * Group by OrderTailor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTailorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderTailorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderTailorGroupByArgs['orderBy'] }
        : { orderBy?: OrderTailorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderTailorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderTailorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderTailor model
   */
  readonly fields: OrderTailorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderTailor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderTailorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tailor<T extends TailorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TailorDefaultArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderTailor model
   */
  interface OrderTailorFieldRefs {
    readonly id: FieldRef<"OrderTailor", 'Int'>
    readonly orderNo: FieldRef<"OrderTailor", 'String'>
    readonly tailor_id: FieldRef<"OrderTailor", 'Int'>
    readonly assigned_at: FieldRef<"OrderTailor", 'DateTime'>
    readonly status: FieldRef<"OrderTailor", 'String'>
    readonly due_date: FieldRef<"OrderTailor", 'DateTime'>
    readonly notes: FieldRef<"OrderTailor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderTailor findUnique
   */
  export type OrderTailorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * Filter, which OrderTailor to fetch.
     */
    where: OrderTailorWhereUniqueInput
  }

  /**
   * OrderTailor findUniqueOrThrow
   */
  export type OrderTailorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * Filter, which OrderTailor to fetch.
     */
    where: OrderTailorWhereUniqueInput
  }

  /**
   * OrderTailor findFirst
   */
  export type OrderTailorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * Filter, which OrderTailor to fetch.
     */
    where?: OrderTailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTailors to fetch.
     */
    orderBy?: OrderTailorOrderByWithRelationInput | OrderTailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTailors.
     */
    cursor?: OrderTailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTailors.
     */
    distinct?: OrderTailorScalarFieldEnum | OrderTailorScalarFieldEnum[]
  }

  /**
   * OrderTailor findFirstOrThrow
   */
  export type OrderTailorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * Filter, which OrderTailor to fetch.
     */
    where?: OrderTailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTailors to fetch.
     */
    orderBy?: OrderTailorOrderByWithRelationInput | OrderTailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTailors.
     */
    cursor?: OrderTailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTailors.
     */
    distinct?: OrderTailorScalarFieldEnum | OrderTailorScalarFieldEnum[]
  }

  /**
   * OrderTailor findMany
   */
  export type OrderTailorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * Filter, which OrderTailors to fetch.
     */
    where?: OrderTailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTailors to fetch.
     */
    orderBy?: OrderTailorOrderByWithRelationInput | OrderTailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderTailors.
     */
    cursor?: OrderTailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTailors.
     */
    skip?: number
    distinct?: OrderTailorScalarFieldEnum | OrderTailorScalarFieldEnum[]
  }

  /**
   * OrderTailor create
   */
  export type OrderTailorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderTailor.
     */
    data: XOR<OrderTailorCreateInput, OrderTailorUncheckedCreateInput>
  }

  /**
   * OrderTailor createMany
   */
  export type OrderTailorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderTailors.
     */
    data: OrderTailorCreateManyInput | OrderTailorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderTailor createManyAndReturn
   */
  export type OrderTailorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * The data used to create many OrderTailors.
     */
    data: OrderTailorCreateManyInput | OrderTailorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderTailor update
   */
  export type OrderTailorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderTailor.
     */
    data: XOR<OrderTailorUpdateInput, OrderTailorUncheckedUpdateInput>
    /**
     * Choose, which OrderTailor to update.
     */
    where: OrderTailorWhereUniqueInput
  }

  /**
   * OrderTailor updateMany
   */
  export type OrderTailorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderTailors.
     */
    data: XOR<OrderTailorUpdateManyMutationInput, OrderTailorUncheckedUpdateManyInput>
    /**
     * Filter which OrderTailors to update
     */
    where?: OrderTailorWhereInput
    /**
     * Limit how many OrderTailors to update.
     */
    limit?: number
  }

  /**
   * OrderTailor updateManyAndReturn
   */
  export type OrderTailorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * The data used to update OrderTailors.
     */
    data: XOR<OrderTailorUpdateManyMutationInput, OrderTailorUncheckedUpdateManyInput>
    /**
     * Filter which OrderTailors to update
     */
    where?: OrderTailorWhereInput
    /**
     * Limit how many OrderTailors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderTailor upsert
   */
  export type OrderTailorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderTailor to update in case it exists.
     */
    where: OrderTailorWhereUniqueInput
    /**
     * In case the OrderTailor found by the `where` argument doesn't exist, create a new OrderTailor with this data.
     */
    create: XOR<OrderTailorCreateInput, OrderTailorUncheckedCreateInput>
    /**
     * In case the OrderTailor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderTailorUpdateInput, OrderTailorUncheckedUpdateInput>
  }

  /**
   * OrderTailor delete
   */
  export type OrderTailorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
    /**
     * Filter which OrderTailor to delete.
     */
    where: OrderTailorWhereUniqueInput
  }

  /**
   * OrderTailor deleteMany
   */
  export type OrderTailorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderTailors to delete
     */
    where?: OrderTailorWhereInput
    /**
     * Limit how many OrderTailors to delete.
     */
    limit?: number
  }

  /**
   * OrderTailor without action
   */
  export type OrderTailorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTailor
     */
    select?: OrderTailorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTailor
     */
    omit?: OrderTailorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTailorInclude<ExtArgs> | null
  }


  /**
   * Model RawMaterialsOrderList
   */

  export type AggregateRawMaterialsOrderList = {
    _count: RawMaterialsOrderListCountAggregateOutputType | null
    _avg: RawMaterialsOrderListAvgAggregateOutputType | null
    _sum: RawMaterialsOrderListSumAggregateOutputType | null
    _min: RawMaterialsOrderListMinAggregateOutputType | null
    _max: RawMaterialsOrderListMaxAggregateOutputType | null
  }

  export type RawMaterialsOrderListAvgAggregateOutputType = {
    order_id: number | null
    quantity: Decimal | null
    supplier_id: number | null
  }

  export type RawMaterialsOrderListSumAggregateOutputType = {
    order_id: number | null
    quantity: Decimal | null
    supplier_id: number | null
  }

  export type RawMaterialsOrderListMinAggregateOutputType = {
    order_id: number | null
    product_name: string | null
    description: string | null
    raw_material_code: string | null
    color: string | null
    supplier_name: string | null
    quantity: Decimal | null
    ordered_date: Date | null
    supplier_id: number | null
  }

  export type RawMaterialsOrderListMaxAggregateOutputType = {
    order_id: number | null
    product_name: string | null
    description: string | null
    raw_material_code: string | null
    color: string | null
    supplier_name: string | null
    quantity: Decimal | null
    ordered_date: Date | null
    supplier_id: number | null
  }

  export type RawMaterialsOrderListCountAggregateOutputType = {
    order_id: number
    product_name: number
    description: number
    raw_material_code: number
    color: number
    supplier_name: number
    quantity: number
    ordered_date: number
    supplier_id: number
    _all: number
  }


  export type RawMaterialsOrderListAvgAggregateInputType = {
    order_id?: true
    quantity?: true
    supplier_id?: true
  }

  export type RawMaterialsOrderListSumAggregateInputType = {
    order_id?: true
    quantity?: true
    supplier_id?: true
  }

  export type RawMaterialsOrderListMinAggregateInputType = {
    order_id?: true
    product_name?: true
    description?: true
    raw_material_code?: true
    color?: true
    supplier_name?: true
    quantity?: true
    ordered_date?: true
    supplier_id?: true
  }

  export type RawMaterialsOrderListMaxAggregateInputType = {
    order_id?: true
    product_name?: true
    description?: true
    raw_material_code?: true
    color?: true
    supplier_name?: true
    quantity?: true
    ordered_date?: true
    supplier_id?: true
  }

  export type RawMaterialsOrderListCountAggregateInputType = {
    order_id?: true
    product_name?: true
    description?: true
    raw_material_code?: true
    color?: true
    supplier_name?: true
    quantity?: true
    ordered_date?: true
    supplier_id?: true
    _all?: true
  }

  export type RawMaterialsOrderListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawMaterialsOrderList to aggregate.
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialsOrderLists to fetch.
     */
    orderBy?: RawMaterialsOrderListOrderByWithRelationInput | RawMaterialsOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RawMaterialsOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialsOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialsOrderLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RawMaterialsOrderLists
    **/
    _count?: true | RawMaterialsOrderListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RawMaterialsOrderListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RawMaterialsOrderListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RawMaterialsOrderListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RawMaterialsOrderListMaxAggregateInputType
  }

  export type GetRawMaterialsOrderListAggregateType<T extends RawMaterialsOrderListAggregateArgs> = {
        [P in keyof T & keyof AggregateRawMaterialsOrderList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRawMaterialsOrderList[P]>
      : GetScalarType<T[P], AggregateRawMaterialsOrderList[P]>
  }




  export type RawMaterialsOrderListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RawMaterialsOrderListWhereInput
    orderBy?: RawMaterialsOrderListOrderByWithAggregationInput | RawMaterialsOrderListOrderByWithAggregationInput[]
    by: RawMaterialsOrderListScalarFieldEnum[] | RawMaterialsOrderListScalarFieldEnum
    having?: RawMaterialsOrderListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RawMaterialsOrderListCountAggregateInputType | true
    _avg?: RawMaterialsOrderListAvgAggregateInputType
    _sum?: RawMaterialsOrderListSumAggregateInputType
    _min?: RawMaterialsOrderListMinAggregateInputType
    _max?: RawMaterialsOrderListMaxAggregateInputType
  }

  export type RawMaterialsOrderListGroupByOutputType = {
    order_id: number
    product_name: string | null
    description: string | null
    raw_material_code: string | null
    color: string | null
    supplier_name: string | null
    quantity: Decimal | null
    ordered_date: Date | null
    supplier_id: number | null
    _count: RawMaterialsOrderListCountAggregateOutputType | null
    _avg: RawMaterialsOrderListAvgAggregateOutputType | null
    _sum: RawMaterialsOrderListSumAggregateOutputType | null
    _min: RawMaterialsOrderListMinAggregateOutputType | null
    _max: RawMaterialsOrderListMaxAggregateOutputType | null
  }

  type GetRawMaterialsOrderListGroupByPayload<T extends RawMaterialsOrderListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RawMaterialsOrderListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RawMaterialsOrderListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RawMaterialsOrderListGroupByOutputType[P]>
            : GetScalarType<T[P], RawMaterialsOrderListGroupByOutputType[P]>
        }
      >
    >


  export type RawMaterialsOrderListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    product_name?: boolean
    description?: boolean
    raw_material_code?: boolean
    color?: boolean
    supplier_name?: boolean
    quantity?: boolean
    ordered_date?: boolean
    supplier_id?: boolean
    supplier?: boolean | RawMaterialsOrderList$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterialsOrderList"]>

  export type RawMaterialsOrderListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    product_name?: boolean
    description?: boolean
    raw_material_code?: boolean
    color?: boolean
    supplier_name?: boolean
    quantity?: boolean
    ordered_date?: boolean
    supplier_id?: boolean
    supplier?: boolean | RawMaterialsOrderList$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterialsOrderList"]>

  export type RawMaterialsOrderListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    product_name?: boolean
    description?: boolean
    raw_material_code?: boolean
    color?: boolean
    supplier_name?: boolean
    quantity?: boolean
    ordered_date?: boolean
    supplier_id?: boolean
    supplier?: boolean | RawMaterialsOrderList$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["rawMaterialsOrderList"]>

  export type RawMaterialsOrderListSelectScalar = {
    order_id?: boolean
    product_name?: boolean
    description?: boolean
    raw_material_code?: boolean
    color?: boolean
    supplier_name?: boolean
    quantity?: boolean
    ordered_date?: boolean
    supplier_id?: boolean
  }

  export type RawMaterialsOrderListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"order_id" | "product_name" | "description" | "raw_material_code" | "color" | "supplier_name" | "quantity" | "ordered_date" | "supplier_id", ExtArgs["result"]["rawMaterialsOrderList"]>
  export type RawMaterialsOrderListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | RawMaterialsOrderList$supplierArgs<ExtArgs>
  }
  export type RawMaterialsOrderListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | RawMaterialsOrderList$supplierArgs<ExtArgs>
  }
  export type RawMaterialsOrderListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | RawMaterialsOrderList$supplierArgs<ExtArgs>
  }

  export type $RawMaterialsOrderListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RawMaterialsOrderList"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      product_name: string | null
      description: string | null
      raw_material_code: string | null
      color: string | null
      supplier_name: string | null
      quantity: Prisma.Decimal | null
      ordered_date: Date | null
      supplier_id: number | null
    }, ExtArgs["result"]["rawMaterialsOrderList"]>
    composites: {}
  }

  type RawMaterialsOrderListGetPayload<S extends boolean | null | undefined | RawMaterialsOrderListDefaultArgs> = $Result.GetResult<Prisma.$RawMaterialsOrderListPayload, S>

  type RawMaterialsOrderListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RawMaterialsOrderListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RawMaterialsOrderListCountAggregateInputType | true
    }

  export interface RawMaterialsOrderListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RawMaterialsOrderList'], meta: { name: 'RawMaterialsOrderList' } }
    /**
     * Find zero or one RawMaterialsOrderList that matches the filter.
     * @param {RawMaterialsOrderListFindUniqueArgs} args - Arguments to find a RawMaterialsOrderList
     * @example
     * // Get one RawMaterialsOrderList
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RawMaterialsOrderListFindUniqueArgs>(args: SelectSubset<T, RawMaterialsOrderListFindUniqueArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RawMaterialsOrderList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RawMaterialsOrderListFindUniqueOrThrowArgs} args - Arguments to find a RawMaterialsOrderList
     * @example
     * // Get one RawMaterialsOrderList
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RawMaterialsOrderListFindUniqueOrThrowArgs>(args: SelectSubset<T, RawMaterialsOrderListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawMaterialsOrderList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListFindFirstArgs} args - Arguments to find a RawMaterialsOrderList
     * @example
     * // Get one RawMaterialsOrderList
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RawMaterialsOrderListFindFirstArgs>(args?: SelectSubset<T, RawMaterialsOrderListFindFirstArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RawMaterialsOrderList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListFindFirstOrThrowArgs} args - Arguments to find a RawMaterialsOrderList
     * @example
     * // Get one RawMaterialsOrderList
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RawMaterialsOrderListFindFirstOrThrowArgs>(args?: SelectSubset<T, RawMaterialsOrderListFindFirstOrThrowArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RawMaterialsOrderLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RawMaterialsOrderLists
     * const rawMaterialsOrderLists = await prisma.rawMaterialsOrderList.findMany()
     * 
     * // Get first 10 RawMaterialsOrderLists
     * const rawMaterialsOrderLists = await prisma.rawMaterialsOrderList.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const rawMaterialsOrderListWithOrder_idOnly = await prisma.rawMaterialsOrderList.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends RawMaterialsOrderListFindManyArgs>(args?: SelectSubset<T, RawMaterialsOrderListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RawMaterialsOrderList.
     * @param {RawMaterialsOrderListCreateArgs} args - Arguments to create a RawMaterialsOrderList.
     * @example
     * // Create one RawMaterialsOrderList
     * const RawMaterialsOrderList = await prisma.rawMaterialsOrderList.create({
     *   data: {
     *     // ... data to create a RawMaterialsOrderList
     *   }
     * })
     * 
     */
    create<T extends RawMaterialsOrderListCreateArgs>(args: SelectSubset<T, RawMaterialsOrderListCreateArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RawMaterialsOrderLists.
     * @param {RawMaterialsOrderListCreateManyArgs} args - Arguments to create many RawMaterialsOrderLists.
     * @example
     * // Create many RawMaterialsOrderLists
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RawMaterialsOrderListCreateManyArgs>(args?: SelectSubset<T, RawMaterialsOrderListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RawMaterialsOrderLists and returns the data saved in the database.
     * @param {RawMaterialsOrderListCreateManyAndReturnArgs} args - Arguments to create many RawMaterialsOrderLists.
     * @example
     * // Create many RawMaterialsOrderLists
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RawMaterialsOrderLists and only return the `order_id`
     * const rawMaterialsOrderListWithOrder_idOnly = await prisma.rawMaterialsOrderList.createManyAndReturn({
     *   select: { order_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RawMaterialsOrderListCreateManyAndReturnArgs>(args?: SelectSubset<T, RawMaterialsOrderListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RawMaterialsOrderList.
     * @param {RawMaterialsOrderListDeleteArgs} args - Arguments to delete one RawMaterialsOrderList.
     * @example
     * // Delete one RawMaterialsOrderList
     * const RawMaterialsOrderList = await prisma.rawMaterialsOrderList.delete({
     *   where: {
     *     // ... filter to delete one RawMaterialsOrderList
     *   }
     * })
     * 
     */
    delete<T extends RawMaterialsOrderListDeleteArgs>(args: SelectSubset<T, RawMaterialsOrderListDeleteArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RawMaterialsOrderList.
     * @param {RawMaterialsOrderListUpdateArgs} args - Arguments to update one RawMaterialsOrderList.
     * @example
     * // Update one RawMaterialsOrderList
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RawMaterialsOrderListUpdateArgs>(args: SelectSubset<T, RawMaterialsOrderListUpdateArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RawMaterialsOrderLists.
     * @param {RawMaterialsOrderListDeleteManyArgs} args - Arguments to filter RawMaterialsOrderLists to delete.
     * @example
     * // Delete a few RawMaterialsOrderLists
     * const { count } = await prisma.rawMaterialsOrderList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RawMaterialsOrderListDeleteManyArgs>(args?: SelectSubset<T, RawMaterialsOrderListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawMaterialsOrderLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RawMaterialsOrderLists
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RawMaterialsOrderListUpdateManyArgs>(args: SelectSubset<T, RawMaterialsOrderListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RawMaterialsOrderLists and returns the data updated in the database.
     * @param {RawMaterialsOrderListUpdateManyAndReturnArgs} args - Arguments to update many RawMaterialsOrderLists.
     * @example
     * // Update many RawMaterialsOrderLists
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RawMaterialsOrderLists and only return the `order_id`
     * const rawMaterialsOrderListWithOrder_idOnly = await prisma.rawMaterialsOrderList.updateManyAndReturn({
     *   select: { order_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RawMaterialsOrderListUpdateManyAndReturnArgs>(args: SelectSubset<T, RawMaterialsOrderListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RawMaterialsOrderList.
     * @param {RawMaterialsOrderListUpsertArgs} args - Arguments to update or create a RawMaterialsOrderList.
     * @example
     * // Update or create a RawMaterialsOrderList
     * const rawMaterialsOrderList = await prisma.rawMaterialsOrderList.upsert({
     *   create: {
     *     // ... data to create a RawMaterialsOrderList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RawMaterialsOrderList we want to update
     *   }
     * })
     */
    upsert<T extends RawMaterialsOrderListUpsertArgs>(args: SelectSubset<T, RawMaterialsOrderListUpsertArgs<ExtArgs>>): Prisma__RawMaterialsOrderListClient<$Result.GetResult<Prisma.$RawMaterialsOrderListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RawMaterialsOrderLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListCountArgs} args - Arguments to filter RawMaterialsOrderLists to count.
     * @example
     * // Count the number of RawMaterialsOrderLists
     * const count = await prisma.rawMaterialsOrderList.count({
     *   where: {
     *     // ... the filter for the RawMaterialsOrderLists we want to count
     *   }
     * })
    **/
    count<T extends RawMaterialsOrderListCountArgs>(
      args?: Subset<T, RawMaterialsOrderListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RawMaterialsOrderListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RawMaterialsOrderList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RawMaterialsOrderListAggregateArgs>(args: Subset<T, RawMaterialsOrderListAggregateArgs>): Prisma.PrismaPromise<GetRawMaterialsOrderListAggregateType<T>>

    /**
     * Group by RawMaterialsOrderList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RawMaterialsOrderListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RawMaterialsOrderListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RawMaterialsOrderListGroupByArgs['orderBy'] }
        : { orderBy?: RawMaterialsOrderListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RawMaterialsOrderListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRawMaterialsOrderListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RawMaterialsOrderList model
   */
  readonly fields: RawMaterialsOrderListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RawMaterialsOrderList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RawMaterialsOrderListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends RawMaterialsOrderList$supplierArgs<ExtArgs> = {}>(args?: Subset<T, RawMaterialsOrderList$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RawMaterialsOrderList model
   */
  interface RawMaterialsOrderListFieldRefs {
    readonly order_id: FieldRef<"RawMaterialsOrderList", 'Int'>
    readonly product_name: FieldRef<"RawMaterialsOrderList", 'String'>
    readonly description: FieldRef<"RawMaterialsOrderList", 'String'>
    readonly raw_material_code: FieldRef<"RawMaterialsOrderList", 'String'>
    readonly color: FieldRef<"RawMaterialsOrderList", 'String'>
    readonly supplier_name: FieldRef<"RawMaterialsOrderList", 'String'>
    readonly quantity: FieldRef<"RawMaterialsOrderList", 'Decimal'>
    readonly ordered_date: FieldRef<"RawMaterialsOrderList", 'DateTime'>
    readonly supplier_id: FieldRef<"RawMaterialsOrderList", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RawMaterialsOrderList findUnique
   */
  export type RawMaterialsOrderListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialsOrderList to fetch.
     */
    where: RawMaterialsOrderListWhereUniqueInput
  }

  /**
   * RawMaterialsOrderList findUniqueOrThrow
   */
  export type RawMaterialsOrderListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialsOrderList to fetch.
     */
    where: RawMaterialsOrderListWhereUniqueInput
  }

  /**
   * RawMaterialsOrderList findFirst
   */
  export type RawMaterialsOrderListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialsOrderList to fetch.
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialsOrderLists to fetch.
     */
    orderBy?: RawMaterialsOrderListOrderByWithRelationInput | RawMaterialsOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawMaterialsOrderLists.
     */
    cursor?: RawMaterialsOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialsOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialsOrderLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawMaterialsOrderLists.
     */
    distinct?: RawMaterialsOrderListScalarFieldEnum | RawMaterialsOrderListScalarFieldEnum[]
  }

  /**
   * RawMaterialsOrderList findFirstOrThrow
   */
  export type RawMaterialsOrderListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialsOrderList to fetch.
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialsOrderLists to fetch.
     */
    orderBy?: RawMaterialsOrderListOrderByWithRelationInput | RawMaterialsOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RawMaterialsOrderLists.
     */
    cursor?: RawMaterialsOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialsOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialsOrderLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RawMaterialsOrderLists.
     */
    distinct?: RawMaterialsOrderListScalarFieldEnum | RawMaterialsOrderListScalarFieldEnum[]
  }

  /**
   * RawMaterialsOrderList findMany
   */
  export type RawMaterialsOrderListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * Filter, which RawMaterialsOrderLists to fetch.
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RawMaterialsOrderLists to fetch.
     */
    orderBy?: RawMaterialsOrderListOrderByWithRelationInput | RawMaterialsOrderListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RawMaterialsOrderLists.
     */
    cursor?: RawMaterialsOrderListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RawMaterialsOrderLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RawMaterialsOrderLists.
     */
    skip?: number
    distinct?: RawMaterialsOrderListScalarFieldEnum | RawMaterialsOrderListScalarFieldEnum[]
  }

  /**
   * RawMaterialsOrderList create
   */
  export type RawMaterialsOrderListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * The data needed to create a RawMaterialsOrderList.
     */
    data?: XOR<RawMaterialsOrderListCreateInput, RawMaterialsOrderListUncheckedCreateInput>
  }

  /**
   * RawMaterialsOrderList createMany
   */
  export type RawMaterialsOrderListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RawMaterialsOrderLists.
     */
    data: RawMaterialsOrderListCreateManyInput | RawMaterialsOrderListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RawMaterialsOrderList createManyAndReturn
   */
  export type RawMaterialsOrderListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * The data used to create many RawMaterialsOrderLists.
     */
    data: RawMaterialsOrderListCreateManyInput | RawMaterialsOrderListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawMaterialsOrderList update
   */
  export type RawMaterialsOrderListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * The data needed to update a RawMaterialsOrderList.
     */
    data: XOR<RawMaterialsOrderListUpdateInput, RawMaterialsOrderListUncheckedUpdateInput>
    /**
     * Choose, which RawMaterialsOrderList to update.
     */
    where: RawMaterialsOrderListWhereUniqueInput
  }

  /**
   * RawMaterialsOrderList updateMany
   */
  export type RawMaterialsOrderListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RawMaterialsOrderLists.
     */
    data: XOR<RawMaterialsOrderListUpdateManyMutationInput, RawMaterialsOrderListUncheckedUpdateManyInput>
    /**
     * Filter which RawMaterialsOrderLists to update
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * Limit how many RawMaterialsOrderLists to update.
     */
    limit?: number
  }

  /**
   * RawMaterialsOrderList updateManyAndReturn
   */
  export type RawMaterialsOrderListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * The data used to update RawMaterialsOrderLists.
     */
    data: XOR<RawMaterialsOrderListUpdateManyMutationInput, RawMaterialsOrderListUncheckedUpdateManyInput>
    /**
     * Filter which RawMaterialsOrderLists to update
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * Limit how many RawMaterialsOrderLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RawMaterialsOrderList upsert
   */
  export type RawMaterialsOrderListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * The filter to search for the RawMaterialsOrderList to update in case it exists.
     */
    where: RawMaterialsOrderListWhereUniqueInput
    /**
     * In case the RawMaterialsOrderList found by the `where` argument doesn't exist, create a new RawMaterialsOrderList with this data.
     */
    create: XOR<RawMaterialsOrderListCreateInput, RawMaterialsOrderListUncheckedCreateInput>
    /**
     * In case the RawMaterialsOrderList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RawMaterialsOrderListUpdateInput, RawMaterialsOrderListUncheckedUpdateInput>
  }

  /**
   * RawMaterialsOrderList delete
   */
  export type RawMaterialsOrderListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
    /**
     * Filter which RawMaterialsOrderList to delete.
     */
    where: RawMaterialsOrderListWhereUniqueInput
  }

  /**
   * RawMaterialsOrderList deleteMany
   */
  export type RawMaterialsOrderListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RawMaterialsOrderLists to delete
     */
    where?: RawMaterialsOrderListWhereInput
    /**
     * Limit how many RawMaterialsOrderLists to delete.
     */
    limit?: number
  }

  /**
   * RawMaterialsOrderList.supplier
   */
  export type RawMaterialsOrderList$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * RawMaterialsOrderList without action
   */
  export type RawMaterialsOrderListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RawMaterialsOrderList
     */
    select?: RawMaterialsOrderListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RawMaterialsOrderList
     */
    omit?: RawMaterialsOrderListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RawMaterialsOrderListInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logs?: boolean | User$logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | User$logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      logs: Prisma.$LogEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    cursor?: LogEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model LogEntry
   */

  export type AggregateLogEntry = {
    _count: LogEntryCountAggregateOutputType | null
    _avg: LogEntryAvgAggregateOutputType | null
    _sum: LogEntrySumAggregateOutputType | null
    _min: LogEntryMinAggregateOutputType | null
    _max: LogEntryMaxAggregateOutputType | null
  }

  export type LogEntryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogEntrySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LogEntryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    timestamp: Date | null
  }

  export type LogEntryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    timestamp: Date | null
  }

  export type LogEntryCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    timestamp: number
    _all: number
  }


  export type LogEntryAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogEntrySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LogEntryMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    timestamp?: true
  }

  export type LogEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    timestamp?: true
  }

  export type LogEntryCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    timestamp?: true
    _all?: true
  }

  export type LogEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntry to aggregate.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogEntries
    **/
    _count?: true | LogEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogEntryMaxAggregateInputType
  }

  export type GetLogEntryAggregateType<T extends LogEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLogEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogEntry[P]>
      : GetScalarType<T[P], AggregateLogEntry[P]>
  }




  export type LogEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithAggregationInput | LogEntryOrderByWithAggregationInput[]
    by: LogEntryScalarFieldEnum[] | LogEntryScalarFieldEnum
    having?: LogEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogEntryCountAggregateInputType | true
    _avg?: LogEntryAvgAggregateInputType
    _sum?: LogEntrySumAggregateInputType
    _min?: LogEntryMinAggregateInputType
    _max?: LogEntryMaxAggregateInputType
  }

  export type LogEntryGroupByOutputType = {
    id: number
    userId: number
    action: string
    timestamp: Date
    _count: LogEntryCountAggregateOutputType | null
    _avg: LogEntryAvgAggregateOutputType | null
    _sum: LogEntrySumAggregateOutputType | null
    _min: LogEntryMinAggregateOutputType | null
    _max: LogEntryMaxAggregateOutputType | null
  }

  type GetLogEntryGroupByPayload<T extends LogEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LogEntryGroupByOutputType[P]>
        }
      >
    >


  export type LogEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logEntry"]>

  export type LogEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logEntry"]>

  export type LogEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logEntry"]>

  export type LogEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    timestamp?: boolean
  }

  export type LogEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "timestamp", ExtArgs["result"]["logEntry"]>
  export type LogEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LogEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      timestamp: Date
    }, ExtArgs["result"]["logEntry"]>
    composites: {}
  }

  type LogEntryGetPayload<S extends boolean | null | undefined | LogEntryDefaultArgs> = $Result.GetResult<Prisma.$LogEntryPayload, S>

  type LogEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogEntryCountAggregateInputType | true
    }

  export interface LogEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogEntry'], meta: { name: 'LogEntry' } }
    /**
     * Find zero or one LogEntry that matches the filter.
     * @param {LogEntryFindUniqueArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogEntryFindUniqueArgs>(args: SelectSubset<T, LogEntryFindUniqueArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LogEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogEntryFindUniqueOrThrowArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LogEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LogEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindFirstArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogEntryFindFirstArgs>(args?: SelectSubset<T, LogEntryFindFirstArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LogEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindFirstOrThrowArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LogEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LogEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogEntries
     * const logEntries = await prisma.logEntry.findMany()
     * 
     * // Get first 10 LogEntries
     * const logEntries = await prisma.logEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logEntryWithIdOnly = await prisma.logEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogEntryFindManyArgs>(args?: SelectSubset<T, LogEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LogEntry.
     * @param {LogEntryCreateArgs} args - Arguments to create a LogEntry.
     * @example
     * // Create one LogEntry
     * const LogEntry = await prisma.logEntry.create({
     *   data: {
     *     // ... data to create a LogEntry
     *   }
     * })
     * 
     */
    create<T extends LogEntryCreateArgs>(args: SelectSubset<T, LogEntryCreateArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LogEntries.
     * @param {LogEntryCreateManyArgs} args - Arguments to create many LogEntries.
     * @example
     * // Create many LogEntries
     * const logEntry = await prisma.logEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogEntryCreateManyArgs>(args?: SelectSubset<T, LogEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogEntries and returns the data saved in the database.
     * @param {LogEntryCreateManyAndReturnArgs} args - Arguments to create many LogEntries.
     * @example
     * // Create many LogEntries
     * const logEntry = await prisma.logEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogEntries and only return the `id`
     * const logEntryWithIdOnly = await prisma.logEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LogEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LogEntry.
     * @param {LogEntryDeleteArgs} args - Arguments to delete one LogEntry.
     * @example
     * // Delete one LogEntry
     * const LogEntry = await prisma.logEntry.delete({
     *   where: {
     *     // ... filter to delete one LogEntry
     *   }
     * })
     * 
     */
    delete<T extends LogEntryDeleteArgs>(args: SelectSubset<T, LogEntryDeleteArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LogEntry.
     * @param {LogEntryUpdateArgs} args - Arguments to update one LogEntry.
     * @example
     * // Update one LogEntry
     * const logEntry = await prisma.logEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogEntryUpdateArgs>(args: SelectSubset<T, LogEntryUpdateArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LogEntries.
     * @param {LogEntryDeleteManyArgs} args - Arguments to filter LogEntries to delete.
     * @example
     * // Delete a few LogEntries
     * const { count } = await prisma.logEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogEntryDeleteManyArgs>(args?: SelectSubset<T, LogEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogEntries
     * const logEntry = await prisma.logEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogEntryUpdateManyArgs>(args: SelectSubset<T, LogEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogEntries and returns the data updated in the database.
     * @param {LogEntryUpdateManyAndReturnArgs} args - Arguments to update many LogEntries.
     * @example
     * // Update many LogEntries
     * const logEntry = await prisma.logEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LogEntries and only return the `id`
     * const logEntryWithIdOnly = await prisma.logEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LogEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LogEntry.
     * @param {LogEntryUpsertArgs} args - Arguments to update or create a LogEntry.
     * @example
     * // Update or create a LogEntry
     * const logEntry = await prisma.logEntry.upsert({
     *   create: {
     *     // ... data to create a LogEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogEntry we want to update
     *   }
     * })
     */
    upsert<T extends LogEntryUpsertArgs>(args: SelectSubset<T, LogEntryUpsertArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryCountArgs} args - Arguments to filter LogEntries to count.
     * @example
     * // Count the number of LogEntries
     * const count = await prisma.logEntry.count({
     *   where: {
     *     // ... the filter for the LogEntries we want to count
     *   }
     * })
    **/
    count<T extends LogEntryCountArgs>(
      args?: Subset<T, LogEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogEntryAggregateArgs>(args: Subset<T, LogEntryAggregateArgs>): Prisma.PrismaPromise<GetLogEntryAggregateType<T>>

    /**
     * Group by LogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogEntryGroupByArgs['orderBy'] }
        : { orderBy?: LogEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogEntry model
   */
  readonly fields: LogEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogEntry model
   */
  interface LogEntryFieldRefs {
    readonly id: FieldRef<"LogEntry", 'Int'>
    readonly userId: FieldRef<"LogEntry", 'Int'>
    readonly action: FieldRef<"LogEntry", 'String'>
    readonly timestamp: FieldRef<"LogEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogEntry findUnique
   */
  export type LogEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry findUniqueOrThrow
   */
  export type LogEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry findFirst
   */
  export type LogEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntries.
     */
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry findFirstOrThrow
   */
  export type LogEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntries.
     */
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry findMany
   */
  export type LogEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntries to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry create
   */
  export type LogEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LogEntry.
     */
    data: XOR<LogEntryCreateInput, LogEntryUncheckedCreateInput>
  }

  /**
   * LogEntry createMany
   */
  export type LogEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogEntries.
     */
    data: LogEntryCreateManyInput | LogEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogEntry createManyAndReturn
   */
  export type LogEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LogEntries.
     */
    data: LogEntryCreateManyInput | LogEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogEntry update
   */
  export type LogEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LogEntry.
     */
    data: XOR<LogEntryUpdateInput, LogEntryUncheckedUpdateInput>
    /**
     * Choose, which LogEntry to update.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry updateMany
   */
  export type LogEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogEntries.
     */
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyInput>
    /**
     * Filter which LogEntries to update
     */
    where?: LogEntryWhereInput
    /**
     * Limit how many LogEntries to update.
     */
    limit?: number
  }

  /**
   * LogEntry updateManyAndReturn
   */
  export type LogEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * The data used to update LogEntries.
     */
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyInput>
    /**
     * Filter which LogEntries to update
     */
    where?: LogEntryWhereInput
    /**
     * Limit how many LogEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogEntry upsert
   */
  export type LogEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LogEntry to update in case it exists.
     */
    where: LogEntryWhereUniqueInput
    /**
     * In case the LogEntry found by the `where` argument doesn't exist, create a new LogEntry with this data.
     */
    create: XOR<LogEntryCreateInput, LogEntryUncheckedCreateInput>
    /**
     * In case the LogEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogEntryUpdateInput, LogEntryUncheckedUpdateInput>
  }

  /**
   * LogEntry delete
   */
  export type LogEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter which LogEntry to delete.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry deleteMany
   */
  export type LogEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntries to delete
     */
    where?: LogEntryWhereInput
    /**
     * Limit how many LogEntries to delete.
     */
    limit?: number
  }

  /**
   * LogEntry without action
   */
  export type LogEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogEntry
     */
    omit?: LogEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
  }


  /**
   * Model OrderProduction
   */

  export type AggregateOrderProduction = {
    _count: OrderProductionCountAggregateOutputType | null
    _avg: OrderProductionAvgAggregateOutputType | null
    _sum: OrderProductionSumAggregateOutputType | null
    _min: OrderProductionMinAggregateOutputType | null
    _max: OrderProductionMaxAggregateOutputType | null
  }

  export type OrderProductionAvgAggregateOutputType = {
    id: number | null
  }

  export type OrderProductionSumAggregateOutputType = {
    id: number | null
  }

  export type OrderProductionMinAggregateOutputType = {
    id: number | null
    orderNo: string | null
    status: $Enums.ProductionStatus | null
    updatedAt: Date | null
    notes: string | null
  }

  export type OrderProductionMaxAggregateOutputType = {
    id: number | null
    orderNo: string | null
    status: $Enums.ProductionStatus | null
    updatedAt: Date | null
    notes: string | null
  }

  export type OrderProductionCountAggregateOutputType = {
    id: number
    orderNo: number
    status: number
    updatedAt: number
    notes: number
    _all: number
  }


  export type OrderProductionAvgAggregateInputType = {
    id?: true
  }

  export type OrderProductionSumAggregateInputType = {
    id?: true
  }

  export type OrderProductionMinAggregateInputType = {
    id?: true
    orderNo?: true
    status?: true
    updatedAt?: true
    notes?: true
  }

  export type OrderProductionMaxAggregateInputType = {
    id?: true
    orderNo?: true
    status?: true
    updatedAt?: true
    notes?: true
  }

  export type OrderProductionCountAggregateInputType = {
    id?: true
    orderNo?: true
    status?: true
    updatedAt?: true
    notes?: true
    _all?: true
  }

  export type OrderProductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProduction to aggregate.
     */
    where?: OrderProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProductions to fetch.
     */
    orderBy?: OrderProductionOrderByWithRelationInput | OrderProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderProductions
    **/
    _count?: true | OrderProductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderProductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderProductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderProductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderProductionMaxAggregateInputType
  }

  export type GetOrderProductionAggregateType<T extends OrderProductionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderProduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderProduction[P]>
      : GetScalarType<T[P], AggregateOrderProduction[P]>
  }




  export type OrderProductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductionWhereInput
    orderBy?: OrderProductionOrderByWithAggregationInput | OrderProductionOrderByWithAggregationInput[]
    by: OrderProductionScalarFieldEnum[] | OrderProductionScalarFieldEnum
    having?: OrderProductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderProductionCountAggregateInputType | true
    _avg?: OrderProductionAvgAggregateInputType
    _sum?: OrderProductionSumAggregateInputType
    _min?: OrderProductionMinAggregateInputType
    _max?: OrderProductionMaxAggregateInputType
  }

  export type OrderProductionGroupByOutputType = {
    id: number
    orderNo: string
    status: $Enums.ProductionStatus
    updatedAt: Date
    notes: string | null
    _count: OrderProductionCountAggregateOutputType | null
    _avg: OrderProductionAvgAggregateOutputType | null
    _sum: OrderProductionSumAggregateOutputType | null
    _min: OrderProductionMinAggregateOutputType | null
    _max: OrderProductionMaxAggregateOutputType | null
  }

  type GetOrderProductionGroupByPayload<T extends OrderProductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderProductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderProductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderProductionGroupByOutputType[P]>
            : GetScalarType<T[P], OrderProductionGroupByOutputType[P]>
        }
      >
    >


  export type OrderProductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    status?: boolean
    updatedAt?: boolean
    notes?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduction"]>

  export type OrderProductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    status?: boolean
    updatedAt?: boolean
    notes?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduction"]>

  export type OrderProductionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    status?: boolean
    updatedAt?: boolean
    notes?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduction"]>

  export type OrderProductionSelectScalar = {
    id?: boolean
    orderNo?: boolean
    status?: boolean
    updatedAt?: boolean
    notes?: boolean
  }

  export type OrderProductionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNo" | "status" | "updatedAt" | "notes", ExtArgs["result"]["orderProduction"]>
  export type OrderProductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }
  export type OrderProductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }
  export type OrderProductionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
  }

  export type $OrderProductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderProduction"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNo: string
      status: $Enums.ProductionStatus
      updatedAt: Date
      notes: string | null
    }, ExtArgs["result"]["orderProduction"]>
    composites: {}
  }

  type OrderProductionGetPayload<S extends boolean | null | undefined | OrderProductionDefaultArgs> = $Result.GetResult<Prisma.$OrderProductionPayload, S>

  type OrderProductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderProductionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderProductionCountAggregateInputType | true
    }

  export interface OrderProductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderProduction'], meta: { name: 'OrderProduction' } }
    /**
     * Find zero or one OrderProduction that matches the filter.
     * @param {OrderProductionFindUniqueArgs} args - Arguments to find a OrderProduction
     * @example
     * // Get one OrderProduction
     * const orderProduction = await prisma.orderProduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderProductionFindUniqueArgs>(args: SelectSubset<T, OrderProductionFindUniqueArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderProduction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderProductionFindUniqueOrThrowArgs} args - Arguments to find a OrderProduction
     * @example
     * // Get one OrderProduction
     * const orderProduction = await prisma.orderProduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderProductionFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderProductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderProduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionFindFirstArgs} args - Arguments to find a OrderProduction
     * @example
     * // Get one OrderProduction
     * const orderProduction = await prisma.orderProduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderProductionFindFirstArgs>(args?: SelectSubset<T, OrderProductionFindFirstArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderProduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionFindFirstOrThrowArgs} args - Arguments to find a OrderProduction
     * @example
     * // Get one OrderProduction
     * const orderProduction = await prisma.orderProduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderProductionFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderProductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderProductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderProductions
     * const orderProductions = await prisma.orderProduction.findMany()
     * 
     * // Get first 10 OrderProductions
     * const orderProductions = await prisma.orderProduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderProductionWithIdOnly = await prisma.orderProduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderProductionFindManyArgs>(args?: SelectSubset<T, OrderProductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderProduction.
     * @param {OrderProductionCreateArgs} args - Arguments to create a OrderProduction.
     * @example
     * // Create one OrderProduction
     * const OrderProduction = await prisma.orderProduction.create({
     *   data: {
     *     // ... data to create a OrderProduction
     *   }
     * })
     * 
     */
    create<T extends OrderProductionCreateArgs>(args: SelectSubset<T, OrderProductionCreateArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderProductions.
     * @param {OrderProductionCreateManyArgs} args - Arguments to create many OrderProductions.
     * @example
     * // Create many OrderProductions
     * const orderProduction = await prisma.orderProduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderProductionCreateManyArgs>(args?: SelectSubset<T, OrderProductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderProductions and returns the data saved in the database.
     * @param {OrderProductionCreateManyAndReturnArgs} args - Arguments to create many OrderProductions.
     * @example
     * // Create many OrderProductions
     * const orderProduction = await prisma.orderProduction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderProductions and only return the `id`
     * const orderProductionWithIdOnly = await prisma.orderProduction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderProductionCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderProductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderProduction.
     * @param {OrderProductionDeleteArgs} args - Arguments to delete one OrderProduction.
     * @example
     * // Delete one OrderProduction
     * const OrderProduction = await prisma.orderProduction.delete({
     *   where: {
     *     // ... filter to delete one OrderProduction
     *   }
     * })
     * 
     */
    delete<T extends OrderProductionDeleteArgs>(args: SelectSubset<T, OrderProductionDeleteArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderProduction.
     * @param {OrderProductionUpdateArgs} args - Arguments to update one OrderProduction.
     * @example
     * // Update one OrderProduction
     * const orderProduction = await prisma.orderProduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderProductionUpdateArgs>(args: SelectSubset<T, OrderProductionUpdateArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderProductions.
     * @param {OrderProductionDeleteManyArgs} args - Arguments to filter OrderProductions to delete.
     * @example
     * // Delete a few OrderProductions
     * const { count } = await prisma.orderProduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderProductionDeleteManyArgs>(args?: SelectSubset<T, OrderProductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderProductions
     * const orderProduction = await prisma.orderProduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderProductionUpdateManyArgs>(args: SelectSubset<T, OrderProductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProductions and returns the data updated in the database.
     * @param {OrderProductionUpdateManyAndReturnArgs} args - Arguments to update many OrderProductions.
     * @example
     * // Update many OrderProductions
     * const orderProduction = await prisma.orderProduction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderProductions and only return the `id`
     * const orderProductionWithIdOnly = await prisma.orderProduction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderProductionUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderProductionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderProduction.
     * @param {OrderProductionUpsertArgs} args - Arguments to update or create a OrderProduction.
     * @example
     * // Update or create a OrderProduction
     * const orderProduction = await prisma.orderProduction.upsert({
     *   create: {
     *     // ... data to create a OrderProduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderProduction we want to update
     *   }
     * })
     */
    upsert<T extends OrderProductionUpsertArgs>(args: SelectSubset<T, OrderProductionUpsertArgs<ExtArgs>>): Prisma__OrderProductionClient<$Result.GetResult<Prisma.$OrderProductionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderProductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionCountArgs} args - Arguments to filter OrderProductions to count.
     * @example
     * // Count the number of OrderProductions
     * const count = await prisma.orderProduction.count({
     *   where: {
     *     // ... the filter for the OrderProductions we want to count
     *   }
     * })
    **/
    count<T extends OrderProductionCountArgs>(
      args?: Subset<T, OrderProductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderProductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderProduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderProductionAggregateArgs>(args: Subset<T, OrderProductionAggregateArgs>): Prisma.PrismaPromise<GetOrderProductionAggregateType<T>>

    /**
     * Group by OrderProduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderProductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderProductionGroupByArgs['orderBy'] }
        : { orderBy?: OrderProductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderProductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderProductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderProduction model
   */
  readonly fields: OrderProductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderProduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderProductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderProduction model
   */
  interface OrderProductionFieldRefs {
    readonly id: FieldRef<"OrderProduction", 'Int'>
    readonly orderNo: FieldRef<"OrderProduction", 'String'>
    readonly status: FieldRef<"OrderProduction", 'ProductionStatus'>
    readonly updatedAt: FieldRef<"OrderProduction", 'DateTime'>
    readonly notes: FieldRef<"OrderProduction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderProduction findUnique
   */
  export type OrderProductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduction to fetch.
     */
    where: OrderProductionWhereUniqueInput
  }

  /**
   * OrderProduction findUniqueOrThrow
   */
  export type OrderProductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduction to fetch.
     */
    where: OrderProductionWhereUniqueInput
  }

  /**
   * OrderProduction findFirst
   */
  export type OrderProductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduction to fetch.
     */
    where?: OrderProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProductions to fetch.
     */
    orderBy?: OrderProductionOrderByWithRelationInput | OrderProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProductions.
     */
    cursor?: OrderProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProductions.
     */
    distinct?: OrderProductionScalarFieldEnum | OrderProductionScalarFieldEnum[]
  }

  /**
   * OrderProduction findFirstOrThrow
   */
  export type OrderProductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduction to fetch.
     */
    where?: OrderProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProductions to fetch.
     */
    orderBy?: OrderProductionOrderByWithRelationInput | OrderProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProductions.
     */
    cursor?: OrderProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProductions.
     */
    distinct?: OrderProductionScalarFieldEnum | OrderProductionScalarFieldEnum[]
  }

  /**
   * OrderProduction findMany
   */
  export type OrderProductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * Filter, which OrderProductions to fetch.
     */
    where?: OrderProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProductions to fetch.
     */
    orderBy?: OrderProductionOrderByWithRelationInput | OrderProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderProductions.
     */
    cursor?: OrderProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProductions.
     */
    skip?: number
    distinct?: OrderProductionScalarFieldEnum | OrderProductionScalarFieldEnum[]
  }

  /**
   * OrderProduction create
   */
  export type OrderProductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderProduction.
     */
    data: XOR<OrderProductionCreateInput, OrderProductionUncheckedCreateInput>
  }

  /**
   * OrderProduction createMany
   */
  export type OrderProductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderProductions.
     */
    data: OrderProductionCreateManyInput | OrderProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderProduction createManyAndReturn
   */
  export type OrderProductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * The data used to create many OrderProductions.
     */
    data: OrderProductionCreateManyInput | OrderProductionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderProduction update
   */
  export type OrderProductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderProduction.
     */
    data: XOR<OrderProductionUpdateInput, OrderProductionUncheckedUpdateInput>
    /**
     * Choose, which OrderProduction to update.
     */
    where: OrderProductionWhereUniqueInput
  }

  /**
   * OrderProduction updateMany
   */
  export type OrderProductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderProductions.
     */
    data: XOR<OrderProductionUpdateManyMutationInput, OrderProductionUncheckedUpdateManyInput>
    /**
     * Filter which OrderProductions to update
     */
    where?: OrderProductionWhereInput
    /**
     * Limit how many OrderProductions to update.
     */
    limit?: number
  }

  /**
   * OrderProduction updateManyAndReturn
   */
  export type OrderProductionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * The data used to update OrderProductions.
     */
    data: XOR<OrderProductionUpdateManyMutationInput, OrderProductionUncheckedUpdateManyInput>
    /**
     * Filter which OrderProductions to update
     */
    where?: OrderProductionWhereInput
    /**
     * Limit how many OrderProductions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderProduction upsert
   */
  export type OrderProductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderProduction to update in case it exists.
     */
    where: OrderProductionWhereUniqueInput
    /**
     * In case the OrderProduction found by the `where` argument doesn't exist, create a new OrderProduction with this data.
     */
    create: XOR<OrderProductionCreateInput, OrderProductionUncheckedCreateInput>
    /**
     * In case the OrderProduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderProductionUpdateInput, OrderProductionUncheckedUpdateInput>
  }

  /**
   * OrderProduction delete
   */
  export type OrderProductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
    /**
     * Filter which OrderProduction to delete.
     */
    where: OrderProductionWhereUniqueInput
  }

  /**
   * OrderProduction deleteMany
   */
  export type OrderProductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProductions to delete
     */
    where?: OrderProductionWhereInput
    /**
     * Limit how many OrderProductions to delete.
     */
    limit?: number
  }

  /**
   * OrderProduction without action
   */
  export type OrderProductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduction
     */
    select?: OrderProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduction
     */
    omit?: OrderProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const RackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location_id: 'location_id',
    capacity: 'capacity',
    current_utilization: 'current_utilization',
    createdAt: 'createdAt'
  };

  export type RackScalarFieldEnum = (typeof RackScalarFieldEnum)[keyof typeof RackScalarFieldEnum]


  export const BunchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rack_id: 'rack_id',
    createdAt: 'createdAt'
  };

  export type BunchScalarFieldEnum = (typeof BunchScalarFieldEnum)[keyof typeof BunchScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    baseUnit: 'baseUnit',
    conversion_rate: 'conversion_rate'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    type: 'type',
    quantity: 'quantity',
    note: 'note',
    moved_at: 'moved_at'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const ItemSupplierScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    supplier_id: 'supplier_id',
    price: 'price',
    added_on: 'added_on'
  };

  export type ItemSupplierScalarFieldEnum = (typeof ItemSupplierScalarFieldEnum)[keyof typeof ItemSupplierScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    item_id: 'item_id',
    item_name: 'item_name',
    item_type: 'item_type',
    bunch_id: 'bunch_id',
    unit_id: 'unit_id',
    quantity: 'quantity'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    customer_id: 'customer_id',
    first_name: 'first_name',
    middle_name: 'middle_name',
    last_name: 'last_name',
    add1: 'add1',
    add2: 'add2',
    add3: 'add3',
    add4: 'add4',
    email: 'email',
    mobile: 'mobile',
    office_phone: 'office_phone',
    residential_phone: 'residential_phone',
    last_ordered_date: 'last_ordered_date'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const FabricScalarFieldEnum: {
    fabric_id: 'fabric_id',
    description: 'description',
    available_length: 'available_length',
    fabric_code: 'fabric_code',
    fabric_brand: 'fabric_brand',
    stock_location: 'stock_location',
    image: 'image',
    barcode: 'barcode'
  };

  export type FabricScalarFieldEnum = (typeof FabricScalarFieldEnum)[keyof typeof FabricScalarFieldEnum]


  export const FabricOrderListScalarFieldEnum: {
    order_id: 'order_id',
    fabric_id: 'fabric_id',
    description: 'description',
    supplier_name: 'supplier_name',
    meters: 'meters',
    ordered_date: 'ordered_date',
    ordered_for: 'ordered_for',
    supplier_id: 'supplier_id'
  };

  export type FabricOrderListScalarFieldEnum = (typeof FabricOrderListScalarFieldEnum)[keyof typeof FabricOrderListScalarFieldEnum]


  export const FinalJacketMeasurementScalarFieldEnum: {
    measurement_id: 'measurement_id',
    customer_id: 'customer_id',
    orderNo: 'orderNo',
    date: 'date',
    jacket_length: 'jacket_length',
    natural_length: 'natural_length',
    back_length: 'back_length',
    x_back: 'x_back',
    half_shoulder: 'half_shoulder',
    to_sleeve: 'to_sleeve',
    chest: 'chest',
    waist: 'waist',
    collar: 'collar',
    waist_coat_length: 'waist_coat_length',
    sherwani_length: 'sherwani_length',
    other_notes: 'other_notes'
  };

  export type FinalJacketMeasurementScalarFieldEnum = (typeof FinalJacketMeasurementScalarFieldEnum)[keyof typeof FinalJacketMeasurementScalarFieldEnum]


  export const JacketMeasurementScalarFieldEnum: {
    measurement_id: 'measurement_id',
    customer_id: 'customer_id',
    orderNo: 'orderNo',
    date: 'date',
    jacket_length: 'jacket_length',
    natural_length: 'natural_length',
    back_length: 'back_length',
    x_back: 'x_back',
    half_shoulder: 'half_shoulder',
    to_sleeve: 'to_sleeve',
    chest: 'chest',
    waist: 'waist',
    collar: 'collar',
    waist_coat_length: 'waist_coat_length',
    sherwani_length: 'sherwani_length',
    other_notes: 'other_notes'
  };

  export type JacketMeasurementScalarFieldEnum = (typeof JacketMeasurementScalarFieldEnum)[keyof typeof JacketMeasurementScalarFieldEnum]


  export const FinalPantMeasurementScalarFieldEnum: {
    measurement_id: 'measurement_id',
    customer_id: 'customer_id',
    orderNo: 'orderNo',
    date: 'date',
    length: 'length',
    inseem: 'inseem',
    waist: 'waist',
    hips: 'hips',
    bottom: 'bottom',
    knee: 'knee',
    other_notes: 'other_notes'
  };

  export type FinalPantMeasurementScalarFieldEnum = (typeof FinalPantMeasurementScalarFieldEnum)[keyof typeof FinalPantMeasurementScalarFieldEnum]


  export const PantMeasurementScalarFieldEnum: {
    measurement_id: 'measurement_id',
    customer_id: 'customer_id',
    orderNo: 'orderNo',
    date: 'date',
    length: 'length',
    inseem: 'inseem',
    waist: 'waist',
    hips: 'hips',
    bottom: 'bottom',
    knee: 'knee',
    other_notes: 'other_notes'
  };

  export type PantMeasurementScalarFieldEnum = (typeof PantMeasurementScalarFieldEnum)[keyof typeof PantMeasurementScalarFieldEnum]


  export const FinalShirtMeasurementScalarFieldEnum: {
    measurement_id: 'measurement_id',
    customer_id: 'customer_id',
    orderNo: 'orderNo',
    date: 'date',
    length: 'length',
    half_shoulder: 'half_shoulder',
    to_sleeve: 'to_sleeve',
    chest: 'chest',
    waist: 'waist',
    collar: 'collar',
    other_notes: 'other_notes'
  };

  export type FinalShirtMeasurementScalarFieldEnum = (typeof FinalShirtMeasurementScalarFieldEnum)[keyof typeof FinalShirtMeasurementScalarFieldEnum]


  export const ShirtMeasurementScalarFieldEnum: {
    measurement_id: 'measurement_id',
    customer_id: 'customer_id',
    orderNo: 'orderNo',
    date: 'date',
    length: 'length',
    half_shoulder: 'half_shoulder',
    to_sleeve: 'to_sleeve',
    chest: 'chest',
    waist: 'waist',
    collar: 'collar',
    other_notes: 'other_notes'
  };

  export type ShirtMeasurementScalarFieldEnum = (typeof ShirtMeasurementScalarFieldEnum)[keyof typeof ShirtMeasurementScalarFieldEnum]


  export const OrderPhotosScalarFieldEnum: {
    photo_id: 'photo_id',
    orderNo: 'orderNo',
    s3_key: 's3_key',
    uploaded_at: 'uploaded_at'
  };

  export type OrderPhotosScalarFieldEnum = (typeof OrderPhotosScalarFieldEnum)[keyof typeof OrderPhotosScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    orderNo: 'orderNo',
    customer_id: 'customer_id',
    date: 'date',
    onote: 'onote'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    item_id: 'item_id',
    orderNo: 'orderNo',
    item_name: 'item_name',
    item_type: 'item_type',
    fabric_id: 'fabric_id',
    lining_fabric_id: 'lining_fabric_id',
    jacket_measurement_id: 'jacket_measurement_id',
    shirt_measurement_id: 'shirt_measurement_id',
    pant_measurement_id: 'pant_measurement_id',
    final_jacket_measurement_id: 'final_jacket_measurement_id',
    final_shirt_measurement_id: 'final_shirt_measurement_id',
    final_pant_measurement_id: 'final_pant_measurement_id'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    supplier_id: 'supplier_id',
    supplier_name: 'supplier_name',
    add1: 'add1',
    add2: 'add2',
    add3: 'add3',
    phone_number1: 'phone_number1',
    phone_number2: 'phone_number2',
    phone_number3: 'phone_number3',
    email: 'email',
    primary_contact_name1: 'primary_contact_name1',
    primary_contact_name2: 'primary_contact_name2',
    primary_contact_name3: 'primary_contact_name3',
    notes: 'notes'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const TailorScalarFieldEnum: {
    tailor_id: 'tailor_id',
    first_name: 'first_name',
    last_name: 'last_name',
    specialization: 'specialization',
    experience_years: 'experience_years',
    joining_date: 'joining_date',
    address: 'address',
    phone_number: 'phone_number',
    email: 'email',
    emergency_contact: 'emergency_contact',
    status: 'status',
    hourly_rate: 'hourly_rate',
    notes: 'notes'
  };

  export type TailorScalarFieldEnum = (typeof TailorScalarFieldEnum)[keyof typeof TailorScalarFieldEnum]


  export const OrderTailorScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    tailor_id: 'tailor_id',
    assigned_at: 'assigned_at',
    status: 'status',
    due_date: 'due_date',
    notes: 'notes'
  };

  export type OrderTailorScalarFieldEnum = (typeof OrderTailorScalarFieldEnum)[keyof typeof OrderTailorScalarFieldEnum]


  export const RawMaterialsOrderListScalarFieldEnum: {
    order_id: 'order_id',
    product_name: 'product_name',
    description: 'description',
    raw_material_code: 'raw_material_code',
    color: 'color',
    supplier_name: 'supplier_name',
    quantity: 'quantity',
    ordered_date: 'ordered_date',
    supplier_id: 'supplier_id'
  };

  export type RawMaterialsOrderListScalarFieldEnum = (typeof RawMaterialsOrderListScalarFieldEnum)[keyof typeof RawMaterialsOrderListScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LogEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    timestamp: 'timestamp'
  };

  export type LogEntryScalarFieldEnum = (typeof LogEntryScalarFieldEnum)[keyof typeof LogEntryScalarFieldEnum]


  export const OrderProductionScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    status: 'status',
    updatedAt: 'updatedAt',
    notes: 'notes'
  };

  export type OrderProductionScalarFieldEnum = (typeof OrderProductionScalarFieldEnum)[keyof typeof OrderProductionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MovementType'
   */
  export type EnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType'>
    


  /**
   * Reference to a field of type 'MovementType[]'
   */
  export type ListEnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'InventoryItemType'
   */
  export type EnumInventoryItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryItemType'>
    


  /**
   * Reference to a field of type 'InventoryItemType[]'
   */
  export type ListEnumInventoryItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryItemType[]'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'ProductionStatus'
   */
  export type EnumProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionStatus'>
    


  /**
   * Reference to a field of type 'ProductionStatus[]'
   */
  export type ListEnumProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    name?: StringFilter<"Location"> | string
    description?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    racks?: RackListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    racks?: RackOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    description?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    racks?: RackListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    name?: StringWithAggregatesFilter<"Location"> | string
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type RackWhereInput = {
    AND?: RackWhereInput | RackWhereInput[]
    OR?: RackWhereInput[]
    NOT?: RackWhereInput | RackWhereInput[]
    id?: IntFilter<"Rack"> | number
    name?: StringFilter<"Rack"> | string
    location_id?: IntFilter<"Rack"> | number
    capacity?: IntFilter<"Rack"> | number
    current_utilization?: IntFilter<"Rack"> | number
    createdAt?: DateTimeFilter<"Rack"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    bunches?: BunchListRelationFilter
  }

  export type RackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
    createdAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    bunches?: BunchOrderByRelationAggregateInput
  }

  export type RackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RackWhereInput | RackWhereInput[]
    OR?: RackWhereInput[]
    NOT?: RackWhereInput | RackWhereInput[]
    name?: StringFilter<"Rack"> | string
    location_id?: IntFilter<"Rack"> | number
    capacity?: IntFilter<"Rack"> | number
    current_utilization?: IntFilter<"Rack"> | number
    createdAt?: DateTimeFilter<"Rack"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    bunches?: BunchListRelationFilter
  }, "id">

  export type RackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
    createdAt?: SortOrder
    _count?: RackCountOrderByAggregateInput
    _avg?: RackAvgOrderByAggregateInput
    _max?: RackMaxOrderByAggregateInput
    _min?: RackMinOrderByAggregateInput
    _sum?: RackSumOrderByAggregateInput
  }

  export type RackScalarWhereWithAggregatesInput = {
    AND?: RackScalarWhereWithAggregatesInput | RackScalarWhereWithAggregatesInput[]
    OR?: RackScalarWhereWithAggregatesInput[]
    NOT?: RackScalarWhereWithAggregatesInput | RackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rack"> | number
    name?: StringWithAggregatesFilter<"Rack"> | string
    location_id?: IntWithAggregatesFilter<"Rack"> | number
    capacity?: IntWithAggregatesFilter<"Rack"> | number
    current_utilization?: IntWithAggregatesFilter<"Rack"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Rack"> | Date | string
  }

  export type BunchWhereInput = {
    AND?: BunchWhereInput | BunchWhereInput[]
    OR?: BunchWhereInput[]
    NOT?: BunchWhereInput | BunchWhereInput[]
    id?: IntFilter<"Bunch"> | number
    name?: StringFilter<"Bunch"> | string
    rack_id?: IntFilter<"Bunch"> | number
    createdAt?: DateTimeFilter<"Bunch"> | Date | string
    rack?: XOR<RackScalarRelationFilter, RackWhereInput>
    items?: InventoryItemListRelationFilter
  }

  export type BunchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rack_id?: SortOrder
    createdAt?: SortOrder
    rack?: RackOrderByWithRelationInput
    items?: InventoryItemOrderByRelationAggregateInput
  }

  export type BunchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BunchWhereInput | BunchWhereInput[]
    OR?: BunchWhereInput[]
    NOT?: BunchWhereInput | BunchWhereInput[]
    name?: StringFilter<"Bunch"> | string
    rack_id?: IntFilter<"Bunch"> | number
    createdAt?: DateTimeFilter<"Bunch"> | Date | string
    rack?: XOR<RackScalarRelationFilter, RackWhereInput>
    items?: InventoryItemListRelationFilter
  }, "id">

  export type BunchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rack_id?: SortOrder
    createdAt?: SortOrder
    _count?: BunchCountOrderByAggregateInput
    _avg?: BunchAvgOrderByAggregateInput
    _max?: BunchMaxOrderByAggregateInput
    _min?: BunchMinOrderByAggregateInput
    _sum?: BunchSumOrderByAggregateInput
  }

  export type BunchScalarWhereWithAggregatesInput = {
    AND?: BunchScalarWhereWithAggregatesInput | BunchScalarWhereWithAggregatesInput[]
    OR?: BunchScalarWhereWithAggregatesInput[]
    NOT?: BunchScalarWhereWithAggregatesInput | BunchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bunch"> | number
    name?: StringWithAggregatesFilter<"Bunch"> | string
    rack_id?: IntWithAggregatesFilter<"Bunch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Bunch"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    name?: StringFilter<"Unit"> | string
    symbol?: StringFilter<"Unit"> | string
    baseUnit?: StringNullableFilter<"Unit"> | string | null
    conversion_rate?: FloatNullableFilter<"Unit"> | number | null
    items?: InventoryItemListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    baseUnit?: SortOrderInput | SortOrder
    conversion_rate?: SortOrderInput | SortOrder
    items?: InventoryItemOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    name?: StringFilter<"Unit"> | string
    symbol?: StringFilter<"Unit"> | string
    baseUnit?: StringNullableFilter<"Unit"> | string | null
    conversion_rate?: FloatNullableFilter<"Unit"> | number | null
    items?: InventoryItemListRelationFilter
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    baseUnit?: SortOrderInput | SortOrder
    conversion_rate?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    name?: StringWithAggregatesFilter<"Unit"> | string
    symbol?: StringWithAggregatesFilter<"Unit"> | string
    baseUnit?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    conversion_rate?: FloatNullableWithAggregatesFilter<"Unit"> | number | null
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: IntFilter<"InventoryMovement"> | number
    item_id?: StringFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: FloatFilter<"InventoryMovement"> | number
    note?: StringNullableFilter<"InventoryMovement"> | string | null
    moved_at?: DateTimeFilter<"InventoryMovement"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    note?: SortOrderInput | SortOrder
    moved_at?: SortOrder
    item?: InventoryItemOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    item_id?: StringFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: FloatFilter<"InventoryMovement"> | number
    note?: StringNullableFilter<"InventoryMovement"> | string | null
    moved_at?: DateTimeFilter<"InventoryMovement"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    note?: SortOrderInput | SortOrder
    moved_at?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryMovement"> | number
    item_id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeWithAggregatesFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: FloatWithAggregatesFilter<"InventoryMovement"> | number
    note?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    moved_at?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
  }

  export type ItemSupplierWhereInput = {
    AND?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    OR?: ItemSupplierWhereInput[]
    NOT?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    id?: IntFilter<"ItemSupplier"> | number
    item_id?: StringFilter<"ItemSupplier"> | string
    supplier_id?: IntFilter<"ItemSupplier"> | number
    price?: DecimalNullableFilter<"ItemSupplier"> | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFilter<"ItemSupplier"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type ItemSupplierOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrderInput | SortOrder
    added_on?: SortOrder
    item?: InventoryItemOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type ItemSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    item_id_supplier_id?: ItemSupplierItem_idSupplier_idCompoundUniqueInput
    AND?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    OR?: ItemSupplierWhereInput[]
    NOT?: ItemSupplierWhereInput | ItemSupplierWhereInput[]
    item_id?: StringFilter<"ItemSupplier"> | string
    supplier_id?: IntFilter<"ItemSupplier"> | number
    price?: DecimalNullableFilter<"ItemSupplier"> | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFilter<"ItemSupplier"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id" | "item_id_supplier_id">

  export type ItemSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrderInput | SortOrder
    added_on?: SortOrder
    _count?: ItemSupplierCountOrderByAggregateInput
    _avg?: ItemSupplierAvgOrderByAggregateInput
    _max?: ItemSupplierMaxOrderByAggregateInput
    _min?: ItemSupplierMinOrderByAggregateInput
    _sum?: ItemSupplierSumOrderByAggregateInput
  }

  export type ItemSupplierScalarWhereWithAggregatesInput = {
    AND?: ItemSupplierScalarWhereWithAggregatesInput | ItemSupplierScalarWhereWithAggregatesInput[]
    OR?: ItemSupplierScalarWhereWithAggregatesInput[]
    NOT?: ItemSupplierScalarWhereWithAggregatesInput | ItemSupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemSupplier"> | number
    item_id?: StringWithAggregatesFilter<"ItemSupplier"> | string
    supplier_id?: IntWithAggregatesFilter<"ItemSupplier"> | number
    price?: DecimalNullableWithAggregatesFilter<"ItemSupplier"> | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeWithAggregatesFilter<"ItemSupplier"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    item_id?: StringFilter<"InventoryItem"> | string
    item_name?: StringFilter<"InventoryItem"> | string
    item_type?: EnumInventoryItemTypeFilter<"InventoryItem"> | $Enums.InventoryItemType
    bunch_id?: IntNullableFilter<"InventoryItem"> | number | null
    unit_id?: IntNullableFilter<"InventoryItem"> | number | null
    quantity?: FloatNullableFilter<"InventoryItem"> | number | null
    bunch?: XOR<BunchNullableScalarRelationFilter, BunchWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    suppliers?: ItemSupplierListRelationFilter
    movement_logs?: InventoryMovementListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    bunch_id?: SortOrderInput | SortOrder
    unit_id?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    bunch?: BunchOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    suppliers?: ItemSupplierOrderByRelationAggregateInput
    movement_logs?: InventoryMovementOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    item_id?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    item_name?: StringFilter<"InventoryItem"> | string
    item_type?: EnumInventoryItemTypeFilter<"InventoryItem"> | $Enums.InventoryItemType
    bunch_id?: IntNullableFilter<"InventoryItem"> | number | null
    unit_id?: IntNullableFilter<"InventoryItem"> | number | null
    quantity?: FloatNullableFilter<"InventoryItem"> | number | null
    bunch?: XOR<BunchNullableScalarRelationFilter, BunchWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    suppliers?: ItemSupplierListRelationFilter
    movement_logs?: InventoryMovementListRelationFilter
  }, "item_id">

  export type InventoryItemOrderByWithAggregationInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    bunch_id?: SortOrderInput | SortOrder
    unit_id?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    item_id?: StringWithAggregatesFilter<"InventoryItem"> | string
    item_name?: StringWithAggregatesFilter<"InventoryItem"> | string
    item_type?: EnumInventoryItemTypeWithAggregatesFilter<"InventoryItem"> | $Enums.InventoryItemType
    bunch_id?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    unit_id?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    quantity?: FloatNullableWithAggregatesFilter<"InventoryItem"> | number | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customer_id?: IntFilter<"Customer"> | number
    first_name?: StringNullableFilter<"Customer"> | string | null
    middle_name?: StringNullableFilter<"Customer"> | string | null
    last_name?: StringNullableFilter<"Customer"> | string | null
    add1?: StringNullableFilter<"Customer"> | string | null
    add2?: StringNullableFilter<"Customer"> | string | null
    add3?: StringNullableFilter<"Customer"> | string | null
    add4?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    office_phone?: StringNullableFilter<"Customer"> | string | null
    residential_phone?: StringNullableFilter<"Customer"> | string | null
    last_ordered_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    orders?: OrdersListRelationFilter
    measurements?: FinalJacketMeasurementListRelationFilter
    FinalPantMeasurement?: FinalPantMeasurementListRelationFilter
    FinalShirtMeasurement?: FinalShirtMeasurementListRelationFilter
    JacketMeasurement?: JacketMeasurementListRelationFilter
    PantMeasurement?: PantMeasurementListRelationFilter
    ShirtMeasurement?: ShirtMeasurementListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    customer_id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    middle_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    add1?: SortOrderInput | SortOrder
    add2?: SortOrderInput | SortOrder
    add3?: SortOrderInput | SortOrder
    add4?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    office_phone?: SortOrderInput | SortOrder
    residential_phone?: SortOrderInput | SortOrder
    last_ordered_date?: SortOrderInput | SortOrder
    orders?: OrdersOrderByRelationAggregateInput
    measurements?: FinalJacketMeasurementOrderByRelationAggregateInput
    FinalPantMeasurement?: FinalPantMeasurementOrderByRelationAggregateInput
    FinalShirtMeasurement?: FinalShirtMeasurementOrderByRelationAggregateInput
    JacketMeasurement?: JacketMeasurementOrderByRelationAggregateInput
    PantMeasurement?: PantMeasurementOrderByRelationAggregateInput
    ShirtMeasurement?: ShirtMeasurementOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    customer_id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    first_name?: StringNullableFilter<"Customer"> | string | null
    middle_name?: StringNullableFilter<"Customer"> | string | null
    last_name?: StringNullableFilter<"Customer"> | string | null
    add1?: StringNullableFilter<"Customer"> | string | null
    add2?: StringNullableFilter<"Customer"> | string | null
    add3?: StringNullableFilter<"Customer"> | string | null
    add4?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    office_phone?: StringNullableFilter<"Customer"> | string | null
    residential_phone?: StringNullableFilter<"Customer"> | string | null
    last_ordered_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    orders?: OrdersListRelationFilter
    measurements?: FinalJacketMeasurementListRelationFilter
    FinalPantMeasurement?: FinalPantMeasurementListRelationFilter
    FinalShirtMeasurement?: FinalShirtMeasurementListRelationFilter
    JacketMeasurement?: JacketMeasurementListRelationFilter
    PantMeasurement?: PantMeasurementListRelationFilter
    ShirtMeasurement?: ShirtMeasurementListRelationFilter
  }, "customer_id">

  export type CustomerOrderByWithAggregationInput = {
    customer_id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    middle_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    add1?: SortOrderInput | SortOrder
    add2?: SortOrderInput | SortOrder
    add3?: SortOrderInput | SortOrder
    add4?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    office_phone?: SortOrderInput | SortOrder
    residential_phone?: SortOrderInput | SortOrder
    last_ordered_date?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    customer_id?: IntWithAggregatesFilter<"Customer"> | number
    first_name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    middle_name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    add1?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    add2?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    add3?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    add4?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    office_phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    residential_phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    last_ordered_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type FabricWhereInput = {
    AND?: FabricWhereInput | FabricWhereInput[]
    OR?: FabricWhereInput[]
    NOT?: FabricWhereInput | FabricWhereInput[]
    fabric_id?: IntFilter<"Fabric"> | number
    description?: StringNullableFilter<"Fabric"> | string | null
    available_length?: DecimalNullableFilter<"Fabric"> | Decimal | DecimalJsLike | number | string | null
    fabric_code?: StringNullableFilter<"Fabric"> | string | null
    fabric_brand?: StringNullableFilter<"Fabric"> | string | null
    stock_location?: StringNullableFilter<"Fabric"> | string | null
    image?: StringNullableFilter<"Fabric"> | string | null
    barcode?: StringNullableFilter<"Fabric"> | string | null
    fabricOrders?: FabricOrderListListRelationFilter
    items?: ItemsListRelationFilter
    liningItems?: ItemsListRelationFilter
  }

  export type FabricOrderByWithRelationInput = {
    fabric_id?: SortOrder
    description?: SortOrderInput | SortOrder
    available_length?: SortOrderInput | SortOrder
    fabric_code?: SortOrderInput | SortOrder
    fabric_brand?: SortOrderInput | SortOrder
    stock_location?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    fabricOrders?: FabricOrderListOrderByRelationAggregateInput
    items?: ItemsOrderByRelationAggregateInput
    liningItems?: ItemsOrderByRelationAggregateInput
  }

  export type FabricWhereUniqueInput = Prisma.AtLeast<{
    fabric_id?: number
    AND?: FabricWhereInput | FabricWhereInput[]
    OR?: FabricWhereInput[]
    NOT?: FabricWhereInput | FabricWhereInput[]
    description?: StringNullableFilter<"Fabric"> | string | null
    available_length?: DecimalNullableFilter<"Fabric"> | Decimal | DecimalJsLike | number | string | null
    fabric_code?: StringNullableFilter<"Fabric"> | string | null
    fabric_brand?: StringNullableFilter<"Fabric"> | string | null
    stock_location?: StringNullableFilter<"Fabric"> | string | null
    image?: StringNullableFilter<"Fabric"> | string | null
    barcode?: StringNullableFilter<"Fabric"> | string | null
    fabricOrders?: FabricOrderListListRelationFilter
    items?: ItemsListRelationFilter
    liningItems?: ItemsListRelationFilter
  }, "fabric_id">

  export type FabricOrderByWithAggregationInput = {
    fabric_id?: SortOrder
    description?: SortOrderInput | SortOrder
    available_length?: SortOrderInput | SortOrder
    fabric_code?: SortOrderInput | SortOrder
    fabric_brand?: SortOrderInput | SortOrder
    stock_location?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    _count?: FabricCountOrderByAggregateInput
    _avg?: FabricAvgOrderByAggregateInput
    _max?: FabricMaxOrderByAggregateInput
    _min?: FabricMinOrderByAggregateInput
    _sum?: FabricSumOrderByAggregateInput
  }

  export type FabricScalarWhereWithAggregatesInput = {
    AND?: FabricScalarWhereWithAggregatesInput | FabricScalarWhereWithAggregatesInput[]
    OR?: FabricScalarWhereWithAggregatesInput[]
    NOT?: FabricScalarWhereWithAggregatesInput | FabricScalarWhereWithAggregatesInput[]
    fabric_id?: IntWithAggregatesFilter<"Fabric"> | number
    description?: StringNullableWithAggregatesFilter<"Fabric"> | string | null
    available_length?: DecimalNullableWithAggregatesFilter<"Fabric"> | Decimal | DecimalJsLike | number | string | null
    fabric_code?: StringNullableWithAggregatesFilter<"Fabric"> | string | null
    fabric_brand?: StringNullableWithAggregatesFilter<"Fabric"> | string | null
    stock_location?: StringNullableWithAggregatesFilter<"Fabric"> | string | null
    image?: StringNullableWithAggregatesFilter<"Fabric"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"Fabric"> | string | null
  }

  export type FabricOrderListWhereInput = {
    AND?: FabricOrderListWhereInput | FabricOrderListWhereInput[]
    OR?: FabricOrderListWhereInput[]
    NOT?: FabricOrderListWhereInput | FabricOrderListWhereInput[]
    order_id?: IntFilter<"FabricOrderList"> | number
    fabric_id?: IntNullableFilter<"FabricOrderList"> | number | null
    description?: StringNullableFilter<"FabricOrderList"> | string | null
    supplier_name?: StringNullableFilter<"FabricOrderList"> | string | null
    meters?: DecimalNullableFilter<"FabricOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableFilter<"FabricOrderList"> | Date | string | null
    ordered_for?: StringNullableFilter<"FabricOrderList"> | string | null
    supplier_id?: IntNullableFilter<"FabricOrderList"> | number | null
    fabric?: XOR<FabricNullableScalarRelationFilter, FabricWhereInput> | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }

  export type FabricOrderListOrderByWithRelationInput = {
    order_id?: SortOrder
    fabric_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    supplier_name?: SortOrderInput | SortOrder
    meters?: SortOrderInput | SortOrder
    ordered_date?: SortOrderInput | SortOrder
    ordered_for?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    fabric?: FabricOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type FabricOrderListWhereUniqueInput = Prisma.AtLeast<{
    order_id?: number
    AND?: FabricOrderListWhereInput | FabricOrderListWhereInput[]
    OR?: FabricOrderListWhereInput[]
    NOT?: FabricOrderListWhereInput | FabricOrderListWhereInput[]
    fabric_id?: IntNullableFilter<"FabricOrderList"> | number | null
    description?: StringNullableFilter<"FabricOrderList"> | string | null
    supplier_name?: StringNullableFilter<"FabricOrderList"> | string | null
    meters?: DecimalNullableFilter<"FabricOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableFilter<"FabricOrderList"> | Date | string | null
    ordered_for?: StringNullableFilter<"FabricOrderList"> | string | null
    supplier_id?: IntNullableFilter<"FabricOrderList"> | number | null
    fabric?: XOR<FabricNullableScalarRelationFilter, FabricWhereInput> | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }, "order_id">

  export type FabricOrderListOrderByWithAggregationInput = {
    order_id?: SortOrder
    fabric_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    supplier_name?: SortOrderInput | SortOrder
    meters?: SortOrderInput | SortOrder
    ordered_date?: SortOrderInput | SortOrder
    ordered_for?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    _count?: FabricOrderListCountOrderByAggregateInput
    _avg?: FabricOrderListAvgOrderByAggregateInput
    _max?: FabricOrderListMaxOrderByAggregateInput
    _min?: FabricOrderListMinOrderByAggregateInput
    _sum?: FabricOrderListSumOrderByAggregateInput
  }

  export type FabricOrderListScalarWhereWithAggregatesInput = {
    AND?: FabricOrderListScalarWhereWithAggregatesInput | FabricOrderListScalarWhereWithAggregatesInput[]
    OR?: FabricOrderListScalarWhereWithAggregatesInput[]
    NOT?: FabricOrderListScalarWhereWithAggregatesInput | FabricOrderListScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"FabricOrderList"> | number
    fabric_id?: IntNullableWithAggregatesFilter<"FabricOrderList"> | number | null
    description?: StringNullableWithAggregatesFilter<"FabricOrderList"> | string | null
    supplier_name?: StringNullableWithAggregatesFilter<"FabricOrderList"> | string | null
    meters?: DecimalNullableWithAggregatesFilter<"FabricOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableWithAggregatesFilter<"FabricOrderList"> | Date | string | null
    ordered_for?: StringNullableWithAggregatesFilter<"FabricOrderList"> | string | null
    supplier_id?: IntNullableWithAggregatesFilter<"FabricOrderList"> | number | null
  }

  export type FinalJacketMeasurementWhereInput = {
    AND?: FinalJacketMeasurementWhereInput | FinalJacketMeasurementWhereInput[]
    OR?: FinalJacketMeasurementWhereInput[]
    NOT?: FinalJacketMeasurementWhereInput | FinalJacketMeasurementWhereInput[]
    measurement_id?: StringFilter<"FinalJacketMeasurement"> | string
    customer_id?: IntNullableFilter<"FinalJacketMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalJacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    natural_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    back_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    x_back?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    chest?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    collar?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    waist_coat_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    sherwani_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }

  export type FinalJacketMeasurementOrderByWithRelationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    jacket_length?: SortOrderInput | SortOrder
    natural_length?: SortOrderInput | SortOrder
    back_length?: SortOrderInput | SortOrder
    x_back?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    waist_coat_length?: SortOrderInput | SortOrder
    sherwani_length?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
    Items?: ItemsOrderByRelationAggregateInput
  }

  export type FinalJacketMeasurementWhereUniqueInput = Prisma.AtLeast<{
    measurement_id?: string
    AND?: FinalJacketMeasurementWhereInput | FinalJacketMeasurementWhereInput[]
    OR?: FinalJacketMeasurementWhereInput[]
    NOT?: FinalJacketMeasurementWhereInput | FinalJacketMeasurementWhereInput[]
    customer_id?: IntNullableFilter<"FinalJacketMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalJacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    natural_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    back_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    x_back?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    chest?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    collar?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    waist_coat_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    sherwani_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }, "measurement_id">

  export type FinalJacketMeasurementOrderByWithAggregationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    jacket_length?: SortOrderInput | SortOrder
    natural_length?: SortOrderInput | SortOrder
    back_length?: SortOrderInput | SortOrder
    x_back?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    waist_coat_length?: SortOrderInput | SortOrder
    sherwani_length?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    _count?: FinalJacketMeasurementCountOrderByAggregateInput
    _avg?: FinalJacketMeasurementAvgOrderByAggregateInput
    _max?: FinalJacketMeasurementMaxOrderByAggregateInput
    _min?: FinalJacketMeasurementMinOrderByAggregateInput
    _sum?: FinalJacketMeasurementSumOrderByAggregateInput
  }

  export type FinalJacketMeasurementScalarWhereWithAggregatesInput = {
    AND?: FinalJacketMeasurementScalarWhereWithAggregatesInput | FinalJacketMeasurementScalarWhereWithAggregatesInput[]
    OR?: FinalJacketMeasurementScalarWhereWithAggregatesInput[]
    NOT?: FinalJacketMeasurementScalarWhereWithAggregatesInput | FinalJacketMeasurementScalarWhereWithAggregatesInput[]
    measurement_id?: StringWithAggregatesFilter<"FinalJacketMeasurement"> | string
    customer_id?: IntNullableWithAggregatesFilter<"FinalJacketMeasurement"> | number | null
    orderNo?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"FinalJacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    natural_length?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    back_length?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    x_back?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    half_shoulder?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    to_sleeve?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    chest?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    waist?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    collar?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    waist_coat_length?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    sherwani_length?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
    other_notes?: StringNullableWithAggregatesFilter<"FinalJacketMeasurement"> | string | null
  }

  export type JacketMeasurementWhereInput = {
    AND?: JacketMeasurementWhereInput | JacketMeasurementWhereInput[]
    OR?: JacketMeasurementWhereInput[]
    NOT?: JacketMeasurementWhereInput | JacketMeasurementWhereInput[]
    measurement_id?: StringFilter<"JacketMeasurement"> | string
    customer_id?: IntNullableFilter<"JacketMeasurement"> | number | null
    orderNo?: StringNullableFilter<"JacketMeasurement"> | string | null
    date?: DateTimeNullableFilter<"JacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    natural_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    back_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    x_back?: StringNullableFilter<"JacketMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"JacketMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"JacketMeasurement"> | string | null
    chest?: StringNullableFilter<"JacketMeasurement"> | string | null
    waist?: StringNullableFilter<"JacketMeasurement"> | string | null
    collar?: StringNullableFilter<"JacketMeasurement"> | string | null
    waist_coat_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    sherwani_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    other_notes?: StringNullableFilter<"JacketMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }

  export type JacketMeasurementOrderByWithRelationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    jacket_length?: SortOrderInput | SortOrder
    natural_length?: SortOrderInput | SortOrder
    back_length?: SortOrderInput | SortOrder
    x_back?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    waist_coat_length?: SortOrderInput | SortOrder
    sherwani_length?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
    Items?: ItemsOrderByRelationAggregateInput
  }

  export type JacketMeasurementWhereUniqueInput = Prisma.AtLeast<{
    measurement_id?: string
    AND?: JacketMeasurementWhereInput | JacketMeasurementWhereInput[]
    OR?: JacketMeasurementWhereInput[]
    NOT?: JacketMeasurementWhereInput | JacketMeasurementWhereInput[]
    customer_id?: IntNullableFilter<"JacketMeasurement"> | number | null
    orderNo?: StringNullableFilter<"JacketMeasurement"> | string | null
    date?: DateTimeNullableFilter<"JacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    natural_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    back_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    x_back?: StringNullableFilter<"JacketMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"JacketMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"JacketMeasurement"> | string | null
    chest?: StringNullableFilter<"JacketMeasurement"> | string | null
    waist?: StringNullableFilter<"JacketMeasurement"> | string | null
    collar?: StringNullableFilter<"JacketMeasurement"> | string | null
    waist_coat_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    sherwani_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    other_notes?: StringNullableFilter<"JacketMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }, "measurement_id">

  export type JacketMeasurementOrderByWithAggregationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    jacket_length?: SortOrderInput | SortOrder
    natural_length?: SortOrderInput | SortOrder
    back_length?: SortOrderInput | SortOrder
    x_back?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    waist_coat_length?: SortOrderInput | SortOrder
    sherwani_length?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    _count?: JacketMeasurementCountOrderByAggregateInput
    _avg?: JacketMeasurementAvgOrderByAggregateInput
    _max?: JacketMeasurementMaxOrderByAggregateInput
    _min?: JacketMeasurementMinOrderByAggregateInput
    _sum?: JacketMeasurementSumOrderByAggregateInput
  }

  export type JacketMeasurementScalarWhereWithAggregatesInput = {
    AND?: JacketMeasurementScalarWhereWithAggregatesInput | JacketMeasurementScalarWhereWithAggregatesInput[]
    OR?: JacketMeasurementScalarWhereWithAggregatesInput[]
    NOT?: JacketMeasurementScalarWhereWithAggregatesInput | JacketMeasurementScalarWhereWithAggregatesInput[]
    measurement_id?: StringWithAggregatesFilter<"JacketMeasurement"> | string
    customer_id?: IntNullableWithAggregatesFilter<"JacketMeasurement"> | number | null
    orderNo?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"JacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    natural_length?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    back_length?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    x_back?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    half_shoulder?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    to_sleeve?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    chest?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    waist?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    collar?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    waist_coat_length?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    sherwani_length?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
    other_notes?: StringNullableWithAggregatesFilter<"JacketMeasurement"> | string | null
  }

  export type FinalPantMeasurementWhereInput = {
    AND?: FinalPantMeasurementWhereInput | FinalPantMeasurementWhereInput[]
    OR?: FinalPantMeasurementWhereInput[]
    NOT?: FinalPantMeasurementWhereInput | FinalPantMeasurementWhereInput[]
    measurement_id?: StringFilter<"FinalPantMeasurement"> | string
    customer_id?: IntNullableFilter<"FinalPantMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalPantMeasurement"> | Date | string | null
    length?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    inseem?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    hips?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    bottom?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    knee?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }

  export type FinalPantMeasurementOrderByWithRelationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    inseem?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    hips?: SortOrderInput | SortOrder
    bottom?: SortOrderInput | SortOrder
    knee?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
    Items?: ItemsOrderByRelationAggregateInput
  }

  export type FinalPantMeasurementWhereUniqueInput = Prisma.AtLeast<{
    measurement_id?: string
    AND?: FinalPantMeasurementWhereInput | FinalPantMeasurementWhereInput[]
    OR?: FinalPantMeasurementWhereInput[]
    NOT?: FinalPantMeasurementWhereInput | FinalPantMeasurementWhereInput[]
    customer_id?: IntNullableFilter<"FinalPantMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalPantMeasurement"> | Date | string | null
    length?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    inseem?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    hips?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    bottom?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    knee?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }, "measurement_id">

  export type FinalPantMeasurementOrderByWithAggregationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    inseem?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    hips?: SortOrderInput | SortOrder
    bottom?: SortOrderInput | SortOrder
    knee?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    _count?: FinalPantMeasurementCountOrderByAggregateInput
    _avg?: FinalPantMeasurementAvgOrderByAggregateInput
    _max?: FinalPantMeasurementMaxOrderByAggregateInput
    _min?: FinalPantMeasurementMinOrderByAggregateInput
    _sum?: FinalPantMeasurementSumOrderByAggregateInput
  }

  export type FinalPantMeasurementScalarWhereWithAggregatesInput = {
    AND?: FinalPantMeasurementScalarWhereWithAggregatesInput | FinalPantMeasurementScalarWhereWithAggregatesInput[]
    OR?: FinalPantMeasurementScalarWhereWithAggregatesInput[]
    NOT?: FinalPantMeasurementScalarWhereWithAggregatesInput | FinalPantMeasurementScalarWhereWithAggregatesInput[]
    measurement_id?: StringWithAggregatesFilter<"FinalPantMeasurement"> | string
    customer_id?: IntNullableWithAggregatesFilter<"FinalPantMeasurement"> | number | null
    orderNo?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"FinalPantMeasurement"> | Date | string | null
    length?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    inseem?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    waist?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    hips?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    bottom?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    knee?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
    other_notes?: StringNullableWithAggregatesFilter<"FinalPantMeasurement"> | string | null
  }

  export type PantMeasurementWhereInput = {
    AND?: PantMeasurementWhereInput | PantMeasurementWhereInput[]
    OR?: PantMeasurementWhereInput[]
    NOT?: PantMeasurementWhereInput | PantMeasurementWhereInput[]
    measurement_id?: StringFilter<"PantMeasurement"> | string
    customer_id?: IntNullableFilter<"PantMeasurement"> | number | null
    orderNo?: StringNullableFilter<"PantMeasurement"> | string | null
    date?: DateTimeNullableFilter<"PantMeasurement"> | Date | string | null
    length?: StringNullableFilter<"PantMeasurement"> | string | null
    inseem?: StringNullableFilter<"PantMeasurement"> | string | null
    waist?: StringNullableFilter<"PantMeasurement"> | string | null
    hips?: StringNullableFilter<"PantMeasurement"> | string | null
    bottom?: StringNullableFilter<"PantMeasurement"> | string | null
    knee?: StringNullableFilter<"PantMeasurement"> | string | null
    other_notes?: StringNullableFilter<"PantMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }

  export type PantMeasurementOrderByWithRelationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    inseem?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    hips?: SortOrderInput | SortOrder
    bottom?: SortOrderInput | SortOrder
    knee?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
    Items?: ItemsOrderByRelationAggregateInput
  }

  export type PantMeasurementWhereUniqueInput = Prisma.AtLeast<{
    measurement_id?: string
    AND?: PantMeasurementWhereInput | PantMeasurementWhereInput[]
    OR?: PantMeasurementWhereInput[]
    NOT?: PantMeasurementWhereInput | PantMeasurementWhereInput[]
    customer_id?: IntNullableFilter<"PantMeasurement"> | number | null
    orderNo?: StringNullableFilter<"PantMeasurement"> | string | null
    date?: DateTimeNullableFilter<"PantMeasurement"> | Date | string | null
    length?: StringNullableFilter<"PantMeasurement"> | string | null
    inseem?: StringNullableFilter<"PantMeasurement"> | string | null
    waist?: StringNullableFilter<"PantMeasurement"> | string | null
    hips?: StringNullableFilter<"PantMeasurement"> | string | null
    bottom?: StringNullableFilter<"PantMeasurement"> | string | null
    knee?: StringNullableFilter<"PantMeasurement"> | string | null
    other_notes?: StringNullableFilter<"PantMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }, "measurement_id">

  export type PantMeasurementOrderByWithAggregationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    inseem?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    hips?: SortOrderInput | SortOrder
    bottom?: SortOrderInput | SortOrder
    knee?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    _count?: PantMeasurementCountOrderByAggregateInput
    _avg?: PantMeasurementAvgOrderByAggregateInput
    _max?: PantMeasurementMaxOrderByAggregateInput
    _min?: PantMeasurementMinOrderByAggregateInput
    _sum?: PantMeasurementSumOrderByAggregateInput
  }

  export type PantMeasurementScalarWhereWithAggregatesInput = {
    AND?: PantMeasurementScalarWhereWithAggregatesInput | PantMeasurementScalarWhereWithAggregatesInput[]
    OR?: PantMeasurementScalarWhereWithAggregatesInput[]
    NOT?: PantMeasurementScalarWhereWithAggregatesInput | PantMeasurementScalarWhereWithAggregatesInput[]
    measurement_id?: StringWithAggregatesFilter<"PantMeasurement"> | string
    customer_id?: IntNullableWithAggregatesFilter<"PantMeasurement"> | number | null
    orderNo?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"PantMeasurement"> | Date | string | null
    length?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    inseem?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    waist?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    hips?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    bottom?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    knee?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
    other_notes?: StringNullableWithAggregatesFilter<"PantMeasurement"> | string | null
  }

  export type FinalShirtMeasurementWhereInput = {
    AND?: FinalShirtMeasurementWhereInput | FinalShirtMeasurementWhereInput[]
    OR?: FinalShirtMeasurementWhereInput[]
    NOT?: FinalShirtMeasurementWhereInput | FinalShirtMeasurementWhereInput[]
    measurement_id?: StringFilter<"FinalShirtMeasurement"> | string
    customer_id?: IntNullableFilter<"FinalShirtMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalShirtMeasurement"> | Date | string | null
    length?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    chest?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    collar?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }

  export type FinalShirtMeasurementOrderByWithRelationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
    Items?: ItemsOrderByRelationAggregateInput
  }

  export type FinalShirtMeasurementWhereUniqueInput = Prisma.AtLeast<{
    measurement_id?: string
    AND?: FinalShirtMeasurementWhereInput | FinalShirtMeasurementWhereInput[]
    OR?: FinalShirtMeasurementWhereInput[]
    NOT?: FinalShirtMeasurementWhereInput | FinalShirtMeasurementWhereInput[]
    customer_id?: IntNullableFilter<"FinalShirtMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalShirtMeasurement"> | Date | string | null
    length?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    chest?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    collar?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }, "measurement_id">

  export type FinalShirtMeasurementOrderByWithAggregationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    _count?: FinalShirtMeasurementCountOrderByAggregateInput
    _avg?: FinalShirtMeasurementAvgOrderByAggregateInput
    _max?: FinalShirtMeasurementMaxOrderByAggregateInput
    _min?: FinalShirtMeasurementMinOrderByAggregateInput
    _sum?: FinalShirtMeasurementSumOrderByAggregateInput
  }

  export type FinalShirtMeasurementScalarWhereWithAggregatesInput = {
    AND?: FinalShirtMeasurementScalarWhereWithAggregatesInput | FinalShirtMeasurementScalarWhereWithAggregatesInput[]
    OR?: FinalShirtMeasurementScalarWhereWithAggregatesInput[]
    NOT?: FinalShirtMeasurementScalarWhereWithAggregatesInput | FinalShirtMeasurementScalarWhereWithAggregatesInput[]
    measurement_id?: StringWithAggregatesFilter<"FinalShirtMeasurement"> | string
    customer_id?: IntNullableWithAggregatesFilter<"FinalShirtMeasurement"> | number | null
    orderNo?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"FinalShirtMeasurement"> | Date | string | null
    length?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    half_shoulder?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    to_sleeve?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    chest?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    waist?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    collar?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
    other_notes?: StringNullableWithAggregatesFilter<"FinalShirtMeasurement"> | string | null
  }

  export type ShirtMeasurementWhereInput = {
    AND?: ShirtMeasurementWhereInput | ShirtMeasurementWhereInput[]
    OR?: ShirtMeasurementWhereInput[]
    NOT?: ShirtMeasurementWhereInput | ShirtMeasurementWhereInput[]
    measurement_id?: StringFilter<"ShirtMeasurement"> | string
    customer_id?: IntNullableFilter<"ShirtMeasurement"> | number | null
    orderNo?: StringNullableFilter<"ShirtMeasurement"> | string | null
    date?: DateTimeNullableFilter<"ShirtMeasurement"> | Date | string | null
    length?: StringNullableFilter<"ShirtMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"ShirtMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"ShirtMeasurement"> | string | null
    chest?: StringNullableFilter<"ShirtMeasurement"> | string | null
    waist?: StringNullableFilter<"ShirtMeasurement"> | string | null
    collar?: StringNullableFilter<"ShirtMeasurement"> | string | null
    other_notes?: StringNullableFilter<"ShirtMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }

  export type ShirtMeasurementOrderByWithRelationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: OrdersOrderByWithRelationInput
    Items?: ItemsOrderByRelationAggregateInput
  }

  export type ShirtMeasurementWhereUniqueInput = Prisma.AtLeast<{
    measurement_id?: string
    AND?: ShirtMeasurementWhereInput | ShirtMeasurementWhereInput[]
    OR?: ShirtMeasurementWhereInput[]
    NOT?: ShirtMeasurementWhereInput | ShirtMeasurementWhereInput[]
    customer_id?: IntNullableFilter<"ShirtMeasurement"> | number | null
    orderNo?: StringNullableFilter<"ShirtMeasurement"> | string | null
    date?: DateTimeNullableFilter<"ShirtMeasurement"> | Date | string | null
    length?: StringNullableFilter<"ShirtMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"ShirtMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"ShirtMeasurement"> | string | null
    chest?: StringNullableFilter<"ShirtMeasurement"> | string | null
    waist?: StringNullableFilter<"ShirtMeasurement"> | string | null
    collar?: StringNullableFilter<"ShirtMeasurement"> | string | null
    other_notes?: StringNullableFilter<"ShirtMeasurement"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    Items?: ItemsListRelationFilter
  }, "measurement_id">

  export type ShirtMeasurementOrderByWithAggregationInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    orderNo?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    half_shoulder?: SortOrderInput | SortOrder
    to_sleeve?: SortOrderInput | SortOrder
    chest?: SortOrderInput | SortOrder
    waist?: SortOrderInput | SortOrder
    collar?: SortOrderInput | SortOrder
    other_notes?: SortOrderInput | SortOrder
    _count?: ShirtMeasurementCountOrderByAggregateInput
    _avg?: ShirtMeasurementAvgOrderByAggregateInput
    _max?: ShirtMeasurementMaxOrderByAggregateInput
    _min?: ShirtMeasurementMinOrderByAggregateInput
    _sum?: ShirtMeasurementSumOrderByAggregateInput
  }

  export type ShirtMeasurementScalarWhereWithAggregatesInput = {
    AND?: ShirtMeasurementScalarWhereWithAggregatesInput | ShirtMeasurementScalarWhereWithAggregatesInput[]
    OR?: ShirtMeasurementScalarWhereWithAggregatesInput[]
    NOT?: ShirtMeasurementScalarWhereWithAggregatesInput | ShirtMeasurementScalarWhereWithAggregatesInput[]
    measurement_id?: StringWithAggregatesFilter<"ShirtMeasurement"> | string
    customer_id?: IntNullableWithAggregatesFilter<"ShirtMeasurement"> | number | null
    orderNo?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"ShirtMeasurement"> | Date | string | null
    length?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    half_shoulder?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    to_sleeve?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    chest?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    waist?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    collar?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
    other_notes?: StringNullableWithAggregatesFilter<"ShirtMeasurement"> | string | null
  }

  export type OrderPhotosWhereInput = {
    AND?: OrderPhotosWhereInput | OrderPhotosWhereInput[]
    OR?: OrderPhotosWhereInput[]
    NOT?: OrderPhotosWhereInput | OrderPhotosWhereInput[]
    photo_id?: IntFilter<"OrderPhotos"> | number
    orderNo?: StringNullableFilter<"OrderPhotos"> | string | null
    s3_key?: StringNullableFilter<"OrderPhotos"> | string | null
    uploaded_at?: DateTimeFilter<"OrderPhotos"> | Date | string
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
  }

  export type OrderPhotosOrderByWithRelationInput = {
    photo_id?: SortOrder
    orderNo?: SortOrderInput | SortOrder
    s3_key?: SortOrderInput | SortOrder
    uploaded_at?: SortOrder
    order?: OrdersOrderByWithRelationInput
  }

  export type OrderPhotosWhereUniqueInput = Prisma.AtLeast<{
    photo_id?: number
    AND?: OrderPhotosWhereInput | OrderPhotosWhereInput[]
    OR?: OrderPhotosWhereInput[]
    NOT?: OrderPhotosWhereInput | OrderPhotosWhereInput[]
    orderNo?: StringNullableFilter<"OrderPhotos"> | string | null
    s3_key?: StringNullableFilter<"OrderPhotos"> | string | null
    uploaded_at?: DateTimeFilter<"OrderPhotos"> | Date | string
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
  }, "photo_id">

  export type OrderPhotosOrderByWithAggregationInput = {
    photo_id?: SortOrder
    orderNo?: SortOrderInput | SortOrder
    s3_key?: SortOrderInput | SortOrder
    uploaded_at?: SortOrder
    _count?: OrderPhotosCountOrderByAggregateInput
    _avg?: OrderPhotosAvgOrderByAggregateInput
    _max?: OrderPhotosMaxOrderByAggregateInput
    _min?: OrderPhotosMinOrderByAggregateInput
    _sum?: OrderPhotosSumOrderByAggregateInput
  }

  export type OrderPhotosScalarWhereWithAggregatesInput = {
    AND?: OrderPhotosScalarWhereWithAggregatesInput | OrderPhotosScalarWhereWithAggregatesInput[]
    OR?: OrderPhotosScalarWhereWithAggregatesInput[]
    NOT?: OrderPhotosScalarWhereWithAggregatesInput | OrderPhotosScalarWhereWithAggregatesInput[]
    photo_id?: IntWithAggregatesFilter<"OrderPhotos"> | number
    orderNo?: StringNullableWithAggregatesFilter<"OrderPhotos"> | string | null
    s3_key?: StringNullableWithAggregatesFilter<"OrderPhotos"> | string | null
    uploaded_at?: DateTimeWithAggregatesFilter<"OrderPhotos"> | Date | string
  }

  export type OrdersWhereInput = {
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    orderNo?: StringFilter<"Orders"> | string
    customer_id?: IntNullableFilter<"Orders"> | number | null
    date?: DateTimeNullableFilter<"Orders"> | Date | string | null
    onote?: StringNullableFilter<"Orders"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: ItemsListRelationFilter
    FinalJacketMeasurement?: FinalJacketMeasurementListRelationFilter
    FinalPantMeasurement?: FinalPantMeasurementListRelationFilter
    FinalShirtMeasurement?: FinalShirtMeasurementListRelationFilter
    JacketMeasurement?: JacketMeasurementListRelationFilter
    PantMeasurement?: PantMeasurementListRelationFilter
    ShirtMeasurement?: ShirtMeasurementListRelationFilter
    OrderPhotos?: OrderPhotosListRelationFilter
    tailors?: OrderTailorListRelationFilter
    production?: XOR<OrderProductionNullableScalarRelationFilter, OrderProductionWhereInput> | null
  }

  export type OrdersOrderByWithRelationInput = {
    orderNo?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    onote?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: ItemsOrderByRelationAggregateInput
    FinalJacketMeasurement?: FinalJacketMeasurementOrderByRelationAggregateInput
    FinalPantMeasurement?: FinalPantMeasurementOrderByRelationAggregateInput
    FinalShirtMeasurement?: FinalShirtMeasurementOrderByRelationAggregateInput
    JacketMeasurement?: JacketMeasurementOrderByRelationAggregateInput
    PantMeasurement?: PantMeasurementOrderByRelationAggregateInput
    ShirtMeasurement?: ShirtMeasurementOrderByRelationAggregateInput
    OrderPhotos?: OrderPhotosOrderByRelationAggregateInput
    tailors?: OrderTailorOrderByRelationAggregateInput
    production?: OrderProductionOrderByWithRelationInput
  }

  export type OrdersWhereUniqueInput = Prisma.AtLeast<{
    orderNo?: string
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    customer_id?: IntNullableFilter<"Orders"> | number | null
    date?: DateTimeNullableFilter<"Orders"> | Date | string | null
    onote?: StringNullableFilter<"Orders"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: ItemsListRelationFilter
    FinalJacketMeasurement?: FinalJacketMeasurementListRelationFilter
    FinalPantMeasurement?: FinalPantMeasurementListRelationFilter
    FinalShirtMeasurement?: FinalShirtMeasurementListRelationFilter
    JacketMeasurement?: JacketMeasurementListRelationFilter
    PantMeasurement?: PantMeasurementListRelationFilter
    ShirtMeasurement?: ShirtMeasurementListRelationFilter
    OrderPhotos?: OrderPhotosListRelationFilter
    tailors?: OrderTailorListRelationFilter
    production?: XOR<OrderProductionNullableScalarRelationFilter, OrderProductionWhereInput> | null
  }, "orderNo">

  export type OrdersOrderByWithAggregationInput = {
    orderNo?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    onote?: SortOrderInput | SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    OR?: OrdersScalarWhereWithAggregatesInput[]
    NOT?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    orderNo?: StringWithAggregatesFilter<"Orders"> | string
    customer_id?: IntNullableWithAggregatesFilter<"Orders"> | number | null
    date?: DateTimeNullableWithAggregatesFilter<"Orders"> | Date | string | null
    onote?: StringNullableWithAggregatesFilter<"Orders"> | string | null
  }

  export type ItemsWhereInput = {
    AND?: ItemsWhereInput | ItemsWhereInput[]
    OR?: ItemsWhereInput[]
    NOT?: ItemsWhereInput | ItemsWhereInput[]
    item_id?: IntFilter<"Items"> | number
    orderNo?: StringNullableFilter<"Items"> | string | null
    item_name?: StringNullableFilter<"Items"> | string | null
    item_type?: EnumItemTypeNullableFilter<"Items"> | $Enums.ItemType | null
    fabric_id?: IntNullableFilter<"Items"> | number | null
    lining_fabric_id?: IntNullableFilter<"Items"> | number | null
    jacket_measurement_id?: StringNullableFilter<"Items"> | string | null
    shirt_measurement_id?: StringNullableFilter<"Items"> | string | null
    pant_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_jacket_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_shirt_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_pant_measurement_id?: StringNullableFilter<"Items"> | string | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    fabric?: XOR<FabricNullableScalarRelationFilter, FabricWhereInput> | null
    lining_fabric?: XOR<FabricNullableScalarRelationFilter, FabricWhereInput> | null
    jacket_measurement?: XOR<JacketMeasurementNullableScalarRelationFilter, JacketMeasurementWhereInput> | null
    shirt_measurement?: XOR<ShirtMeasurementNullableScalarRelationFilter, ShirtMeasurementWhereInput> | null
    pant_measurement?: XOR<PantMeasurementNullableScalarRelationFilter, PantMeasurementWhereInput> | null
    final_jacket_measurement?: XOR<FinalJacketMeasurementNullableScalarRelationFilter, FinalJacketMeasurementWhereInput> | null
    final_shirt_measurement?: XOR<FinalShirtMeasurementNullableScalarRelationFilter, FinalShirtMeasurementWhereInput> | null
    final_pant_measurement?: XOR<FinalPantMeasurementNullableScalarRelationFilter, FinalPantMeasurementWhereInput> | null
  }

  export type ItemsOrderByWithRelationInput = {
    item_id?: SortOrder
    orderNo?: SortOrderInput | SortOrder
    item_name?: SortOrderInput | SortOrder
    item_type?: SortOrderInput | SortOrder
    fabric_id?: SortOrderInput | SortOrder
    lining_fabric_id?: SortOrderInput | SortOrder
    jacket_measurement_id?: SortOrderInput | SortOrder
    shirt_measurement_id?: SortOrderInput | SortOrder
    pant_measurement_id?: SortOrderInput | SortOrder
    final_jacket_measurement_id?: SortOrderInput | SortOrder
    final_shirt_measurement_id?: SortOrderInput | SortOrder
    final_pant_measurement_id?: SortOrderInput | SortOrder
    order?: OrdersOrderByWithRelationInput
    fabric?: FabricOrderByWithRelationInput
    lining_fabric?: FabricOrderByWithRelationInput
    jacket_measurement?: JacketMeasurementOrderByWithRelationInput
    shirt_measurement?: ShirtMeasurementOrderByWithRelationInput
    pant_measurement?: PantMeasurementOrderByWithRelationInput
    final_jacket_measurement?: FinalJacketMeasurementOrderByWithRelationInput
    final_shirt_measurement?: FinalShirtMeasurementOrderByWithRelationInput
    final_pant_measurement?: FinalPantMeasurementOrderByWithRelationInput
  }

  export type ItemsWhereUniqueInput = Prisma.AtLeast<{
    item_id?: number
    AND?: ItemsWhereInput | ItemsWhereInput[]
    OR?: ItemsWhereInput[]
    NOT?: ItemsWhereInput | ItemsWhereInput[]
    orderNo?: StringNullableFilter<"Items"> | string | null
    item_name?: StringNullableFilter<"Items"> | string | null
    item_type?: EnumItemTypeNullableFilter<"Items"> | $Enums.ItemType | null
    fabric_id?: IntNullableFilter<"Items"> | number | null
    lining_fabric_id?: IntNullableFilter<"Items"> | number | null
    jacket_measurement_id?: StringNullableFilter<"Items"> | string | null
    shirt_measurement_id?: StringNullableFilter<"Items"> | string | null
    pant_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_jacket_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_shirt_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_pant_measurement_id?: StringNullableFilter<"Items"> | string | null
    order?: XOR<OrdersNullableScalarRelationFilter, OrdersWhereInput> | null
    fabric?: XOR<FabricNullableScalarRelationFilter, FabricWhereInput> | null
    lining_fabric?: XOR<FabricNullableScalarRelationFilter, FabricWhereInput> | null
    jacket_measurement?: XOR<JacketMeasurementNullableScalarRelationFilter, JacketMeasurementWhereInput> | null
    shirt_measurement?: XOR<ShirtMeasurementNullableScalarRelationFilter, ShirtMeasurementWhereInput> | null
    pant_measurement?: XOR<PantMeasurementNullableScalarRelationFilter, PantMeasurementWhereInput> | null
    final_jacket_measurement?: XOR<FinalJacketMeasurementNullableScalarRelationFilter, FinalJacketMeasurementWhereInput> | null
    final_shirt_measurement?: XOR<FinalShirtMeasurementNullableScalarRelationFilter, FinalShirtMeasurementWhereInput> | null
    final_pant_measurement?: XOR<FinalPantMeasurementNullableScalarRelationFilter, FinalPantMeasurementWhereInput> | null
  }, "item_id">

  export type ItemsOrderByWithAggregationInput = {
    item_id?: SortOrder
    orderNo?: SortOrderInput | SortOrder
    item_name?: SortOrderInput | SortOrder
    item_type?: SortOrderInput | SortOrder
    fabric_id?: SortOrderInput | SortOrder
    lining_fabric_id?: SortOrderInput | SortOrder
    jacket_measurement_id?: SortOrderInput | SortOrder
    shirt_measurement_id?: SortOrderInput | SortOrder
    pant_measurement_id?: SortOrderInput | SortOrder
    final_jacket_measurement_id?: SortOrderInput | SortOrder
    final_shirt_measurement_id?: SortOrderInput | SortOrder
    final_pant_measurement_id?: SortOrderInput | SortOrder
    _count?: ItemsCountOrderByAggregateInput
    _avg?: ItemsAvgOrderByAggregateInput
    _max?: ItemsMaxOrderByAggregateInput
    _min?: ItemsMinOrderByAggregateInput
    _sum?: ItemsSumOrderByAggregateInput
  }

  export type ItemsScalarWhereWithAggregatesInput = {
    AND?: ItemsScalarWhereWithAggregatesInput | ItemsScalarWhereWithAggregatesInput[]
    OR?: ItemsScalarWhereWithAggregatesInput[]
    NOT?: ItemsScalarWhereWithAggregatesInput | ItemsScalarWhereWithAggregatesInput[]
    item_id?: IntWithAggregatesFilter<"Items"> | number
    orderNo?: StringNullableWithAggregatesFilter<"Items"> | string | null
    item_name?: StringNullableWithAggregatesFilter<"Items"> | string | null
    item_type?: EnumItemTypeNullableWithAggregatesFilter<"Items"> | $Enums.ItemType | null
    fabric_id?: IntNullableWithAggregatesFilter<"Items"> | number | null
    lining_fabric_id?: IntNullableWithAggregatesFilter<"Items"> | number | null
    jacket_measurement_id?: StringNullableWithAggregatesFilter<"Items"> | string | null
    shirt_measurement_id?: StringNullableWithAggregatesFilter<"Items"> | string | null
    pant_measurement_id?: StringNullableWithAggregatesFilter<"Items"> | string | null
    final_jacket_measurement_id?: StringNullableWithAggregatesFilter<"Items"> | string | null
    final_shirt_measurement_id?: StringNullableWithAggregatesFilter<"Items"> | string | null
    final_pant_measurement_id?: StringNullableWithAggregatesFilter<"Items"> | string | null
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    supplier_id?: IntFilter<"Supplier"> | number
    supplier_name?: StringFilter<"Supplier"> | string
    add1?: StringNullableFilter<"Supplier"> | string | null
    add2?: StringNullableFilter<"Supplier"> | string | null
    add3?: StringNullableFilter<"Supplier"> | string | null
    phone_number1?: StringNullableFilter<"Supplier"> | string | null
    phone_number2?: StringNullableFilter<"Supplier"> | string | null
    phone_number3?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    primary_contact_name1?: StringNullableFilter<"Supplier"> | string | null
    primary_contact_name2?: StringNullableFilter<"Supplier"> | string | null
    primary_contact_name3?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    FabricOrderList?: FabricOrderListListRelationFilter
    RawMaterialsOrderList?: RawMaterialsOrderListListRelationFilter
    ItemSupplier?: ItemSupplierListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    add1?: SortOrderInput | SortOrder
    add2?: SortOrderInput | SortOrder
    add3?: SortOrderInput | SortOrder
    phone_number1?: SortOrderInput | SortOrder
    phone_number2?: SortOrderInput | SortOrder
    phone_number3?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    primary_contact_name1?: SortOrderInput | SortOrder
    primary_contact_name2?: SortOrderInput | SortOrder
    primary_contact_name3?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    FabricOrderList?: FabricOrderListOrderByRelationAggregateInput
    RawMaterialsOrderList?: RawMaterialsOrderListOrderByRelationAggregateInput
    ItemSupplier?: ItemSupplierOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    supplier_id?: number
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    supplier_name?: StringFilter<"Supplier"> | string
    add1?: StringNullableFilter<"Supplier"> | string | null
    add2?: StringNullableFilter<"Supplier"> | string | null
    add3?: StringNullableFilter<"Supplier"> | string | null
    phone_number1?: StringNullableFilter<"Supplier"> | string | null
    phone_number2?: StringNullableFilter<"Supplier"> | string | null
    phone_number3?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    primary_contact_name1?: StringNullableFilter<"Supplier"> | string | null
    primary_contact_name2?: StringNullableFilter<"Supplier"> | string | null
    primary_contact_name3?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    FabricOrderList?: FabricOrderListListRelationFilter
    RawMaterialsOrderList?: RawMaterialsOrderListListRelationFilter
    ItemSupplier?: ItemSupplierListRelationFilter
  }, "supplier_id">

  export type SupplierOrderByWithAggregationInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    add1?: SortOrderInput | SortOrder
    add2?: SortOrderInput | SortOrder
    add3?: SortOrderInput | SortOrder
    phone_number1?: SortOrderInput | SortOrder
    phone_number2?: SortOrderInput | SortOrder
    phone_number3?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    primary_contact_name1?: SortOrderInput | SortOrder
    primary_contact_name2?: SortOrderInput | SortOrder
    primary_contact_name3?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    supplier_id?: IntWithAggregatesFilter<"Supplier"> | number
    supplier_name?: StringWithAggregatesFilter<"Supplier"> | string
    add1?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    add2?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    add3?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone_number1?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone_number2?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone_number3?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    primary_contact_name1?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    primary_contact_name2?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    primary_contact_name3?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
  }

  export type TailorWhereInput = {
    AND?: TailorWhereInput | TailorWhereInput[]
    OR?: TailorWhereInput[]
    NOT?: TailorWhereInput | TailorWhereInput[]
    tailor_id?: IntFilter<"Tailor"> | number
    first_name?: StringFilter<"Tailor"> | string
    last_name?: StringNullableFilter<"Tailor"> | string | null
    specialization?: StringNullableFilter<"Tailor"> | string | null
    experience_years?: IntNullableFilter<"Tailor"> | number | null
    joining_date?: DateTimeFilter<"Tailor"> | Date | string
    address?: StringNullableFilter<"Tailor"> | string | null
    phone_number?: StringNullableFilter<"Tailor"> | string | null
    email?: StringNullableFilter<"Tailor"> | string | null
    emergency_contact?: StringNullableFilter<"Tailor"> | string | null
    status?: StringFilter<"Tailor"> | string
    hourly_rate?: DecimalNullableFilter<"Tailor"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Tailor"> | string | null
    orders?: OrderTailorListRelationFilter
  }

  export type TailorOrderByWithRelationInput = {
    tailor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    experience_years?: SortOrderInput | SortOrder
    joining_date?: SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    status?: SortOrder
    hourly_rate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    orders?: OrderTailorOrderByRelationAggregateInput
  }

  export type TailorWhereUniqueInput = Prisma.AtLeast<{
    tailor_id?: number
    email?: string
    AND?: TailorWhereInput | TailorWhereInput[]
    OR?: TailorWhereInput[]
    NOT?: TailorWhereInput | TailorWhereInput[]
    first_name?: StringFilter<"Tailor"> | string
    last_name?: StringNullableFilter<"Tailor"> | string | null
    specialization?: StringNullableFilter<"Tailor"> | string | null
    experience_years?: IntNullableFilter<"Tailor"> | number | null
    joining_date?: DateTimeFilter<"Tailor"> | Date | string
    address?: StringNullableFilter<"Tailor"> | string | null
    phone_number?: StringNullableFilter<"Tailor"> | string | null
    emergency_contact?: StringNullableFilter<"Tailor"> | string | null
    status?: StringFilter<"Tailor"> | string
    hourly_rate?: DecimalNullableFilter<"Tailor"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Tailor"> | string | null
    orders?: OrderTailorListRelationFilter
  }, "tailor_id" | "email">

  export type TailorOrderByWithAggregationInput = {
    tailor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    experience_years?: SortOrderInput | SortOrder
    joining_date?: SortOrder
    address?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    status?: SortOrder
    hourly_rate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: TailorCountOrderByAggregateInput
    _avg?: TailorAvgOrderByAggregateInput
    _max?: TailorMaxOrderByAggregateInput
    _min?: TailorMinOrderByAggregateInput
    _sum?: TailorSumOrderByAggregateInput
  }

  export type TailorScalarWhereWithAggregatesInput = {
    AND?: TailorScalarWhereWithAggregatesInput | TailorScalarWhereWithAggregatesInput[]
    OR?: TailorScalarWhereWithAggregatesInput[]
    NOT?: TailorScalarWhereWithAggregatesInput | TailorScalarWhereWithAggregatesInput[]
    tailor_id?: IntWithAggregatesFilter<"Tailor"> | number
    first_name?: StringWithAggregatesFilter<"Tailor"> | string
    last_name?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
    specialization?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
    experience_years?: IntNullableWithAggregatesFilter<"Tailor"> | number | null
    joining_date?: DateTimeWithAggregatesFilter<"Tailor"> | Date | string
    address?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
    emergency_contact?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
    status?: StringWithAggregatesFilter<"Tailor"> | string
    hourly_rate?: DecimalNullableWithAggregatesFilter<"Tailor"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Tailor"> | string | null
  }

  export type OrderTailorWhereInput = {
    AND?: OrderTailorWhereInput | OrderTailorWhereInput[]
    OR?: OrderTailorWhereInput[]
    NOT?: OrderTailorWhereInput | OrderTailorWhereInput[]
    id?: IntFilter<"OrderTailor"> | number
    orderNo?: StringFilter<"OrderTailor"> | string
    tailor_id?: IntFilter<"OrderTailor"> | number
    assigned_at?: DateTimeFilter<"OrderTailor"> | Date | string
    status?: StringFilter<"OrderTailor"> | string
    due_date?: DateTimeNullableFilter<"OrderTailor"> | Date | string | null
    notes?: StringNullableFilter<"OrderTailor"> | string | null
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
    tailor?: XOR<TailorScalarRelationFilter, TailorWhereInput>
  }

  export type OrderTailorOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    tailor_id?: SortOrder
    assigned_at?: SortOrder
    status?: SortOrder
    due_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    order?: OrdersOrderByWithRelationInput
    tailor?: TailorOrderByWithRelationInput
  }

  export type OrderTailorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo_tailor_id?: OrderTailorOrderNoTailor_idCompoundUniqueInput
    AND?: OrderTailorWhereInput | OrderTailorWhereInput[]
    OR?: OrderTailorWhereInput[]
    NOT?: OrderTailorWhereInput | OrderTailorWhereInput[]
    orderNo?: StringFilter<"OrderTailor"> | string
    tailor_id?: IntFilter<"OrderTailor"> | number
    assigned_at?: DateTimeFilter<"OrderTailor"> | Date | string
    status?: StringFilter<"OrderTailor"> | string
    due_date?: DateTimeNullableFilter<"OrderTailor"> | Date | string | null
    notes?: StringNullableFilter<"OrderTailor"> | string | null
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
    tailor?: XOR<TailorScalarRelationFilter, TailorWhereInput>
  }, "id" | "orderNo_tailor_id">

  export type OrderTailorOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    tailor_id?: SortOrder
    assigned_at?: SortOrder
    status?: SortOrder
    due_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: OrderTailorCountOrderByAggregateInput
    _avg?: OrderTailorAvgOrderByAggregateInput
    _max?: OrderTailorMaxOrderByAggregateInput
    _min?: OrderTailorMinOrderByAggregateInput
    _sum?: OrderTailorSumOrderByAggregateInput
  }

  export type OrderTailorScalarWhereWithAggregatesInput = {
    AND?: OrderTailorScalarWhereWithAggregatesInput | OrderTailorScalarWhereWithAggregatesInput[]
    OR?: OrderTailorScalarWhereWithAggregatesInput[]
    NOT?: OrderTailorScalarWhereWithAggregatesInput | OrderTailorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderTailor"> | number
    orderNo?: StringWithAggregatesFilter<"OrderTailor"> | string
    tailor_id?: IntWithAggregatesFilter<"OrderTailor"> | number
    assigned_at?: DateTimeWithAggregatesFilter<"OrderTailor"> | Date | string
    status?: StringWithAggregatesFilter<"OrderTailor"> | string
    due_date?: DateTimeNullableWithAggregatesFilter<"OrderTailor"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"OrderTailor"> | string | null
  }

  export type RawMaterialsOrderListWhereInput = {
    AND?: RawMaterialsOrderListWhereInput | RawMaterialsOrderListWhereInput[]
    OR?: RawMaterialsOrderListWhereInput[]
    NOT?: RawMaterialsOrderListWhereInput | RawMaterialsOrderListWhereInput[]
    order_id?: IntFilter<"RawMaterialsOrderList"> | number
    product_name?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    description?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    raw_material_code?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    color?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    supplier_name?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    quantity?: DecimalNullableFilter<"RawMaterialsOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableFilter<"RawMaterialsOrderList"> | Date | string | null
    supplier_id?: IntNullableFilter<"RawMaterialsOrderList"> | number | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }

  export type RawMaterialsOrderListOrderByWithRelationInput = {
    order_id?: SortOrder
    product_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    raw_material_code?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    supplier_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    ordered_date?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    supplier?: SupplierOrderByWithRelationInput
  }

  export type RawMaterialsOrderListWhereUniqueInput = Prisma.AtLeast<{
    order_id?: number
    AND?: RawMaterialsOrderListWhereInput | RawMaterialsOrderListWhereInput[]
    OR?: RawMaterialsOrderListWhereInput[]
    NOT?: RawMaterialsOrderListWhereInput | RawMaterialsOrderListWhereInput[]
    product_name?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    description?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    raw_material_code?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    color?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    supplier_name?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    quantity?: DecimalNullableFilter<"RawMaterialsOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableFilter<"RawMaterialsOrderList"> | Date | string | null
    supplier_id?: IntNullableFilter<"RawMaterialsOrderList"> | number | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }, "order_id">

  export type RawMaterialsOrderListOrderByWithAggregationInput = {
    order_id?: SortOrder
    product_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    raw_material_code?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    supplier_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    ordered_date?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    _count?: RawMaterialsOrderListCountOrderByAggregateInput
    _avg?: RawMaterialsOrderListAvgOrderByAggregateInput
    _max?: RawMaterialsOrderListMaxOrderByAggregateInput
    _min?: RawMaterialsOrderListMinOrderByAggregateInput
    _sum?: RawMaterialsOrderListSumOrderByAggregateInput
  }

  export type RawMaterialsOrderListScalarWhereWithAggregatesInput = {
    AND?: RawMaterialsOrderListScalarWhereWithAggregatesInput | RawMaterialsOrderListScalarWhereWithAggregatesInput[]
    OR?: RawMaterialsOrderListScalarWhereWithAggregatesInput[]
    NOT?: RawMaterialsOrderListScalarWhereWithAggregatesInput | RawMaterialsOrderListScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"RawMaterialsOrderList"> | number
    product_name?: StringNullableWithAggregatesFilter<"RawMaterialsOrderList"> | string | null
    description?: StringNullableWithAggregatesFilter<"RawMaterialsOrderList"> | string | null
    raw_material_code?: StringNullableWithAggregatesFilter<"RawMaterialsOrderList"> | string | null
    color?: StringNullableWithAggregatesFilter<"RawMaterialsOrderList"> | string | null
    supplier_name?: StringNullableWithAggregatesFilter<"RawMaterialsOrderList"> | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"RawMaterialsOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableWithAggregatesFilter<"RawMaterialsOrderList"> | Date | string | null
    supplier_id?: IntNullableWithAggregatesFilter<"RawMaterialsOrderList"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    logs?: LogEntryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logs?: LogEntryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    logs?: LogEntryListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LogEntryWhereInput = {
    AND?: LogEntryWhereInput | LogEntryWhereInput[]
    OR?: LogEntryWhereInput[]
    NOT?: LogEntryWhereInput | LogEntryWhereInput[]
    id?: IntFilter<"LogEntry"> | number
    userId?: IntFilter<"LogEntry"> | number
    action?: StringFilter<"LogEntry"> | string
    timestamp?: DateTimeFilter<"LogEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LogEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogEntryWhereInput | LogEntryWhereInput[]
    OR?: LogEntryWhereInput[]
    NOT?: LogEntryWhereInput | LogEntryWhereInput[]
    userId?: IntFilter<"LogEntry"> | number
    action?: StringFilter<"LogEntry"> | string
    timestamp?: DateTimeFilter<"LogEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LogEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    _count?: LogEntryCountOrderByAggregateInput
    _avg?: LogEntryAvgOrderByAggregateInput
    _max?: LogEntryMaxOrderByAggregateInput
    _min?: LogEntryMinOrderByAggregateInput
    _sum?: LogEntrySumOrderByAggregateInput
  }

  export type LogEntryScalarWhereWithAggregatesInput = {
    AND?: LogEntryScalarWhereWithAggregatesInput | LogEntryScalarWhereWithAggregatesInput[]
    OR?: LogEntryScalarWhereWithAggregatesInput[]
    NOT?: LogEntryScalarWhereWithAggregatesInput | LogEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogEntry"> | number
    userId?: IntWithAggregatesFilter<"LogEntry"> | number
    action?: StringWithAggregatesFilter<"LogEntry"> | string
    timestamp?: DateTimeWithAggregatesFilter<"LogEntry"> | Date | string
  }

  export type OrderProductionWhereInput = {
    AND?: OrderProductionWhereInput | OrderProductionWhereInput[]
    OR?: OrderProductionWhereInput[]
    NOT?: OrderProductionWhereInput | OrderProductionWhereInput[]
    id?: IntFilter<"OrderProduction"> | number
    orderNo?: StringFilter<"OrderProduction"> | string
    status?: EnumProductionStatusFilter<"OrderProduction"> | $Enums.ProductionStatus
    updatedAt?: DateTimeFilter<"OrderProduction"> | Date | string
    notes?: StringNullableFilter<"OrderProduction"> | string | null
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }

  export type OrderProductionOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    order?: OrdersOrderByWithRelationInput
  }

  export type OrderProductionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo?: string
    AND?: OrderProductionWhereInput | OrderProductionWhereInput[]
    OR?: OrderProductionWhereInput[]
    NOT?: OrderProductionWhereInput | OrderProductionWhereInput[]
    status?: EnumProductionStatusFilter<"OrderProduction"> | $Enums.ProductionStatus
    updatedAt?: DateTimeFilter<"OrderProduction"> | Date | string
    notes?: StringNullableFilter<"OrderProduction"> | string | null
    order?: XOR<OrdersScalarRelationFilter, OrdersWhereInput>
  }, "id" | "orderNo">

  export type OrderProductionOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: OrderProductionCountOrderByAggregateInput
    _avg?: OrderProductionAvgOrderByAggregateInput
    _max?: OrderProductionMaxOrderByAggregateInput
    _min?: OrderProductionMinOrderByAggregateInput
    _sum?: OrderProductionSumOrderByAggregateInput
  }

  export type OrderProductionScalarWhereWithAggregatesInput = {
    AND?: OrderProductionScalarWhereWithAggregatesInput | OrderProductionScalarWhereWithAggregatesInput[]
    OR?: OrderProductionScalarWhereWithAggregatesInput[]
    NOT?: OrderProductionScalarWhereWithAggregatesInput | OrderProductionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderProduction"> | number
    orderNo?: StringWithAggregatesFilter<"OrderProduction"> | string
    status?: EnumProductionStatusWithAggregatesFilter<"OrderProduction"> | $Enums.ProductionStatus
    updatedAt?: DateTimeWithAggregatesFilter<"OrderProduction"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"OrderProduction"> | string | null
  }

  export type LocationCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    racks?: RackCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    racks?: RackUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    racks?: RackUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    racks?: RackUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RackCreateInput = {
    name: string
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutRacksInput
    bunches?: BunchCreateNestedManyWithoutRackInput
  }

  export type RackUncheckedCreateInput = {
    id?: number
    name: string
    location_id: number
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
    bunches?: BunchUncheckedCreateNestedManyWithoutRackInput
  }

  export type RackUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutRacksNestedInput
    bunches?: BunchUpdateManyWithoutRackNestedInput
  }

  export type RackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bunches?: BunchUncheckedUpdateManyWithoutRackNestedInput
  }

  export type RackCreateManyInput = {
    id?: number
    name: string
    location_id: number
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
  }

  export type RackUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BunchCreateInput = {
    name: string
    createdAt?: Date | string
    rack: RackCreateNestedOneWithoutBunchesInput
    items?: InventoryItemCreateNestedManyWithoutBunchInput
  }

  export type BunchUncheckedCreateInput = {
    id?: number
    name: string
    rack_id: number
    createdAt?: Date | string
    items?: InventoryItemUncheckedCreateNestedManyWithoutBunchInput
  }

  export type BunchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rack?: RackUpdateOneRequiredWithoutBunchesNestedInput
    items?: InventoryItemUpdateManyWithoutBunchNestedInput
  }

  export type BunchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rack_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventoryItemUncheckedUpdateManyWithoutBunchNestedInput
  }

  export type BunchCreateManyInput = {
    id?: number
    name: string
    rack_id: number
    createdAt?: Date | string
  }

  export type BunchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BunchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rack_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    name: string
    symbol: string
    baseUnit?: string | null
    conversion_rate?: number | null
    items?: InventoryItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    name: string
    symbol: string
    baseUnit?: string | null
    conversion_rate?: number | null
    items?: InventoryItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    baseUnit?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: InventoryItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    baseUnit?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: InventoryItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    name: string
    symbol: string
    baseUnit?: string | null
    conversion_rate?: number | null
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    baseUnit?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    baseUnit?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InventoryMovementCreateInput = {
    type: $Enums.MovementType
    quantity: number
    note?: string | null
    moved_at?: Date | string
    item: InventoryItemCreateNestedOneWithoutMovement_logsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: number
    item_id: string
    type: $Enums.MovementType
    quantity: number
    note?: string | null
    moved_at?: Date | string
  }

  export type InventoryMovementUpdateInput = {
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutMovement_logsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: number
    item_id: string
    type: $Enums.MovementType
    quantity: number
    note?: string | null
    moved_at?: Date | string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSupplierCreateInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
    item: InventoryItemCreateNestedOneWithoutSuppliersInput
    supplier: SupplierCreateNestedOneWithoutItemSupplierInput
  }

  export type ItemSupplierUncheckedCreateInput = {
    id?: number
    item_id: string
    supplier_id: number
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
  }

  export type ItemSupplierUpdateInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutSuppliersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutItemSupplierNestedInput
  }

  export type ItemSupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: IntFieldUpdateOperationsInput | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSupplierCreateManyInput = {
    id?: number
    item_id: string
    supplier_id: number
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
  }

  export type ItemSupplierUpdateManyMutationInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    supplier_id?: IntFieldUpdateOperationsInput | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    quantity?: number | null
    bunch?: BunchCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    movement_logs?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id?: number | null
    unit_id?: number | null
    quantity?: number | null
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    movement_logs?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUpdateInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    bunch?: BunchUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    movement_logs?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    bunch_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    movement_logs?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id?: number | null
    unit_id?: number | null
    quantity?: number | null
  }

  export type InventoryItemUpdateManyMutationInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    bunch_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerCreateInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FabricCreateInput = {
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    fabricOrders?: FabricOrderListCreateNestedManyWithoutFabricInput
    items?: ItemsCreateNestedManyWithoutFabricInput
    liningItems?: ItemsCreateNestedManyWithoutLining_fabricInput
  }

  export type FabricUncheckedCreateInput = {
    fabric_id?: number
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    fabricOrders?: FabricOrderListUncheckedCreateNestedManyWithoutFabricInput
    items?: ItemsUncheckedCreateNestedManyWithoutFabricInput
    liningItems?: ItemsUncheckedCreateNestedManyWithoutLining_fabricInput
  }

  export type FabricUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricOrders?: FabricOrderListUpdateManyWithoutFabricNestedInput
    items?: ItemsUpdateManyWithoutFabricNestedInput
    liningItems?: ItemsUpdateManyWithoutLining_fabricNestedInput
  }

  export type FabricUncheckedUpdateInput = {
    fabric_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricOrders?: FabricOrderListUncheckedUpdateManyWithoutFabricNestedInput
    items?: ItemsUncheckedUpdateManyWithoutFabricNestedInput
    liningItems?: ItemsUncheckedUpdateManyWithoutLining_fabricNestedInput
  }

  export type FabricCreateManyInput = {
    fabric_id?: number
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
  }

  export type FabricUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricUncheckedUpdateManyInput = {
    fabric_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricOrderListCreateInput = {
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    fabric?: FabricCreateNestedOneWithoutFabricOrdersInput
    supplier?: SupplierCreateNestedOneWithoutFabricOrderListInput
  }

  export type FabricOrderListUncheckedCreateInput = {
    order_id?: number
    fabric_id?: number | null
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    supplier_id?: number | null
  }

  export type FabricOrderListUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    fabric?: FabricUpdateOneWithoutFabricOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutFabricOrderListNestedInput
  }

  export type FabricOrderListUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FabricOrderListCreateManyInput = {
    order_id?: number
    fabric_id?: number | null
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    supplier_id?: number | null
  }

  export type FabricOrderListUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricOrderListUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinalJacketMeasurementCreateInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutMeasurementsInput
    order?: OrdersCreateNestedOneWithoutFinalJacketMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_jacket_measurementInput
  }

  export type FinalJacketMeasurementUncheckedCreateInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_jacket_measurementInput
  }

  export type FinalJacketMeasurementUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutMeasurementsNestedInput
    order?: OrdersUpdateOneWithoutFinalJacketMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_jacket_measurementNestedInput
  }

  export type FinalJacketMeasurementUncheckedUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_jacket_measurementNestedInput
  }

  export type FinalJacketMeasurementCreateManyInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type FinalJacketMeasurementUpdateManyMutationInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalJacketMeasurementUncheckedUpdateManyInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JacketMeasurementCreateInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutJacketMeasurementInput
    order?: OrdersCreateNestedOneWithoutJacketMeasurementInput
    Items?: ItemsCreateNestedManyWithoutJacket_measurementInput
  }

  export type JacketMeasurementUncheckedCreateInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutJacket_measurementInput
  }

  export type JacketMeasurementUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutJacketMeasurementNestedInput
    order?: OrdersUpdateOneWithoutJacketMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutJacket_measurementNestedInput
  }

  export type JacketMeasurementUncheckedUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutJacket_measurementNestedInput
  }

  export type JacketMeasurementCreateManyInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type JacketMeasurementUpdateManyMutationInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JacketMeasurementUncheckedUpdateManyInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalPantMeasurementCreateInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutFinalPantMeasurementInput
    order?: OrdersCreateNestedOneWithoutFinalPantMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_pant_measurementInput
  }

  export type FinalPantMeasurementUncheckedCreateInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_pant_measurementInput
  }

  export type FinalPantMeasurementUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutFinalPantMeasurementNestedInput
    order?: OrdersUpdateOneWithoutFinalPantMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_pant_measurementNestedInput
  }

  export type FinalPantMeasurementUncheckedUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_pant_measurementNestedInput
  }

  export type FinalPantMeasurementCreateManyInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type FinalPantMeasurementUpdateManyMutationInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalPantMeasurementUncheckedUpdateManyInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PantMeasurementCreateInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutPantMeasurementInput
    order?: OrdersCreateNestedOneWithoutPantMeasurementInput
    Items?: ItemsCreateNestedManyWithoutPant_measurementInput
  }

  export type PantMeasurementUncheckedCreateInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutPant_measurementInput
  }

  export type PantMeasurementUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPantMeasurementNestedInput
    order?: OrdersUpdateOneWithoutPantMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutPant_measurementNestedInput
  }

  export type PantMeasurementUncheckedUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutPant_measurementNestedInput
  }

  export type PantMeasurementCreateManyInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type PantMeasurementUpdateManyMutationInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PantMeasurementUncheckedUpdateManyInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalShirtMeasurementCreateInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutFinalShirtMeasurementInput
    order?: OrdersCreateNestedOneWithoutFinalShirtMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_shirt_measurementInput
  }

  export type FinalShirtMeasurementUncheckedCreateInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_shirt_measurementInput
  }

  export type FinalShirtMeasurementUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutFinalShirtMeasurementNestedInput
    order?: OrdersUpdateOneWithoutFinalShirtMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_shirt_measurementNestedInput
  }

  export type FinalShirtMeasurementUncheckedUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_shirt_measurementNestedInput
  }

  export type FinalShirtMeasurementCreateManyInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type FinalShirtMeasurementUpdateManyMutationInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalShirtMeasurementUncheckedUpdateManyInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShirtMeasurementCreateInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutShirtMeasurementInput
    order?: OrdersCreateNestedOneWithoutShirtMeasurementInput
    Items?: ItemsCreateNestedManyWithoutShirt_measurementInput
  }

  export type ShirtMeasurementUncheckedCreateInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutShirt_measurementInput
  }

  export type ShirtMeasurementUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutShirtMeasurementNestedInput
    order?: OrdersUpdateOneWithoutShirtMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutShirt_measurementNestedInput
  }

  export type ShirtMeasurementUncheckedUpdateInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutShirt_measurementNestedInput
  }

  export type ShirtMeasurementCreateManyInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type ShirtMeasurementUpdateManyMutationInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShirtMeasurementUncheckedUpdateManyInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPhotosCreateInput = {
    s3_key?: string | null
    uploaded_at?: Date | string
    order?: OrdersCreateNestedOneWithoutOrderPhotosInput
  }

  export type OrderPhotosUncheckedCreateInput = {
    photo_id?: number
    orderNo?: string | null
    s3_key?: string | null
    uploaded_at?: Date | string
  }

  export type OrderPhotosUpdateInput = {
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrdersUpdateOneWithoutOrderPhotosNestedInput
  }

  export type OrderPhotosUncheckedUpdateInput = {
    photo_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPhotosCreateManyInput = {
    photo_id?: number
    orderNo?: string | null
    s3_key?: string | null
    uploaded_at?: Date | string
  }

  export type OrderPhotosUpdateManyMutationInput = {
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPhotosUncheckedUpdateManyInput = {
    photo_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersUpdateInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrdersCreateManyInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
  }

  export type OrdersUpdateManyMutationInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersUncheckedUpdateManyInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateManyMutationInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
  }

  export type ItemsUncheckedUpdateManyInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierCreateInput = {
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    FabricOrderList?: FabricOrderListCreateNestedManyWithoutSupplierInput
    RawMaterialsOrderList?: RawMaterialsOrderListCreateNestedManyWithoutSupplierInput
    ItemSupplier?: ItemSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    supplier_id?: number
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    FabricOrderList?: FabricOrderListUncheckedCreateNestedManyWithoutSupplierInput
    RawMaterialsOrderList?: RawMaterialsOrderListUncheckedCreateNestedManyWithoutSupplierInput
    ItemSupplier?: ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    FabricOrderList?: FabricOrderListUpdateManyWithoutSupplierNestedInput
    RawMaterialsOrderList?: RawMaterialsOrderListUpdateManyWithoutSupplierNestedInput
    ItemSupplier?: ItemSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    FabricOrderList?: FabricOrderListUncheckedUpdateManyWithoutSupplierNestedInput
    RawMaterialsOrderList?: RawMaterialsOrderListUncheckedUpdateManyWithoutSupplierNestedInput
    ItemSupplier?: ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    supplier_id?: number
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
  }

  export type SupplierUpdateManyMutationInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailorCreateInput = {
    first_name: string
    last_name?: string | null
    specialization?: string | null
    experience_years?: number | null
    joining_date?: Date | string
    address?: string | null
    phone_number?: string | null
    email?: string | null
    emergency_contact?: string | null
    status?: string
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    orders?: OrderTailorCreateNestedManyWithoutTailorInput
  }

  export type TailorUncheckedCreateInput = {
    tailor_id?: number
    first_name: string
    last_name?: string | null
    specialization?: string | null
    experience_years?: number | null
    joining_date?: Date | string
    address?: string | null
    phone_number?: string | null
    email?: string | null
    emergency_contact?: string | null
    status?: string
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    orders?: OrderTailorUncheckedCreateNestedManyWithoutTailorInput
  }

  export type TailorUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderTailorUpdateManyWithoutTailorNestedInput
  }

  export type TailorUncheckedUpdateInput = {
    tailor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderTailorUncheckedUpdateManyWithoutTailorNestedInput
  }

  export type TailorCreateManyInput = {
    tailor_id?: number
    first_name: string
    last_name?: string | null
    specialization?: string | null
    experience_years?: number | null
    joining_date?: Date | string
    address?: string | null
    phone_number?: string | null
    email?: string | null
    emergency_contact?: string | null
    status?: string
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type TailorUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailorUncheckedUpdateManyInput = {
    tailor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderTailorCreateInput = {
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
    order: OrdersCreateNestedOneWithoutTailorsInput
    tailor: TailorCreateNestedOneWithoutOrdersInput
  }

  export type OrderTailorUncheckedCreateInput = {
    id?: number
    orderNo: string
    tailor_id: number
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
  }

  export type OrderTailorUpdateInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneRequiredWithoutTailorsNestedInput
    tailor?: TailorUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderTailorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    tailor_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderTailorCreateManyInput = {
    id?: number
    orderNo: string
    tailor_id: number
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
  }

  export type OrderTailorUpdateManyMutationInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderTailorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    tailor_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RawMaterialsOrderListCreateInput = {
    product_name?: string | null
    description?: string | null
    raw_material_code?: string | null
    color?: string | null
    supplier_name?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    supplier?: SupplierCreateNestedOneWithoutRawMaterialsOrderListInput
  }

  export type RawMaterialsOrderListUncheckedCreateInput = {
    order_id?: number
    product_name?: string | null
    description?: string | null
    raw_material_code?: string | null
    color?: string | null
    supplier_name?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    supplier_id?: number | null
  }

  export type RawMaterialsOrderListUpdateInput = {
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: SupplierUpdateOneWithoutRawMaterialsOrderListNestedInput
  }

  export type RawMaterialsOrderListUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RawMaterialsOrderListCreateManyInput = {
    order_id?: number
    product_name?: string | null
    description?: string | null
    raw_material_code?: string | null
    color?: string | null
    supplier_name?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    supplier_id?: number | null
  }

  export type RawMaterialsOrderListUpdateManyMutationInput = {
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RawMaterialsOrderListUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    username: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryCreateInput = {
    action: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogEntryUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    timestamp?: Date | string
  }

  export type LogEntryUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryCreateManyInput = {
    id?: number
    userId: number
    action: string
    timestamp?: Date | string
  }

  export type LogEntryUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductionCreateInput = {
    status?: $Enums.ProductionStatus
    updatedAt?: Date | string
    notes?: string | null
    order: OrdersCreateNestedOneWithoutProductionInput
  }

  export type OrderProductionUncheckedCreateInput = {
    id?: number
    orderNo: string
    status?: $Enums.ProductionStatus
    updatedAt?: Date | string
    notes?: string | null
  }

  export type OrderProductionUpdateInput = {
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneRequiredWithoutProductionNestedInput
  }

  export type OrderProductionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderProductionCreateManyInput = {
    id?: number
    orderNo: string
    status?: $Enums.ProductionStatus
    updatedAt?: Date | string
    notes?: string | null
  }

  export type OrderProductionUpdateManyMutationInput = {
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderProductionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RackListRelationFilter = {
    every?: RackWhereInput
    some?: RackWhereInput
    none?: RackWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type BunchListRelationFilter = {
    every?: BunchWhereInput
    some?: BunchWhereInput
    none?: BunchWhereInput
  }

  export type BunchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
    createdAt?: SortOrder
  }

  export type RackAvgOrderByAggregateInput = {
    id?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
  }

  export type RackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
    createdAt?: SortOrder
  }

  export type RackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
    createdAt?: SortOrder
  }

  export type RackSumOrderByAggregateInput = {
    id?: SortOrder
    location_id?: SortOrder
    capacity?: SortOrder
    current_utilization?: SortOrder
  }

  export type RackScalarRelationFilter = {
    is?: RackWhereInput
    isNot?: RackWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BunchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rack_id?: SortOrder
    createdAt?: SortOrder
  }

  export type BunchAvgOrderByAggregateInput = {
    id?: SortOrder
    rack_id?: SortOrder
  }

  export type BunchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rack_id?: SortOrder
    createdAt?: SortOrder
  }

  export type BunchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rack_id?: SortOrder
    createdAt?: SortOrder
  }

  export type BunchSumOrderByAggregateInput = {
    id?: SortOrder
    rack_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    baseUnit?: SortOrder
    conversion_rate?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
    conversion_rate?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    baseUnit?: SortOrder
    conversion_rate?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    baseUnit?: SortOrder
    conversion_rate?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
    conversion_rate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    moved_at?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    moved_at?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    note?: SortOrder
    moved_at?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type EnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type ItemSupplierItem_idSupplier_idCompoundUniqueInput = {
    item_id: string
    supplier_id: number
  }

  export type ItemSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrder
    added_on?: SortOrder
  }

  export type ItemSupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrder
  }

  export type ItemSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrder
    added_on?: SortOrder
  }

  export type ItemSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrder
    added_on?: SortOrder
  }

  export type ItemSupplierSumOrderByAggregateInput = {
    id?: SortOrder
    supplier_id?: SortOrder
    price?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumInventoryItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryItemType | EnumInventoryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryItemTypeFilter<$PrismaModel> | $Enums.InventoryItemType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BunchNullableScalarRelationFilter = {
    is?: BunchWhereInput | null
    isNot?: BunchWhereInput | null
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type ItemSupplierListRelationFilter = {
    every?: ItemSupplierWhereInput
    some?: ItemSupplierWhereInput
    none?: ItemSupplierWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type ItemSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    bunch_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    bunch_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    bunch_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    item_id?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    bunch_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    bunch_id?: SortOrder
    unit_id?: SortOrder
    quantity?: SortOrder
  }

  export type EnumInventoryItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryItemType | EnumInventoryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryItemTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryItemTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type FinalJacketMeasurementListRelationFilter = {
    every?: FinalJacketMeasurementWhereInput
    some?: FinalJacketMeasurementWhereInput
    none?: FinalJacketMeasurementWhereInput
  }

  export type FinalPantMeasurementListRelationFilter = {
    every?: FinalPantMeasurementWhereInput
    some?: FinalPantMeasurementWhereInput
    none?: FinalPantMeasurementWhereInput
  }

  export type FinalShirtMeasurementListRelationFilter = {
    every?: FinalShirtMeasurementWhereInput
    some?: FinalShirtMeasurementWhereInput
    none?: FinalShirtMeasurementWhereInput
  }

  export type JacketMeasurementListRelationFilter = {
    every?: JacketMeasurementWhereInput
    some?: JacketMeasurementWhereInput
    none?: JacketMeasurementWhereInput
  }

  export type PantMeasurementListRelationFilter = {
    every?: PantMeasurementWhereInput
    some?: PantMeasurementWhereInput
    none?: PantMeasurementWhereInput
  }

  export type ShirtMeasurementListRelationFilter = {
    every?: ShirtMeasurementWhereInput
    some?: ShirtMeasurementWhereInput
    none?: ShirtMeasurementWhereInput
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinalJacketMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinalPantMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinalShirtMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JacketMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PantMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShirtMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrder
    last_name?: SortOrder
    add1?: SortOrder
    add2?: SortOrder
    add3?: SortOrder
    add4?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    office_phone?: SortOrder
    residential_phone?: SortOrder
    last_ordered_date?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrder
    last_name?: SortOrder
    add1?: SortOrder
    add2?: SortOrder
    add3?: SortOrder
    add4?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    office_phone?: SortOrder
    residential_phone?: SortOrder
    last_ordered_date?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    customer_id?: SortOrder
    first_name?: SortOrder
    middle_name?: SortOrder
    last_name?: SortOrder
    add1?: SortOrder
    add2?: SortOrder
    add3?: SortOrder
    add4?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    office_phone?: SortOrder
    residential_phone?: SortOrder
    last_ordered_date?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FabricOrderListListRelationFilter = {
    every?: FabricOrderListWhereInput
    some?: FabricOrderListWhereInput
    none?: FabricOrderListWhereInput
  }

  export type ItemsListRelationFilter = {
    every?: ItemsWhereInput
    some?: ItemsWhereInput
    none?: ItemsWhereInput
  }

  export type FabricOrderListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FabricCountOrderByAggregateInput = {
    fabric_id?: SortOrder
    description?: SortOrder
    available_length?: SortOrder
    fabric_code?: SortOrder
    fabric_brand?: SortOrder
    stock_location?: SortOrder
    image?: SortOrder
    barcode?: SortOrder
  }

  export type FabricAvgOrderByAggregateInput = {
    fabric_id?: SortOrder
    available_length?: SortOrder
  }

  export type FabricMaxOrderByAggregateInput = {
    fabric_id?: SortOrder
    description?: SortOrder
    available_length?: SortOrder
    fabric_code?: SortOrder
    fabric_brand?: SortOrder
    stock_location?: SortOrder
    image?: SortOrder
    barcode?: SortOrder
  }

  export type FabricMinOrderByAggregateInput = {
    fabric_id?: SortOrder
    description?: SortOrder
    available_length?: SortOrder
    fabric_code?: SortOrder
    fabric_brand?: SortOrder
    stock_location?: SortOrder
    image?: SortOrder
    barcode?: SortOrder
  }

  export type FabricSumOrderByAggregateInput = {
    fabric_id?: SortOrder
    available_length?: SortOrder
  }

  export type FabricNullableScalarRelationFilter = {
    is?: FabricWhereInput | null
    isNot?: FabricWhereInput | null
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type FabricOrderListCountOrderByAggregateInput = {
    order_id?: SortOrder
    fabric_id?: SortOrder
    description?: SortOrder
    supplier_name?: SortOrder
    meters?: SortOrder
    ordered_date?: SortOrder
    ordered_for?: SortOrder
    supplier_id?: SortOrder
  }

  export type FabricOrderListAvgOrderByAggregateInput = {
    order_id?: SortOrder
    fabric_id?: SortOrder
    meters?: SortOrder
    supplier_id?: SortOrder
  }

  export type FabricOrderListMaxOrderByAggregateInput = {
    order_id?: SortOrder
    fabric_id?: SortOrder
    description?: SortOrder
    supplier_name?: SortOrder
    meters?: SortOrder
    ordered_date?: SortOrder
    ordered_for?: SortOrder
    supplier_id?: SortOrder
  }

  export type FabricOrderListMinOrderByAggregateInput = {
    order_id?: SortOrder
    fabric_id?: SortOrder
    description?: SortOrder
    supplier_name?: SortOrder
    meters?: SortOrder
    ordered_date?: SortOrder
    ordered_for?: SortOrder
    supplier_id?: SortOrder
  }

  export type FabricOrderListSumOrderByAggregateInput = {
    order_id?: SortOrder
    fabric_id?: SortOrder
    meters?: SortOrder
    supplier_id?: SortOrder
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type OrdersNullableScalarRelationFilter = {
    is?: OrdersWhereInput | null
    isNot?: OrdersWhereInput | null
  }

  export type FinalJacketMeasurementCountOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    jacket_length?: SortOrder
    natural_length?: SortOrder
    back_length?: SortOrder
    x_back?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    waist_coat_length?: SortOrder
    sherwani_length?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalJacketMeasurementAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type FinalJacketMeasurementMaxOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    jacket_length?: SortOrder
    natural_length?: SortOrder
    back_length?: SortOrder
    x_back?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    waist_coat_length?: SortOrder
    sherwani_length?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalJacketMeasurementMinOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    jacket_length?: SortOrder
    natural_length?: SortOrder
    back_length?: SortOrder
    x_back?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    waist_coat_length?: SortOrder
    sherwani_length?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalJacketMeasurementSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type JacketMeasurementCountOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    jacket_length?: SortOrder
    natural_length?: SortOrder
    back_length?: SortOrder
    x_back?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    waist_coat_length?: SortOrder
    sherwani_length?: SortOrder
    other_notes?: SortOrder
  }

  export type JacketMeasurementAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type JacketMeasurementMaxOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    jacket_length?: SortOrder
    natural_length?: SortOrder
    back_length?: SortOrder
    x_back?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    waist_coat_length?: SortOrder
    sherwani_length?: SortOrder
    other_notes?: SortOrder
  }

  export type JacketMeasurementMinOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    jacket_length?: SortOrder
    natural_length?: SortOrder
    back_length?: SortOrder
    x_back?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    waist_coat_length?: SortOrder
    sherwani_length?: SortOrder
    other_notes?: SortOrder
  }

  export type JacketMeasurementSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type FinalPantMeasurementCountOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    inseem?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    bottom?: SortOrder
    knee?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalPantMeasurementAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type FinalPantMeasurementMaxOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    inseem?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    bottom?: SortOrder
    knee?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalPantMeasurementMinOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    inseem?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    bottom?: SortOrder
    knee?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalPantMeasurementSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type PantMeasurementCountOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    inseem?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    bottom?: SortOrder
    knee?: SortOrder
    other_notes?: SortOrder
  }

  export type PantMeasurementAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type PantMeasurementMaxOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    inseem?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    bottom?: SortOrder
    knee?: SortOrder
    other_notes?: SortOrder
  }

  export type PantMeasurementMinOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    inseem?: SortOrder
    waist?: SortOrder
    hips?: SortOrder
    bottom?: SortOrder
    knee?: SortOrder
    other_notes?: SortOrder
  }

  export type PantMeasurementSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type FinalShirtMeasurementCountOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalShirtMeasurementAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type FinalShirtMeasurementMaxOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalShirtMeasurementMinOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    other_notes?: SortOrder
  }

  export type FinalShirtMeasurementSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type ShirtMeasurementCountOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    other_notes?: SortOrder
  }

  export type ShirtMeasurementAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type ShirtMeasurementMaxOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    other_notes?: SortOrder
  }

  export type ShirtMeasurementMinOrderByAggregateInput = {
    measurement_id?: SortOrder
    customer_id?: SortOrder
    orderNo?: SortOrder
    date?: SortOrder
    length?: SortOrder
    half_shoulder?: SortOrder
    to_sleeve?: SortOrder
    chest?: SortOrder
    waist?: SortOrder
    collar?: SortOrder
    other_notes?: SortOrder
  }

  export type ShirtMeasurementSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type OrderPhotosCountOrderByAggregateInput = {
    photo_id?: SortOrder
    orderNo?: SortOrder
    s3_key?: SortOrder
    uploaded_at?: SortOrder
  }

  export type OrderPhotosAvgOrderByAggregateInput = {
    photo_id?: SortOrder
  }

  export type OrderPhotosMaxOrderByAggregateInput = {
    photo_id?: SortOrder
    orderNo?: SortOrder
    s3_key?: SortOrder
    uploaded_at?: SortOrder
  }

  export type OrderPhotosMinOrderByAggregateInput = {
    photo_id?: SortOrder
    orderNo?: SortOrder
    s3_key?: SortOrder
    uploaded_at?: SortOrder
  }

  export type OrderPhotosSumOrderByAggregateInput = {
    photo_id?: SortOrder
  }

  export type OrderPhotosListRelationFilter = {
    every?: OrderPhotosWhereInput
    some?: OrderPhotosWhereInput
    none?: OrderPhotosWhereInput
  }

  export type OrderTailorListRelationFilter = {
    every?: OrderTailorWhereInput
    some?: OrderTailorWhereInput
    none?: OrderTailorWhereInput
  }

  export type OrderProductionNullableScalarRelationFilter = {
    is?: OrderProductionWhereInput | null
    isNot?: OrderProductionWhereInput | null
  }

  export type OrderPhotosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderTailorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersCountOrderByAggregateInput = {
    orderNo?: SortOrder
    customer_id?: SortOrder
    date?: SortOrder
    onote?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    orderNo?: SortOrder
    customer_id?: SortOrder
    date?: SortOrder
    onote?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    orderNo?: SortOrder
    customer_id?: SortOrder
    date?: SortOrder
    onote?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    customer_id?: SortOrder
  }

  export type EnumItemTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumItemTypeNullableFilter<$PrismaModel> | $Enums.ItemType | null
  }

  export type JacketMeasurementNullableScalarRelationFilter = {
    is?: JacketMeasurementWhereInput | null
    isNot?: JacketMeasurementWhereInput | null
  }

  export type ShirtMeasurementNullableScalarRelationFilter = {
    is?: ShirtMeasurementWhereInput | null
    isNot?: ShirtMeasurementWhereInput | null
  }

  export type PantMeasurementNullableScalarRelationFilter = {
    is?: PantMeasurementWhereInput | null
    isNot?: PantMeasurementWhereInput | null
  }

  export type FinalJacketMeasurementNullableScalarRelationFilter = {
    is?: FinalJacketMeasurementWhereInput | null
    isNot?: FinalJacketMeasurementWhereInput | null
  }

  export type FinalShirtMeasurementNullableScalarRelationFilter = {
    is?: FinalShirtMeasurementWhereInput | null
    isNot?: FinalShirtMeasurementWhereInput | null
  }

  export type FinalPantMeasurementNullableScalarRelationFilter = {
    is?: FinalPantMeasurementWhereInput | null
    isNot?: FinalPantMeasurementWhereInput | null
  }

  export type ItemsCountOrderByAggregateInput = {
    item_id?: SortOrder
    orderNo?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    fabric_id?: SortOrder
    lining_fabric_id?: SortOrder
    jacket_measurement_id?: SortOrder
    shirt_measurement_id?: SortOrder
    pant_measurement_id?: SortOrder
    final_jacket_measurement_id?: SortOrder
    final_shirt_measurement_id?: SortOrder
    final_pant_measurement_id?: SortOrder
  }

  export type ItemsAvgOrderByAggregateInput = {
    item_id?: SortOrder
    fabric_id?: SortOrder
    lining_fabric_id?: SortOrder
  }

  export type ItemsMaxOrderByAggregateInput = {
    item_id?: SortOrder
    orderNo?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    fabric_id?: SortOrder
    lining_fabric_id?: SortOrder
    jacket_measurement_id?: SortOrder
    shirt_measurement_id?: SortOrder
    pant_measurement_id?: SortOrder
    final_jacket_measurement_id?: SortOrder
    final_shirt_measurement_id?: SortOrder
    final_pant_measurement_id?: SortOrder
  }

  export type ItemsMinOrderByAggregateInput = {
    item_id?: SortOrder
    orderNo?: SortOrder
    item_name?: SortOrder
    item_type?: SortOrder
    fabric_id?: SortOrder
    lining_fabric_id?: SortOrder
    jacket_measurement_id?: SortOrder
    shirt_measurement_id?: SortOrder
    pant_measurement_id?: SortOrder
    final_jacket_measurement_id?: SortOrder
    final_shirt_measurement_id?: SortOrder
    final_pant_measurement_id?: SortOrder
  }

  export type ItemsSumOrderByAggregateInput = {
    item_id?: SortOrder
    fabric_id?: SortOrder
    lining_fabric_id?: SortOrder
  }

  export type EnumItemTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumItemTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ItemType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumItemTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumItemTypeNullableFilter<$PrismaModel>
  }

  export type RawMaterialsOrderListListRelationFilter = {
    every?: RawMaterialsOrderListWhereInput
    some?: RawMaterialsOrderListWhereInput
    none?: RawMaterialsOrderListWhereInput
  }

  export type RawMaterialsOrderListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    add1?: SortOrder
    add2?: SortOrder
    add3?: SortOrder
    phone_number1?: SortOrder
    phone_number2?: SortOrder
    phone_number3?: SortOrder
    email?: SortOrder
    primary_contact_name1?: SortOrder
    primary_contact_name2?: SortOrder
    primary_contact_name3?: SortOrder
    notes?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    supplier_id?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    add1?: SortOrder
    add2?: SortOrder
    add3?: SortOrder
    phone_number1?: SortOrder
    phone_number2?: SortOrder
    phone_number3?: SortOrder
    email?: SortOrder
    primary_contact_name1?: SortOrder
    primary_contact_name2?: SortOrder
    primary_contact_name3?: SortOrder
    notes?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    add1?: SortOrder
    add2?: SortOrder
    add3?: SortOrder
    phone_number1?: SortOrder
    phone_number2?: SortOrder
    phone_number3?: SortOrder
    email?: SortOrder
    primary_contact_name1?: SortOrder
    primary_contact_name2?: SortOrder
    primary_contact_name3?: SortOrder
    notes?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    supplier_id?: SortOrder
  }

  export type TailorCountOrderByAggregateInput = {
    tailor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialization?: SortOrder
    experience_years?: SortOrder
    joining_date?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    emergency_contact?: SortOrder
    status?: SortOrder
    hourly_rate?: SortOrder
    notes?: SortOrder
  }

  export type TailorAvgOrderByAggregateInput = {
    tailor_id?: SortOrder
    experience_years?: SortOrder
    hourly_rate?: SortOrder
  }

  export type TailorMaxOrderByAggregateInput = {
    tailor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialization?: SortOrder
    experience_years?: SortOrder
    joining_date?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    emergency_contact?: SortOrder
    status?: SortOrder
    hourly_rate?: SortOrder
    notes?: SortOrder
  }

  export type TailorMinOrderByAggregateInput = {
    tailor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialization?: SortOrder
    experience_years?: SortOrder
    joining_date?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    emergency_contact?: SortOrder
    status?: SortOrder
    hourly_rate?: SortOrder
    notes?: SortOrder
  }

  export type TailorSumOrderByAggregateInput = {
    tailor_id?: SortOrder
    experience_years?: SortOrder
    hourly_rate?: SortOrder
  }

  export type OrdersScalarRelationFilter = {
    is?: OrdersWhereInput
    isNot?: OrdersWhereInput
  }

  export type TailorScalarRelationFilter = {
    is?: TailorWhereInput
    isNot?: TailorWhereInput
  }

  export type OrderTailorOrderNoTailor_idCompoundUniqueInput = {
    orderNo: string
    tailor_id: number
  }

  export type OrderTailorCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    tailor_id?: SortOrder
    assigned_at?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    notes?: SortOrder
  }

  export type OrderTailorAvgOrderByAggregateInput = {
    id?: SortOrder
    tailor_id?: SortOrder
  }

  export type OrderTailorMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    tailor_id?: SortOrder
    assigned_at?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    notes?: SortOrder
  }

  export type OrderTailorMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    tailor_id?: SortOrder
    assigned_at?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    notes?: SortOrder
  }

  export type OrderTailorSumOrderByAggregateInput = {
    id?: SortOrder
    tailor_id?: SortOrder
  }

  export type RawMaterialsOrderListCountOrderByAggregateInput = {
    order_id?: SortOrder
    product_name?: SortOrder
    description?: SortOrder
    raw_material_code?: SortOrder
    color?: SortOrder
    supplier_name?: SortOrder
    quantity?: SortOrder
    ordered_date?: SortOrder
    supplier_id?: SortOrder
  }

  export type RawMaterialsOrderListAvgOrderByAggregateInput = {
    order_id?: SortOrder
    quantity?: SortOrder
    supplier_id?: SortOrder
  }

  export type RawMaterialsOrderListMaxOrderByAggregateInput = {
    order_id?: SortOrder
    product_name?: SortOrder
    description?: SortOrder
    raw_material_code?: SortOrder
    color?: SortOrder
    supplier_name?: SortOrder
    quantity?: SortOrder
    ordered_date?: SortOrder
    supplier_id?: SortOrder
  }

  export type RawMaterialsOrderListMinOrderByAggregateInput = {
    order_id?: SortOrder
    product_name?: SortOrder
    description?: SortOrder
    raw_material_code?: SortOrder
    color?: SortOrder
    supplier_name?: SortOrder
    quantity?: SortOrder
    ordered_date?: SortOrder
    supplier_id?: SortOrder
  }

  export type RawMaterialsOrderListSumOrderByAggregateInput = {
    order_id?: SortOrder
    quantity?: SortOrder
    supplier_id?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type LogEntryListRelationFilter = {
    every?: LogEntryWhereInput
    some?: LogEntryWhereInput
    none?: LogEntryWhereInput
  }

  export type LogEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LogEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type LogEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LogEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type LogEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type LogEntrySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusFilter<$PrismaModel> | $Enums.ProductionStatus
  }

  export type OrderProductionCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
  }

  export type OrderProductionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderProductionMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
  }

  export type OrderProductionMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
  }

  export type OrderProductionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionStatusFilter<$PrismaModel>
  }

  export type RackCreateNestedManyWithoutLocationInput = {
    create?: XOR<RackCreateWithoutLocationInput, RackUncheckedCreateWithoutLocationInput> | RackCreateWithoutLocationInput[] | RackUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RackCreateOrConnectWithoutLocationInput | RackCreateOrConnectWithoutLocationInput[]
    createMany?: RackCreateManyLocationInputEnvelope
    connect?: RackWhereUniqueInput | RackWhereUniqueInput[]
  }

  export type RackUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<RackCreateWithoutLocationInput, RackUncheckedCreateWithoutLocationInput> | RackCreateWithoutLocationInput[] | RackUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RackCreateOrConnectWithoutLocationInput | RackCreateOrConnectWithoutLocationInput[]
    createMany?: RackCreateManyLocationInputEnvelope
    connect?: RackWhereUniqueInput | RackWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RackUpdateManyWithoutLocationNestedInput = {
    create?: XOR<RackCreateWithoutLocationInput, RackUncheckedCreateWithoutLocationInput> | RackCreateWithoutLocationInput[] | RackUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RackCreateOrConnectWithoutLocationInput | RackCreateOrConnectWithoutLocationInput[]
    upsert?: RackUpsertWithWhereUniqueWithoutLocationInput | RackUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: RackCreateManyLocationInputEnvelope
    set?: RackWhereUniqueInput | RackWhereUniqueInput[]
    disconnect?: RackWhereUniqueInput | RackWhereUniqueInput[]
    delete?: RackWhereUniqueInput | RackWhereUniqueInput[]
    connect?: RackWhereUniqueInput | RackWhereUniqueInput[]
    update?: RackUpdateWithWhereUniqueWithoutLocationInput | RackUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: RackUpdateManyWithWhereWithoutLocationInput | RackUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: RackScalarWhereInput | RackScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RackUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<RackCreateWithoutLocationInput, RackUncheckedCreateWithoutLocationInput> | RackCreateWithoutLocationInput[] | RackUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RackCreateOrConnectWithoutLocationInput | RackCreateOrConnectWithoutLocationInput[]
    upsert?: RackUpsertWithWhereUniqueWithoutLocationInput | RackUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: RackCreateManyLocationInputEnvelope
    set?: RackWhereUniqueInput | RackWhereUniqueInput[]
    disconnect?: RackWhereUniqueInput | RackWhereUniqueInput[]
    delete?: RackWhereUniqueInput | RackWhereUniqueInput[]
    connect?: RackWhereUniqueInput | RackWhereUniqueInput[]
    update?: RackUpdateWithWhereUniqueWithoutLocationInput | RackUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: RackUpdateManyWithWhereWithoutLocationInput | RackUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: RackScalarWhereInput | RackScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutRacksInput = {
    create?: XOR<LocationCreateWithoutRacksInput, LocationUncheckedCreateWithoutRacksInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRacksInput
    connect?: LocationWhereUniqueInput
  }

  export type BunchCreateNestedManyWithoutRackInput = {
    create?: XOR<BunchCreateWithoutRackInput, BunchUncheckedCreateWithoutRackInput> | BunchCreateWithoutRackInput[] | BunchUncheckedCreateWithoutRackInput[]
    connectOrCreate?: BunchCreateOrConnectWithoutRackInput | BunchCreateOrConnectWithoutRackInput[]
    createMany?: BunchCreateManyRackInputEnvelope
    connect?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
  }

  export type BunchUncheckedCreateNestedManyWithoutRackInput = {
    create?: XOR<BunchCreateWithoutRackInput, BunchUncheckedCreateWithoutRackInput> | BunchCreateWithoutRackInput[] | BunchUncheckedCreateWithoutRackInput[]
    connectOrCreate?: BunchCreateOrConnectWithoutRackInput | BunchCreateOrConnectWithoutRackInput[]
    createMany?: BunchCreateManyRackInputEnvelope
    connect?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutRacksNestedInput = {
    create?: XOR<LocationCreateWithoutRacksInput, LocationUncheckedCreateWithoutRacksInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRacksInput
    upsert?: LocationUpsertWithoutRacksInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRacksInput, LocationUpdateWithoutRacksInput>, LocationUncheckedUpdateWithoutRacksInput>
  }

  export type BunchUpdateManyWithoutRackNestedInput = {
    create?: XOR<BunchCreateWithoutRackInput, BunchUncheckedCreateWithoutRackInput> | BunchCreateWithoutRackInput[] | BunchUncheckedCreateWithoutRackInput[]
    connectOrCreate?: BunchCreateOrConnectWithoutRackInput | BunchCreateOrConnectWithoutRackInput[]
    upsert?: BunchUpsertWithWhereUniqueWithoutRackInput | BunchUpsertWithWhereUniqueWithoutRackInput[]
    createMany?: BunchCreateManyRackInputEnvelope
    set?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    disconnect?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    delete?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    connect?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    update?: BunchUpdateWithWhereUniqueWithoutRackInput | BunchUpdateWithWhereUniqueWithoutRackInput[]
    updateMany?: BunchUpdateManyWithWhereWithoutRackInput | BunchUpdateManyWithWhereWithoutRackInput[]
    deleteMany?: BunchScalarWhereInput | BunchScalarWhereInput[]
  }

  export type BunchUncheckedUpdateManyWithoutRackNestedInput = {
    create?: XOR<BunchCreateWithoutRackInput, BunchUncheckedCreateWithoutRackInput> | BunchCreateWithoutRackInput[] | BunchUncheckedCreateWithoutRackInput[]
    connectOrCreate?: BunchCreateOrConnectWithoutRackInput | BunchCreateOrConnectWithoutRackInput[]
    upsert?: BunchUpsertWithWhereUniqueWithoutRackInput | BunchUpsertWithWhereUniqueWithoutRackInput[]
    createMany?: BunchCreateManyRackInputEnvelope
    set?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    disconnect?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    delete?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    connect?: BunchWhereUniqueInput | BunchWhereUniqueInput[]
    update?: BunchUpdateWithWhereUniqueWithoutRackInput | BunchUpdateWithWhereUniqueWithoutRackInput[]
    updateMany?: BunchUpdateManyWithWhereWithoutRackInput | BunchUpdateManyWithWhereWithoutRackInput[]
    deleteMany?: BunchScalarWhereInput | BunchScalarWhereInput[]
  }

  export type RackCreateNestedOneWithoutBunchesInput = {
    create?: XOR<RackCreateWithoutBunchesInput, RackUncheckedCreateWithoutBunchesInput>
    connectOrCreate?: RackCreateOrConnectWithoutBunchesInput
    connect?: RackWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutBunchInput = {
    create?: XOR<InventoryItemCreateWithoutBunchInput, InventoryItemUncheckedCreateWithoutBunchInput> | InventoryItemCreateWithoutBunchInput[] | InventoryItemUncheckedCreateWithoutBunchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBunchInput | InventoryItemCreateOrConnectWithoutBunchInput[]
    createMany?: InventoryItemCreateManyBunchInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutBunchInput = {
    create?: XOR<InventoryItemCreateWithoutBunchInput, InventoryItemUncheckedCreateWithoutBunchInput> | InventoryItemCreateWithoutBunchInput[] | InventoryItemUncheckedCreateWithoutBunchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBunchInput | InventoryItemCreateOrConnectWithoutBunchInput[]
    createMany?: InventoryItemCreateManyBunchInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type RackUpdateOneRequiredWithoutBunchesNestedInput = {
    create?: XOR<RackCreateWithoutBunchesInput, RackUncheckedCreateWithoutBunchesInput>
    connectOrCreate?: RackCreateOrConnectWithoutBunchesInput
    upsert?: RackUpsertWithoutBunchesInput
    connect?: RackWhereUniqueInput
    update?: XOR<XOR<RackUpdateToOneWithWhereWithoutBunchesInput, RackUpdateWithoutBunchesInput>, RackUncheckedUpdateWithoutBunchesInput>
  }

  export type InventoryItemUpdateManyWithoutBunchNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBunchInput, InventoryItemUncheckedCreateWithoutBunchInput> | InventoryItemCreateWithoutBunchInput[] | InventoryItemUncheckedCreateWithoutBunchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBunchInput | InventoryItemCreateOrConnectWithoutBunchInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBunchInput | InventoryItemUpsertWithWhereUniqueWithoutBunchInput[]
    createMany?: InventoryItemCreateManyBunchInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBunchInput | InventoryItemUpdateWithWhereUniqueWithoutBunchInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBunchInput | InventoryItemUpdateManyWithWhereWithoutBunchInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutBunchNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBunchInput, InventoryItemUncheckedCreateWithoutBunchInput> | InventoryItemCreateWithoutBunchInput[] | InventoryItemUncheckedCreateWithoutBunchInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBunchInput | InventoryItemCreateOrConnectWithoutBunchInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBunchInput | InventoryItemUpsertWithWhereUniqueWithoutBunchInput[]
    createMany?: InventoryItemCreateManyBunchInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBunchInput | InventoryItemUpdateWithWhereUniqueWithoutBunchInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBunchInput | InventoryItemUpdateManyWithWhereWithoutBunchInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<InventoryItemCreateWithoutUnitInput, InventoryItemUncheckedCreateWithoutUnitInput> | InventoryItemCreateWithoutUnitInput[] | InventoryItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUnitInput | InventoryItemCreateOrConnectWithoutUnitInput[]
    createMany?: InventoryItemCreateManyUnitInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<InventoryItemCreateWithoutUnitInput, InventoryItemUncheckedCreateWithoutUnitInput> | InventoryItemCreateWithoutUnitInput[] | InventoryItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUnitInput | InventoryItemCreateOrConnectWithoutUnitInput[]
    createMany?: InventoryItemCreateManyUnitInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<InventoryItemCreateWithoutUnitInput, InventoryItemUncheckedCreateWithoutUnitInput> | InventoryItemCreateWithoutUnitInput[] | InventoryItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUnitInput | InventoryItemCreateOrConnectWithoutUnitInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutUnitInput | InventoryItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: InventoryItemCreateManyUnitInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutUnitInput | InventoryItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutUnitInput | InventoryItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<InventoryItemCreateWithoutUnitInput, InventoryItemUncheckedCreateWithoutUnitInput> | InventoryItemCreateWithoutUnitInput[] | InventoryItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUnitInput | InventoryItemCreateOrConnectWithoutUnitInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutUnitInput | InventoryItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: InventoryItemCreateManyUnitInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutUnitInput | InventoryItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutUnitInput | InventoryItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutMovement_logsInput = {
    create?: XOR<InventoryItemCreateWithoutMovement_logsInput, InventoryItemUncheckedCreateWithoutMovement_logsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutMovement_logsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type EnumMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.MovementType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryItemUpdateOneRequiredWithoutMovement_logsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutMovement_logsInput, InventoryItemUncheckedCreateWithoutMovement_logsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutMovement_logsInput
    upsert?: InventoryItemUpsertWithoutMovement_logsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutMovement_logsInput, InventoryItemUpdateWithoutMovement_logsInput>, InventoryItemUncheckedUpdateWithoutMovement_logsInput>
  }

  export type InventoryItemCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<InventoryItemCreateWithoutSuppliersInput, InventoryItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSuppliersInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutItemSupplierInput = {
    create?: XOR<SupplierCreateWithoutItemSupplierInput, SupplierUncheckedCreateWithoutItemSupplierInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemSupplierInput
    connect?: SupplierWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<InventoryItemCreateWithoutSuppliersInput, InventoryItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSuppliersInput
    upsert?: InventoryItemUpsertWithoutSuppliersInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutSuppliersInput, InventoryItemUpdateWithoutSuppliersInput>, InventoryItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierUpdateOneRequiredWithoutItemSupplierNestedInput = {
    create?: XOR<SupplierCreateWithoutItemSupplierInput, SupplierUncheckedCreateWithoutItemSupplierInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemSupplierInput
    upsert?: SupplierUpsertWithoutItemSupplierInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutItemSupplierInput, SupplierUpdateWithoutItemSupplierInput>, SupplierUncheckedUpdateWithoutItemSupplierInput>
  }

  export type BunchCreateNestedOneWithoutItemsInput = {
    create?: XOR<BunchCreateWithoutItemsInput, BunchUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BunchCreateOrConnectWithoutItemsInput
    connect?: BunchWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutItemsInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type ItemSupplierCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type ItemSupplierUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type EnumInventoryItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.InventoryItemType
  }

  export type BunchUpdateOneWithoutItemsNestedInput = {
    create?: XOR<BunchCreateWithoutItemsInput, BunchUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BunchCreateOrConnectWithoutItemsInput
    upsert?: BunchUpsertWithoutItemsInput
    disconnect?: BunchWhereInput | boolean
    delete?: BunchWhereInput | boolean
    connect?: BunchWhereUniqueInput
    update?: XOR<XOR<BunchUpdateToOneWithWhereWithoutItemsInput, BunchUpdateWithoutItemsInput>, BunchUncheckedUpdateWithoutItemsInput>
  }

  export type UnitUpdateOneWithoutItemsNestedInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    upsert?: UnitUpsertWithoutItemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutItemsInput, UnitUpdateWithoutItemsInput>, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type ItemSupplierUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutItemInput | ItemSupplierUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutItemInput | ItemSupplierUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutItemInput | ItemSupplierUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ItemSupplierUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput> | ItemSupplierCreateWithoutItemInput[] | ItemSupplierUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutItemInput | ItemSupplierCreateOrConnectWithoutItemInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutItemInput | ItemSupplierUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemSupplierCreateManyItemInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutItemInput | ItemSupplierUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutItemInput | ItemSupplierUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput> | InventoryMovementCreateWithoutItemInput[] | InventoryMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutItemInput | InventoryMovementCreateOrConnectWithoutItemInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutItemInput | InventoryMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryMovementCreateManyItemInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutItemInput | InventoryMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutItemInput | InventoryMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrdersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrdersCreateWithoutCustomerInput, OrdersUncheckedCreateWithoutCustomerInput> | OrdersCreateWithoutCustomerInput[] | OrdersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomerInput | OrdersCreateOrConnectWithoutCustomerInput[]
    createMany?: OrdersCreateManyCustomerInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type FinalJacketMeasurementCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutCustomerInput, FinalJacketMeasurementUncheckedCreateWithoutCustomerInput> | FinalJacketMeasurementCreateWithoutCustomerInput[] | FinalJacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutCustomerInput | FinalJacketMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: FinalJacketMeasurementCreateManyCustomerInputEnvelope
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
  }

  export type FinalPantMeasurementCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutCustomerInput, FinalPantMeasurementUncheckedCreateWithoutCustomerInput> | FinalPantMeasurementCreateWithoutCustomerInput[] | FinalPantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutCustomerInput | FinalPantMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: FinalPantMeasurementCreateManyCustomerInputEnvelope
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
  }

  export type FinalShirtMeasurementCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutCustomerInput, FinalShirtMeasurementUncheckedCreateWithoutCustomerInput> | FinalShirtMeasurementCreateWithoutCustomerInput[] | FinalShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutCustomerInput | FinalShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: FinalShirtMeasurementCreateManyCustomerInputEnvelope
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
  }

  export type JacketMeasurementCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JacketMeasurementCreateWithoutCustomerInput, JacketMeasurementUncheckedCreateWithoutCustomerInput> | JacketMeasurementCreateWithoutCustomerInput[] | JacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutCustomerInput | JacketMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: JacketMeasurementCreateManyCustomerInputEnvelope
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
  }

  export type PantMeasurementCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PantMeasurementCreateWithoutCustomerInput, PantMeasurementUncheckedCreateWithoutCustomerInput> | PantMeasurementCreateWithoutCustomerInput[] | PantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutCustomerInput | PantMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: PantMeasurementCreateManyCustomerInputEnvelope
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
  }

  export type ShirtMeasurementCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ShirtMeasurementCreateWithoutCustomerInput, ShirtMeasurementUncheckedCreateWithoutCustomerInput> | ShirtMeasurementCreateWithoutCustomerInput[] | ShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutCustomerInput | ShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: ShirtMeasurementCreateManyCustomerInputEnvelope
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrdersCreateWithoutCustomerInput, OrdersUncheckedCreateWithoutCustomerInput> | OrdersCreateWithoutCustomerInput[] | OrdersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomerInput | OrdersCreateOrConnectWithoutCustomerInput[]
    createMany?: OrdersCreateManyCustomerInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutCustomerInput, FinalJacketMeasurementUncheckedCreateWithoutCustomerInput> | FinalJacketMeasurementCreateWithoutCustomerInput[] | FinalJacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutCustomerInput | FinalJacketMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: FinalJacketMeasurementCreateManyCustomerInputEnvelope
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
  }

  export type FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutCustomerInput, FinalPantMeasurementUncheckedCreateWithoutCustomerInput> | FinalPantMeasurementCreateWithoutCustomerInput[] | FinalPantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutCustomerInput | FinalPantMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: FinalPantMeasurementCreateManyCustomerInputEnvelope
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
  }

  export type FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutCustomerInput, FinalShirtMeasurementUncheckedCreateWithoutCustomerInput> | FinalShirtMeasurementCreateWithoutCustomerInput[] | FinalShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutCustomerInput | FinalShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: FinalShirtMeasurementCreateManyCustomerInputEnvelope
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
  }

  export type JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<JacketMeasurementCreateWithoutCustomerInput, JacketMeasurementUncheckedCreateWithoutCustomerInput> | JacketMeasurementCreateWithoutCustomerInput[] | JacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutCustomerInput | JacketMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: JacketMeasurementCreateManyCustomerInputEnvelope
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
  }

  export type PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PantMeasurementCreateWithoutCustomerInput, PantMeasurementUncheckedCreateWithoutCustomerInput> | PantMeasurementCreateWithoutCustomerInput[] | PantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutCustomerInput | PantMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: PantMeasurementCreateManyCustomerInputEnvelope
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
  }

  export type ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ShirtMeasurementCreateWithoutCustomerInput, ShirtMeasurementUncheckedCreateWithoutCustomerInput> | ShirtMeasurementCreateWithoutCustomerInput[] | ShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutCustomerInput | ShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    createMany?: ShirtMeasurementCreateManyCustomerInputEnvelope
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrdersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrdersCreateWithoutCustomerInput, OrdersUncheckedCreateWithoutCustomerInput> | OrdersCreateWithoutCustomerInput[] | OrdersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomerInput | OrdersCreateOrConnectWithoutCustomerInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutCustomerInput | OrdersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrdersCreateManyCustomerInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutCustomerInput | OrdersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutCustomerInput | OrdersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutCustomerInput, FinalJacketMeasurementUncheckedCreateWithoutCustomerInput> | FinalJacketMeasurementCreateWithoutCustomerInput[] | FinalJacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutCustomerInput | FinalJacketMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: FinalJacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput | FinalJacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FinalJacketMeasurementCreateManyCustomerInputEnvelope
    set?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    disconnect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    delete?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    update?: FinalJacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput | FinalJacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FinalJacketMeasurementUpdateManyWithWhereWithoutCustomerInput | FinalJacketMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FinalJacketMeasurementScalarWhereInput | FinalJacketMeasurementScalarWhereInput[]
  }

  export type FinalPantMeasurementUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutCustomerInput, FinalPantMeasurementUncheckedCreateWithoutCustomerInput> | FinalPantMeasurementCreateWithoutCustomerInput[] | FinalPantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutCustomerInput | FinalPantMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: FinalPantMeasurementUpsertWithWhereUniqueWithoutCustomerInput | FinalPantMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FinalPantMeasurementCreateManyCustomerInputEnvelope
    set?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    disconnect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    delete?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    update?: FinalPantMeasurementUpdateWithWhereUniqueWithoutCustomerInput | FinalPantMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FinalPantMeasurementUpdateManyWithWhereWithoutCustomerInput | FinalPantMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FinalPantMeasurementScalarWhereInput | FinalPantMeasurementScalarWhereInput[]
  }

  export type FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutCustomerInput, FinalShirtMeasurementUncheckedCreateWithoutCustomerInput> | FinalShirtMeasurementCreateWithoutCustomerInput[] | FinalShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutCustomerInput | FinalShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: FinalShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput | FinalShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FinalShirtMeasurementCreateManyCustomerInputEnvelope
    set?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    disconnect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    delete?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    update?: FinalShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput | FinalShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FinalShirtMeasurementUpdateManyWithWhereWithoutCustomerInput | FinalShirtMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FinalShirtMeasurementScalarWhereInput | FinalShirtMeasurementScalarWhereInput[]
  }

  export type JacketMeasurementUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JacketMeasurementCreateWithoutCustomerInput, JacketMeasurementUncheckedCreateWithoutCustomerInput> | JacketMeasurementCreateWithoutCustomerInput[] | JacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutCustomerInput | JacketMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: JacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput | JacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JacketMeasurementCreateManyCustomerInputEnvelope
    set?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    disconnect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    delete?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    update?: JacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput | JacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JacketMeasurementUpdateManyWithWhereWithoutCustomerInput | JacketMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JacketMeasurementScalarWhereInput | JacketMeasurementScalarWhereInput[]
  }

  export type PantMeasurementUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PantMeasurementCreateWithoutCustomerInput, PantMeasurementUncheckedCreateWithoutCustomerInput> | PantMeasurementCreateWithoutCustomerInput[] | PantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutCustomerInput | PantMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: PantMeasurementUpsertWithWhereUniqueWithoutCustomerInput | PantMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PantMeasurementCreateManyCustomerInputEnvelope
    set?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    disconnect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    delete?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    update?: PantMeasurementUpdateWithWhereUniqueWithoutCustomerInput | PantMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PantMeasurementUpdateManyWithWhereWithoutCustomerInput | PantMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PantMeasurementScalarWhereInput | PantMeasurementScalarWhereInput[]
  }

  export type ShirtMeasurementUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ShirtMeasurementCreateWithoutCustomerInput, ShirtMeasurementUncheckedCreateWithoutCustomerInput> | ShirtMeasurementCreateWithoutCustomerInput[] | ShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutCustomerInput | ShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: ShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput | ShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ShirtMeasurementCreateManyCustomerInputEnvelope
    set?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    disconnect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    delete?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    update?: ShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput | ShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ShirtMeasurementUpdateManyWithWhereWithoutCustomerInput | ShirtMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ShirtMeasurementScalarWhereInput | ShirtMeasurementScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrdersCreateWithoutCustomerInput, OrdersUncheckedCreateWithoutCustomerInput> | OrdersCreateWithoutCustomerInput[] | OrdersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomerInput | OrdersCreateOrConnectWithoutCustomerInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutCustomerInput | OrdersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrdersCreateManyCustomerInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutCustomerInput | OrdersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutCustomerInput | OrdersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutCustomerInput, FinalJacketMeasurementUncheckedCreateWithoutCustomerInput> | FinalJacketMeasurementCreateWithoutCustomerInput[] | FinalJacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutCustomerInput | FinalJacketMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: FinalJacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput | FinalJacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FinalJacketMeasurementCreateManyCustomerInputEnvelope
    set?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    disconnect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    delete?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    update?: FinalJacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput | FinalJacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FinalJacketMeasurementUpdateManyWithWhereWithoutCustomerInput | FinalJacketMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FinalJacketMeasurementScalarWhereInput | FinalJacketMeasurementScalarWhereInput[]
  }

  export type FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutCustomerInput, FinalPantMeasurementUncheckedCreateWithoutCustomerInput> | FinalPantMeasurementCreateWithoutCustomerInput[] | FinalPantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutCustomerInput | FinalPantMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: FinalPantMeasurementUpsertWithWhereUniqueWithoutCustomerInput | FinalPantMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FinalPantMeasurementCreateManyCustomerInputEnvelope
    set?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    disconnect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    delete?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    update?: FinalPantMeasurementUpdateWithWhereUniqueWithoutCustomerInput | FinalPantMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FinalPantMeasurementUpdateManyWithWhereWithoutCustomerInput | FinalPantMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FinalPantMeasurementScalarWhereInput | FinalPantMeasurementScalarWhereInput[]
  }

  export type FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutCustomerInput, FinalShirtMeasurementUncheckedCreateWithoutCustomerInput> | FinalShirtMeasurementCreateWithoutCustomerInput[] | FinalShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutCustomerInput | FinalShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: FinalShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput | FinalShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FinalShirtMeasurementCreateManyCustomerInputEnvelope
    set?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    disconnect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    delete?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    update?: FinalShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput | FinalShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FinalShirtMeasurementUpdateManyWithWhereWithoutCustomerInput | FinalShirtMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FinalShirtMeasurementScalarWhereInput | FinalShirtMeasurementScalarWhereInput[]
  }

  export type JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<JacketMeasurementCreateWithoutCustomerInput, JacketMeasurementUncheckedCreateWithoutCustomerInput> | JacketMeasurementCreateWithoutCustomerInput[] | JacketMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutCustomerInput | JacketMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: JacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput | JacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: JacketMeasurementCreateManyCustomerInputEnvelope
    set?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    disconnect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    delete?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    update?: JacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput | JacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: JacketMeasurementUpdateManyWithWhereWithoutCustomerInput | JacketMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: JacketMeasurementScalarWhereInput | JacketMeasurementScalarWhereInput[]
  }

  export type PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PantMeasurementCreateWithoutCustomerInput, PantMeasurementUncheckedCreateWithoutCustomerInput> | PantMeasurementCreateWithoutCustomerInput[] | PantMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutCustomerInput | PantMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: PantMeasurementUpsertWithWhereUniqueWithoutCustomerInput | PantMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PantMeasurementCreateManyCustomerInputEnvelope
    set?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    disconnect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    delete?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    update?: PantMeasurementUpdateWithWhereUniqueWithoutCustomerInput | PantMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PantMeasurementUpdateManyWithWhereWithoutCustomerInput | PantMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PantMeasurementScalarWhereInput | PantMeasurementScalarWhereInput[]
  }

  export type ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ShirtMeasurementCreateWithoutCustomerInput, ShirtMeasurementUncheckedCreateWithoutCustomerInput> | ShirtMeasurementCreateWithoutCustomerInput[] | ShirtMeasurementUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutCustomerInput | ShirtMeasurementCreateOrConnectWithoutCustomerInput[]
    upsert?: ShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput | ShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ShirtMeasurementCreateManyCustomerInputEnvelope
    set?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    disconnect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    delete?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    update?: ShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput | ShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ShirtMeasurementUpdateManyWithWhereWithoutCustomerInput | ShirtMeasurementUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ShirtMeasurementScalarWhereInput | ShirtMeasurementScalarWhereInput[]
  }

  export type FabricOrderListCreateNestedManyWithoutFabricInput = {
    create?: XOR<FabricOrderListCreateWithoutFabricInput, FabricOrderListUncheckedCreateWithoutFabricInput> | FabricOrderListCreateWithoutFabricInput[] | FabricOrderListUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutFabricInput | FabricOrderListCreateOrConnectWithoutFabricInput[]
    createMany?: FabricOrderListCreateManyFabricInputEnvelope
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
  }

  export type ItemsCreateNestedManyWithoutFabricInput = {
    create?: XOR<ItemsCreateWithoutFabricInput, ItemsUncheckedCreateWithoutFabricInput> | ItemsCreateWithoutFabricInput[] | ItemsUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFabricInput | ItemsCreateOrConnectWithoutFabricInput[]
    createMany?: ItemsCreateManyFabricInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsCreateNestedManyWithoutLining_fabricInput = {
    create?: XOR<ItemsCreateWithoutLining_fabricInput, ItemsUncheckedCreateWithoutLining_fabricInput> | ItemsCreateWithoutLining_fabricInput[] | ItemsUncheckedCreateWithoutLining_fabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutLining_fabricInput | ItemsCreateOrConnectWithoutLining_fabricInput[]
    createMany?: ItemsCreateManyLining_fabricInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type FabricOrderListUncheckedCreateNestedManyWithoutFabricInput = {
    create?: XOR<FabricOrderListCreateWithoutFabricInput, FabricOrderListUncheckedCreateWithoutFabricInput> | FabricOrderListCreateWithoutFabricInput[] | FabricOrderListUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutFabricInput | FabricOrderListCreateOrConnectWithoutFabricInput[]
    createMany?: FabricOrderListCreateManyFabricInputEnvelope
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutFabricInput = {
    create?: XOR<ItemsCreateWithoutFabricInput, ItemsUncheckedCreateWithoutFabricInput> | ItemsCreateWithoutFabricInput[] | ItemsUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFabricInput | ItemsCreateOrConnectWithoutFabricInput[]
    createMany?: ItemsCreateManyFabricInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutLining_fabricInput = {
    create?: XOR<ItemsCreateWithoutLining_fabricInput, ItemsUncheckedCreateWithoutLining_fabricInput> | ItemsCreateWithoutLining_fabricInput[] | ItemsUncheckedCreateWithoutLining_fabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutLining_fabricInput | ItemsCreateOrConnectWithoutLining_fabricInput[]
    createMany?: ItemsCreateManyLining_fabricInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type FabricOrderListUpdateManyWithoutFabricNestedInput = {
    create?: XOR<FabricOrderListCreateWithoutFabricInput, FabricOrderListUncheckedCreateWithoutFabricInput> | FabricOrderListCreateWithoutFabricInput[] | FabricOrderListUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutFabricInput | FabricOrderListCreateOrConnectWithoutFabricInput[]
    upsert?: FabricOrderListUpsertWithWhereUniqueWithoutFabricInput | FabricOrderListUpsertWithWhereUniqueWithoutFabricInput[]
    createMany?: FabricOrderListCreateManyFabricInputEnvelope
    set?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    disconnect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    delete?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    update?: FabricOrderListUpdateWithWhereUniqueWithoutFabricInput | FabricOrderListUpdateWithWhereUniqueWithoutFabricInput[]
    updateMany?: FabricOrderListUpdateManyWithWhereWithoutFabricInput | FabricOrderListUpdateManyWithWhereWithoutFabricInput[]
    deleteMany?: FabricOrderListScalarWhereInput | FabricOrderListScalarWhereInput[]
  }

  export type ItemsUpdateManyWithoutFabricNestedInput = {
    create?: XOR<ItemsCreateWithoutFabricInput, ItemsUncheckedCreateWithoutFabricInput> | ItemsCreateWithoutFabricInput[] | ItemsUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFabricInput | ItemsCreateOrConnectWithoutFabricInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFabricInput | ItemsUpsertWithWhereUniqueWithoutFabricInput[]
    createMany?: ItemsCreateManyFabricInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFabricInput | ItemsUpdateWithWhereUniqueWithoutFabricInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFabricInput | ItemsUpdateManyWithWhereWithoutFabricInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUpdateManyWithoutLining_fabricNestedInput = {
    create?: XOR<ItemsCreateWithoutLining_fabricInput, ItemsUncheckedCreateWithoutLining_fabricInput> | ItemsCreateWithoutLining_fabricInput[] | ItemsUncheckedCreateWithoutLining_fabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutLining_fabricInput | ItemsCreateOrConnectWithoutLining_fabricInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutLining_fabricInput | ItemsUpsertWithWhereUniqueWithoutLining_fabricInput[]
    createMany?: ItemsCreateManyLining_fabricInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutLining_fabricInput | ItemsUpdateWithWhereUniqueWithoutLining_fabricInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutLining_fabricInput | ItemsUpdateManyWithWhereWithoutLining_fabricInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type FabricOrderListUncheckedUpdateManyWithoutFabricNestedInput = {
    create?: XOR<FabricOrderListCreateWithoutFabricInput, FabricOrderListUncheckedCreateWithoutFabricInput> | FabricOrderListCreateWithoutFabricInput[] | FabricOrderListUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutFabricInput | FabricOrderListCreateOrConnectWithoutFabricInput[]
    upsert?: FabricOrderListUpsertWithWhereUniqueWithoutFabricInput | FabricOrderListUpsertWithWhereUniqueWithoutFabricInput[]
    createMany?: FabricOrderListCreateManyFabricInputEnvelope
    set?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    disconnect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    delete?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    update?: FabricOrderListUpdateWithWhereUniqueWithoutFabricInput | FabricOrderListUpdateWithWhereUniqueWithoutFabricInput[]
    updateMany?: FabricOrderListUpdateManyWithWhereWithoutFabricInput | FabricOrderListUpdateManyWithWhereWithoutFabricInput[]
    deleteMany?: FabricOrderListScalarWhereInput | FabricOrderListScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutFabricNestedInput = {
    create?: XOR<ItemsCreateWithoutFabricInput, ItemsUncheckedCreateWithoutFabricInput> | ItemsCreateWithoutFabricInput[] | ItemsUncheckedCreateWithoutFabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFabricInput | ItemsCreateOrConnectWithoutFabricInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFabricInput | ItemsUpsertWithWhereUniqueWithoutFabricInput[]
    createMany?: ItemsCreateManyFabricInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFabricInput | ItemsUpdateWithWhereUniqueWithoutFabricInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFabricInput | ItemsUpdateManyWithWhereWithoutFabricInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutLining_fabricNestedInput = {
    create?: XOR<ItemsCreateWithoutLining_fabricInput, ItemsUncheckedCreateWithoutLining_fabricInput> | ItemsCreateWithoutLining_fabricInput[] | ItemsUncheckedCreateWithoutLining_fabricInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutLining_fabricInput | ItemsCreateOrConnectWithoutLining_fabricInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutLining_fabricInput | ItemsUpsertWithWhereUniqueWithoutLining_fabricInput[]
    createMany?: ItemsCreateManyLining_fabricInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutLining_fabricInput | ItemsUpdateWithWhereUniqueWithoutLining_fabricInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutLining_fabricInput | ItemsUpdateManyWithWhereWithoutLining_fabricInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type FabricCreateNestedOneWithoutFabricOrdersInput = {
    create?: XOR<FabricCreateWithoutFabricOrdersInput, FabricUncheckedCreateWithoutFabricOrdersInput>
    connectOrCreate?: FabricCreateOrConnectWithoutFabricOrdersInput
    connect?: FabricWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutFabricOrderListInput = {
    create?: XOR<SupplierCreateWithoutFabricOrderListInput, SupplierUncheckedCreateWithoutFabricOrderListInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutFabricOrderListInput
    connect?: SupplierWhereUniqueInput
  }

  export type FabricUpdateOneWithoutFabricOrdersNestedInput = {
    create?: XOR<FabricCreateWithoutFabricOrdersInput, FabricUncheckedCreateWithoutFabricOrdersInput>
    connectOrCreate?: FabricCreateOrConnectWithoutFabricOrdersInput
    upsert?: FabricUpsertWithoutFabricOrdersInput
    disconnect?: FabricWhereInput | boolean
    delete?: FabricWhereInput | boolean
    connect?: FabricWhereUniqueInput
    update?: XOR<XOR<FabricUpdateToOneWithWhereWithoutFabricOrdersInput, FabricUpdateWithoutFabricOrdersInput>, FabricUncheckedUpdateWithoutFabricOrdersInput>
  }

  export type SupplierUpdateOneWithoutFabricOrderListNestedInput = {
    create?: XOR<SupplierCreateWithoutFabricOrderListInput, SupplierUncheckedCreateWithoutFabricOrderListInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutFabricOrderListInput
    upsert?: SupplierUpsertWithoutFabricOrderListInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutFabricOrderListInput, SupplierUpdateWithoutFabricOrderListInput>, SupplierUncheckedUpdateWithoutFabricOrderListInput>
  }

  export type CustomerCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<CustomerCreateWithoutMeasurementsInput, CustomerUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMeasurementsInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutFinalJacketMeasurementInput = {
    create?: XOR<OrdersCreateWithoutFinalJacketMeasurementInput, OrdersUncheckedCreateWithoutFinalJacketMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutFinalJacketMeasurementInput
    connect?: OrdersWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutFinal_jacket_measurementInput = {
    create?: XOR<ItemsCreateWithoutFinal_jacket_measurementInput, ItemsUncheckedCreateWithoutFinal_jacket_measurementInput> | ItemsCreateWithoutFinal_jacket_measurementInput[] | ItemsUncheckedCreateWithoutFinal_jacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_jacket_measurementInput | ItemsCreateOrConnectWithoutFinal_jacket_measurementInput[]
    createMany?: ItemsCreateManyFinal_jacket_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutFinal_jacket_measurementInput = {
    create?: XOR<ItemsCreateWithoutFinal_jacket_measurementInput, ItemsUncheckedCreateWithoutFinal_jacket_measurementInput> | ItemsCreateWithoutFinal_jacket_measurementInput[] | ItemsUncheckedCreateWithoutFinal_jacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_jacket_measurementInput | ItemsCreateOrConnectWithoutFinal_jacket_measurementInput[]
    createMany?: ItemsCreateManyFinal_jacket_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutMeasurementsNestedInput = {
    create?: XOR<CustomerCreateWithoutMeasurementsInput, CustomerUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMeasurementsInput
    upsert?: CustomerUpsertWithoutMeasurementsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutMeasurementsInput, CustomerUpdateWithoutMeasurementsInput>, CustomerUncheckedUpdateWithoutMeasurementsInput>
  }

  export type OrdersUpdateOneWithoutFinalJacketMeasurementNestedInput = {
    create?: XOR<OrdersCreateWithoutFinalJacketMeasurementInput, OrdersUncheckedCreateWithoutFinalJacketMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutFinalJacketMeasurementInput
    upsert?: OrdersUpsertWithoutFinalJacketMeasurementInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutFinalJacketMeasurementInput, OrdersUpdateWithoutFinalJacketMeasurementInput>, OrdersUncheckedUpdateWithoutFinalJacketMeasurementInput>
  }

  export type ItemsUpdateManyWithoutFinal_jacket_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutFinal_jacket_measurementInput, ItemsUncheckedCreateWithoutFinal_jacket_measurementInput> | ItemsCreateWithoutFinal_jacket_measurementInput[] | ItemsUncheckedCreateWithoutFinal_jacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_jacket_measurementInput | ItemsCreateOrConnectWithoutFinal_jacket_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFinal_jacket_measurementInput | ItemsUpsertWithWhereUniqueWithoutFinal_jacket_measurementInput[]
    createMany?: ItemsCreateManyFinal_jacket_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFinal_jacket_measurementInput | ItemsUpdateWithWhereUniqueWithoutFinal_jacket_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFinal_jacket_measurementInput | ItemsUpdateManyWithWhereWithoutFinal_jacket_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutFinal_jacket_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutFinal_jacket_measurementInput, ItemsUncheckedCreateWithoutFinal_jacket_measurementInput> | ItemsCreateWithoutFinal_jacket_measurementInput[] | ItemsUncheckedCreateWithoutFinal_jacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_jacket_measurementInput | ItemsCreateOrConnectWithoutFinal_jacket_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFinal_jacket_measurementInput | ItemsUpsertWithWhereUniqueWithoutFinal_jacket_measurementInput[]
    createMany?: ItemsCreateManyFinal_jacket_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFinal_jacket_measurementInput | ItemsUpdateWithWhereUniqueWithoutFinal_jacket_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFinal_jacket_measurementInput | ItemsUpdateManyWithWhereWithoutFinal_jacket_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutJacketMeasurementInput = {
    create?: XOR<CustomerCreateWithoutJacketMeasurementInput, CustomerUncheckedCreateWithoutJacketMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJacketMeasurementInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutJacketMeasurementInput = {
    create?: XOR<OrdersCreateWithoutJacketMeasurementInput, OrdersUncheckedCreateWithoutJacketMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutJacketMeasurementInput
    connect?: OrdersWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutJacket_measurementInput = {
    create?: XOR<ItemsCreateWithoutJacket_measurementInput, ItemsUncheckedCreateWithoutJacket_measurementInput> | ItemsCreateWithoutJacket_measurementInput[] | ItemsUncheckedCreateWithoutJacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutJacket_measurementInput | ItemsCreateOrConnectWithoutJacket_measurementInput[]
    createMany?: ItemsCreateManyJacket_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutJacket_measurementInput = {
    create?: XOR<ItemsCreateWithoutJacket_measurementInput, ItemsUncheckedCreateWithoutJacket_measurementInput> | ItemsCreateWithoutJacket_measurementInput[] | ItemsUncheckedCreateWithoutJacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutJacket_measurementInput | ItemsCreateOrConnectWithoutJacket_measurementInput[]
    createMany?: ItemsCreateManyJacket_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutJacketMeasurementNestedInput = {
    create?: XOR<CustomerCreateWithoutJacketMeasurementInput, CustomerUncheckedCreateWithoutJacketMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutJacketMeasurementInput
    upsert?: CustomerUpsertWithoutJacketMeasurementInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutJacketMeasurementInput, CustomerUpdateWithoutJacketMeasurementInput>, CustomerUncheckedUpdateWithoutJacketMeasurementInput>
  }

  export type OrdersUpdateOneWithoutJacketMeasurementNestedInput = {
    create?: XOR<OrdersCreateWithoutJacketMeasurementInput, OrdersUncheckedCreateWithoutJacketMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutJacketMeasurementInput
    upsert?: OrdersUpsertWithoutJacketMeasurementInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutJacketMeasurementInput, OrdersUpdateWithoutJacketMeasurementInput>, OrdersUncheckedUpdateWithoutJacketMeasurementInput>
  }

  export type ItemsUpdateManyWithoutJacket_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutJacket_measurementInput, ItemsUncheckedCreateWithoutJacket_measurementInput> | ItemsCreateWithoutJacket_measurementInput[] | ItemsUncheckedCreateWithoutJacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutJacket_measurementInput | ItemsCreateOrConnectWithoutJacket_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutJacket_measurementInput | ItemsUpsertWithWhereUniqueWithoutJacket_measurementInput[]
    createMany?: ItemsCreateManyJacket_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutJacket_measurementInput | ItemsUpdateWithWhereUniqueWithoutJacket_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutJacket_measurementInput | ItemsUpdateManyWithWhereWithoutJacket_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutJacket_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutJacket_measurementInput, ItemsUncheckedCreateWithoutJacket_measurementInput> | ItemsCreateWithoutJacket_measurementInput[] | ItemsUncheckedCreateWithoutJacket_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutJacket_measurementInput | ItemsCreateOrConnectWithoutJacket_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutJacket_measurementInput | ItemsUpsertWithWhereUniqueWithoutJacket_measurementInput[]
    createMany?: ItemsCreateManyJacket_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutJacket_measurementInput | ItemsUpdateWithWhereUniqueWithoutJacket_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutJacket_measurementInput | ItemsUpdateManyWithWhereWithoutJacket_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutFinalPantMeasurementInput = {
    create?: XOR<CustomerCreateWithoutFinalPantMeasurementInput, CustomerUncheckedCreateWithoutFinalPantMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFinalPantMeasurementInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutFinalPantMeasurementInput = {
    create?: XOR<OrdersCreateWithoutFinalPantMeasurementInput, OrdersUncheckedCreateWithoutFinalPantMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutFinalPantMeasurementInput
    connect?: OrdersWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutFinal_pant_measurementInput = {
    create?: XOR<ItemsCreateWithoutFinal_pant_measurementInput, ItemsUncheckedCreateWithoutFinal_pant_measurementInput> | ItemsCreateWithoutFinal_pant_measurementInput[] | ItemsUncheckedCreateWithoutFinal_pant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_pant_measurementInput | ItemsCreateOrConnectWithoutFinal_pant_measurementInput[]
    createMany?: ItemsCreateManyFinal_pant_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutFinal_pant_measurementInput = {
    create?: XOR<ItemsCreateWithoutFinal_pant_measurementInput, ItemsUncheckedCreateWithoutFinal_pant_measurementInput> | ItemsCreateWithoutFinal_pant_measurementInput[] | ItemsUncheckedCreateWithoutFinal_pant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_pant_measurementInput | ItemsCreateOrConnectWithoutFinal_pant_measurementInput[]
    createMany?: ItemsCreateManyFinal_pant_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutFinalPantMeasurementNestedInput = {
    create?: XOR<CustomerCreateWithoutFinalPantMeasurementInput, CustomerUncheckedCreateWithoutFinalPantMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFinalPantMeasurementInput
    upsert?: CustomerUpsertWithoutFinalPantMeasurementInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutFinalPantMeasurementInput, CustomerUpdateWithoutFinalPantMeasurementInput>, CustomerUncheckedUpdateWithoutFinalPantMeasurementInput>
  }

  export type OrdersUpdateOneWithoutFinalPantMeasurementNestedInput = {
    create?: XOR<OrdersCreateWithoutFinalPantMeasurementInput, OrdersUncheckedCreateWithoutFinalPantMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutFinalPantMeasurementInput
    upsert?: OrdersUpsertWithoutFinalPantMeasurementInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutFinalPantMeasurementInput, OrdersUpdateWithoutFinalPantMeasurementInput>, OrdersUncheckedUpdateWithoutFinalPantMeasurementInput>
  }

  export type ItemsUpdateManyWithoutFinal_pant_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutFinal_pant_measurementInput, ItemsUncheckedCreateWithoutFinal_pant_measurementInput> | ItemsCreateWithoutFinal_pant_measurementInput[] | ItemsUncheckedCreateWithoutFinal_pant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_pant_measurementInput | ItemsCreateOrConnectWithoutFinal_pant_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFinal_pant_measurementInput | ItemsUpsertWithWhereUniqueWithoutFinal_pant_measurementInput[]
    createMany?: ItemsCreateManyFinal_pant_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFinal_pant_measurementInput | ItemsUpdateWithWhereUniqueWithoutFinal_pant_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFinal_pant_measurementInput | ItemsUpdateManyWithWhereWithoutFinal_pant_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutFinal_pant_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutFinal_pant_measurementInput, ItemsUncheckedCreateWithoutFinal_pant_measurementInput> | ItemsCreateWithoutFinal_pant_measurementInput[] | ItemsUncheckedCreateWithoutFinal_pant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_pant_measurementInput | ItemsCreateOrConnectWithoutFinal_pant_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFinal_pant_measurementInput | ItemsUpsertWithWhereUniqueWithoutFinal_pant_measurementInput[]
    createMany?: ItemsCreateManyFinal_pant_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFinal_pant_measurementInput | ItemsUpdateWithWhereUniqueWithoutFinal_pant_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFinal_pant_measurementInput | ItemsUpdateManyWithWhereWithoutFinal_pant_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutPantMeasurementInput = {
    create?: XOR<CustomerCreateWithoutPantMeasurementInput, CustomerUncheckedCreateWithoutPantMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPantMeasurementInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutPantMeasurementInput = {
    create?: XOR<OrdersCreateWithoutPantMeasurementInput, OrdersUncheckedCreateWithoutPantMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutPantMeasurementInput
    connect?: OrdersWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutPant_measurementInput = {
    create?: XOR<ItemsCreateWithoutPant_measurementInput, ItemsUncheckedCreateWithoutPant_measurementInput> | ItemsCreateWithoutPant_measurementInput[] | ItemsUncheckedCreateWithoutPant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutPant_measurementInput | ItemsCreateOrConnectWithoutPant_measurementInput[]
    createMany?: ItemsCreateManyPant_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutPant_measurementInput = {
    create?: XOR<ItemsCreateWithoutPant_measurementInput, ItemsUncheckedCreateWithoutPant_measurementInput> | ItemsCreateWithoutPant_measurementInput[] | ItemsUncheckedCreateWithoutPant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutPant_measurementInput | ItemsCreateOrConnectWithoutPant_measurementInput[]
    createMany?: ItemsCreateManyPant_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutPantMeasurementNestedInput = {
    create?: XOR<CustomerCreateWithoutPantMeasurementInput, CustomerUncheckedCreateWithoutPantMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPantMeasurementInput
    upsert?: CustomerUpsertWithoutPantMeasurementInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPantMeasurementInput, CustomerUpdateWithoutPantMeasurementInput>, CustomerUncheckedUpdateWithoutPantMeasurementInput>
  }

  export type OrdersUpdateOneWithoutPantMeasurementNestedInput = {
    create?: XOR<OrdersCreateWithoutPantMeasurementInput, OrdersUncheckedCreateWithoutPantMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutPantMeasurementInput
    upsert?: OrdersUpsertWithoutPantMeasurementInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutPantMeasurementInput, OrdersUpdateWithoutPantMeasurementInput>, OrdersUncheckedUpdateWithoutPantMeasurementInput>
  }

  export type ItemsUpdateManyWithoutPant_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutPant_measurementInput, ItemsUncheckedCreateWithoutPant_measurementInput> | ItemsCreateWithoutPant_measurementInput[] | ItemsUncheckedCreateWithoutPant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutPant_measurementInput | ItemsCreateOrConnectWithoutPant_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutPant_measurementInput | ItemsUpsertWithWhereUniqueWithoutPant_measurementInput[]
    createMany?: ItemsCreateManyPant_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutPant_measurementInput | ItemsUpdateWithWhereUniqueWithoutPant_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutPant_measurementInput | ItemsUpdateManyWithWhereWithoutPant_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutPant_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutPant_measurementInput, ItemsUncheckedCreateWithoutPant_measurementInput> | ItemsCreateWithoutPant_measurementInput[] | ItemsUncheckedCreateWithoutPant_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutPant_measurementInput | ItemsCreateOrConnectWithoutPant_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutPant_measurementInput | ItemsUpsertWithWhereUniqueWithoutPant_measurementInput[]
    createMany?: ItemsCreateManyPant_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutPant_measurementInput | ItemsUpdateWithWhereUniqueWithoutPant_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutPant_measurementInput | ItemsUpdateManyWithWhereWithoutPant_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutFinalShirtMeasurementInput = {
    create?: XOR<CustomerCreateWithoutFinalShirtMeasurementInput, CustomerUncheckedCreateWithoutFinalShirtMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFinalShirtMeasurementInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutFinalShirtMeasurementInput = {
    create?: XOR<OrdersCreateWithoutFinalShirtMeasurementInput, OrdersUncheckedCreateWithoutFinalShirtMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutFinalShirtMeasurementInput
    connect?: OrdersWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutFinal_shirt_measurementInput = {
    create?: XOR<ItemsCreateWithoutFinal_shirt_measurementInput, ItemsUncheckedCreateWithoutFinal_shirt_measurementInput> | ItemsCreateWithoutFinal_shirt_measurementInput[] | ItemsUncheckedCreateWithoutFinal_shirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_shirt_measurementInput | ItemsCreateOrConnectWithoutFinal_shirt_measurementInput[]
    createMany?: ItemsCreateManyFinal_shirt_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutFinal_shirt_measurementInput = {
    create?: XOR<ItemsCreateWithoutFinal_shirt_measurementInput, ItemsUncheckedCreateWithoutFinal_shirt_measurementInput> | ItemsCreateWithoutFinal_shirt_measurementInput[] | ItemsUncheckedCreateWithoutFinal_shirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_shirt_measurementInput | ItemsCreateOrConnectWithoutFinal_shirt_measurementInput[]
    createMany?: ItemsCreateManyFinal_shirt_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutFinalShirtMeasurementNestedInput = {
    create?: XOR<CustomerCreateWithoutFinalShirtMeasurementInput, CustomerUncheckedCreateWithoutFinalShirtMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFinalShirtMeasurementInput
    upsert?: CustomerUpsertWithoutFinalShirtMeasurementInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutFinalShirtMeasurementInput, CustomerUpdateWithoutFinalShirtMeasurementInput>, CustomerUncheckedUpdateWithoutFinalShirtMeasurementInput>
  }

  export type OrdersUpdateOneWithoutFinalShirtMeasurementNestedInput = {
    create?: XOR<OrdersCreateWithoutFinalShirtMeasurementInput, OrdersUncheckedCreateWithoutFinalShirtMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutFinalShirtMeasurementInput
    upsert?: OrdersUpsertWithoutFinalShirtMeasurementInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutFinalShirtMeasurementInput, OrdersUpdateWithoutFinalShirtMeasurementInput>, OrdersUncheckedUpdateWithoutFinalShirtMeasurementInput>
  }

  export type ItemsUpdateManyWithoutFinal_shirt_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutFinal_shirt_measurementInput, ItemsUncheckedCreateWithoutFinal_shirt_measurementInput> | ItemsCreateWithoutFinal_shirt_measurementInput[] | ItemsUncheckedCreateWithoutFinal_shirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_shirt_measurementInput | ItemsCreateOrConnectWithoutFinal_shirt_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFinal_shirt_measurementInput | ItemsUpsertWithWhereUniqueWithoutFinal_shirt_measurementInput[]
    createMany?: ItemsCreateManyFinal_shirt_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFinal_shirt_measurementInput | ItemsUpdateWithWhereUniqueWithoutFinal_shirt_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFinal_shirt_measurementInput | ItemsUpdateManyWithWhereWithoutFinal_shirt_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutFinal_shirt_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutFinal_shirt_measurementInput, ItemsUncheckedCreateWithoutFinal_shirt_measurementInput> | ItemsCreateWithoutFinal_shirt_measurementInput[] | ItemsUncheckedCreateWithoutFinal_shirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutFinal_shirt_measurementInput | ItemsCreateOrConnectWithoutFinal_shirt_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutFinal_shirt_measurementInput | ItemsUpsertWithWhereUniqueWithoutFinal_shirt_measurementInput[]
    createMany?: ItemsCreateManyFinal_shirt_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutFinal_shirt_measurementInput | ItemsUpdateWithWhereUniqueWithoutFinal_shirt_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutFinal_shirt_measurementInput | ItemsUpdateManyWithWhereWithoutFinal_shirt_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutShirtMeasurementInput = {
    create?: XOR<CustomerCreateWithoutShirtMeasurementInput, CustomerUncheckedCreateWithoutShirtMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutShirtMeasurementInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutShirtMeasurementInput = {
    create?: XOR<OrdersCreateWithoutShirtMeasurementInput, OrdersUncheckedCreateWithoutShirtMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutShirtMeasurementInput
    connect?: OrdersWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutShirt_measurementInput = {
    create?: XOR<ItemsCreateWithoutShirt_measurementInput, ItemsUncheckedCreateWithoutShirt_measurementInput> | ItemsCreateWithoutShirt_measurementInput[] | ItemsUncheckedCreateWithoutShirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutShirt_measurementInput | ItemsCreateOrConnectWithoutShirt_measurementInput[]
    createMany?: ItemsCreateManyShirt_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutShirt_measurementInput = {
    create?: XOR<ItemsCreateWithoutShirt_measurementInput, ItemsUncheckedCreateWithoutShirt_measurementInput> | ItemsCreateWithoutShirt_measurementInput[] | ItemsUncheckedCreateWithoutShirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutShirt_measurementInput | ItemsCreateOrConnectWithoutShirt_measurementInput[]
    createMany?: ItemsCreateManyShirt_measurementInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutShirtMeasurementNestedInput = {
    create?: XOR<CustomerCreateWithoutShirtMeasurementInput, CustomerUncheckedCreateWithoutShirtMeasurementInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutShirtMeasurementInput
    upsert?: CustomerUpsertWithoutShirtMeasurementInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutShirtMeasurementInput, CustomerUpdateWithoutShirtMeasurementInput>, CustomerUncheckedUpdateWithoutShirtMeasurementInput>
  }

  export type OrdersUpdateOneWithoutShirtMeasurementNestedInput = {
    create?: XOR<OrdersCreateWithoutShirtMeasurementInput, OrdersUncheckedCreateWithoutShirtMeasurementInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutShirtMeasurementInput
    upsert?: OrdersUpsertWithoutShirtMeasurementInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutShirtMeasurementInput, OrdersUpdateWithoutShirtMeasurementInput>, OrdersUncheckedUpdateWithoutShirtMeasurementInput>
  }

  export type ItemsUpdateManyWithoutShirt_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutShirt_measurementInput, ItemsUncheckedCreateWithoutShirt_measurementInput> | ItemsCreateWithoutShirt_measurementInput[] | ItemsUncheckedCreateWithoutShirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutShirt_measurementInput | ItemsCreateOrConnectWithoutShirt_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutShirt_measurementInput | ItemsUpsertWithWhereUniqueWithoutShirt_measurementInput[]
    createMany?: ItemsCreateManyShirt_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutShirt_measurementInput | ItemsUpdateWithWhereUniqueWithoutShirt_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutShirt_measurementInput | ItemsUpdateManyWithWhereWithoutShirt_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutShirt_measurementNestedInput = {
    create?: XOR<ItemsCreateWithoutShirt_measurementInput, ItemsUncheckedCreateWithoutShirt_measurementInput> | ItemsCreateWithoutShirt_measurementInput[] | ItemsUncheckedCreateWithoutShirt_measurementInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutShirt_measurementInput | ItemsCreateOrConnectWithoutShirt_measurementInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutShirt_measurementInput | ItemsUpsertWithWhereUniqueWithoutShirt_measurementInput[]
    createMany?: ItemsCreateManyShirt_measurementInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutShirt_measurementInput | ItemsUpdateWithWhereUniqueWithoutShirt_measurementInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutShirt_measurementInput | ItemsUpdateManyWithWhereWithoutShirt_measurementInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type OrdersCreateNestedOneWithoutOrderPhotosInput = {
    create?: XOR<OrdersCreateWithoutOrderPhotosInput, OrdersUncheckedCreateWithoutOrderPhotosInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderPhotosInput
    connect?: OrdersWhereUniqueInput
  }

  export type OrdersUpdateOneWithoutOrderPhotosNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderPhotosInput, OrdersUncheckedCreateWithoutOrderPhotosInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderPhotosInput
    upsert?: OrdersUpsertWithoutOrderPhotosInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutOrderPhotosInput, OrdersUpdateWithoutOrderPhotosInput>, OrdersUncheckedUpdateWithoutOrderPhotosInput>
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type ItemsCreateNestedManyWithoutOrderInput = {
    create?: XOR<ItemsCreateWithoutOrderInput, ItemsUncheckedCreateWithoutOrderInput> | ItemsCreateWithoutOrderInput[] | ItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutOrderInput | ItemsCreateOrConnectWithoutOrderInput[]
    createMany?: ItemsCreateManyOrderInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type FinalJacketMeasurementCreateNestedManyWithoutOrderInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutOrderInput, FinalJacketMeasurementUncheckedCreateWithoutOrderInput> | FinalJacketMeasurementCreateWithoutOrderInput[] | FinalJacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutOrderInput | FinalJacketMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: FinalJacketMeasurementCreateManyOrderInputEnvelope
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
  }

  export type FinalPantMeasurementCreateNestedManyWithoutOrderInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutOrderInput, FinalPantMeasurementUncheckedCreateWithoutOrderInput> | FinalPantMeasurementCreateWithoutOrderInput[] | FinalPantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutOrderInput | FinalPantMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: FinalPantMeasurementCreateManyOrderInputEnvelope
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
  }

  export type FinalShirtMeasurementCreateNestedManyWithoutOrderInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutOrderInput, FinalShirtMeasurementUncheckedCreateWithoutOrderInput> | FinalShirtMeasurementCreateWithoutOrderInput[] | FinalShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutOrderInput | FinalShirtMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: FinalShirtMeasurementCreateManyOrderInputEnvelope
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
  }

  export type JacketMeasurementCreateNestedManyWithoutOrderInput = {
    create?: XOR<JacketMeasurementCreateWithoutOrderInput, JacketMeasurementUncheckedCreateWithoutOrderInput> | JacketMeasurementCreateWithoutOrderInput[] | JacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutOrderInput | JacketMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: JacketMeasurementCreateManyOrderInputEnvelope
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
  }

  export type PantMeasurementCreateNestedManyWithoutOrderInput = {
    create?: XOR<PantMeasurementCreateWithoutOrderInput, PantMeasurementUncheckedCreateWithoutOrderInput> | PantMeasurementCreateWithoutOrderInput[] | PantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutOrderInput | PantMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: PantMeasurementCreateManyOrderInputEnvelope
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
  }

  export type ShirtMeasurementCreateNestedManyWithoutOrderInput = {
    create?: XOR<ShirtMeasurementCreateWithoutOrderInput, ShirtMeasurementUncheckedCreateWithoutOrderInput> | ShirtMeasurementCreateWithoutOrderInput[] | ShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutOrderInput | ShirtMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: ShirtMeasurementCreateManyOrderInputEnvelope
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
  }

  export type OrderPhotosCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderPhotosCreateWithoutOrderInput, OrderPhotosUncheckedCreateWithoutOrderInput> | OrderPhotosCreateWithoutOrderInput[] | OrderPhotosUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderPhotosCreateOrConnectWithoutOrderInput | OrderPhotosCreateOrConnectWithoutOrderInput[]
    createMany?: OrderPhotosCreateManyOrderInputEnvelope
    connect?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
  }

  export type OrderTailorCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderTailorCreateWithoutOrderInput, OrderTailorUncheckedCreateWithoutOrderInput> | OrderTailorCreateWithoutOrderInput[] | OrderTailorUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutOrderInput | OrderTailorCreateOrConnectWithoutOrderInput[]
    createMany?: OrderTailorCreateManyOrderInputEnvelope
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
  }

  export type OrderProductionCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrderProductionCreateWithoutOrderInput, OrderProductionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderProductionCreateOrConnectWithoutOrderInput
    connect?: OrderProductionWhereUniqueInput
  }

  export type ItemsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ItemsCreateWithoutOrderInput, ItemsUncheckedCreateWithoutOrderInput> | ItemsCreateWithoutOrderInput[] | ItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutOrderInput | ItemsCreateOrConnectWithoutOrderInput[]
    createMany?: ItemsCreateManyOrderInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutOrderInput, FinalJacketMeasurementUncheckedCreateWithoutOrderInput> | FinalJacketMeasurementCreateWithoutOrderInput[] | FinalJacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutOrderInput | FinalJacketMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: FinalJacketMeasurementCreateManyOrderInputEnvelope
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
  }

  export type FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutOrderInput, FinalPantMeasurementUncheckedCreateWithoutOrderInput> | FinalPantMeasurementCreateWithoutOrderInput[] | FinalPantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutOrderInput | FinalPantMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: FinalPantMeasurementCreateManyOrderInputEnvelope
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
  }

  export type FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutOrderInput, FinalShirtMeasurementUncheckedCreateWithoutOrderInput> | FinalShirtMeasurementCreateWithoutOrderInput[] | FinalShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutOrderInput | FinalShirtMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: FinalShirtMeasurementCreateManyOrderInputEnvelope
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
  }

  export type JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<JacketMeasurementCreateWithoutOrderInput, JacketMeasurementUncheckedCreateWithoutOrderInput> | JacketMeasurementCreateWithoutOrderInput[] | JacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutOrderInput | JacketMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: JacketMeasurementCreateManyOrderInputEnvelope
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
  }

  export type PantMeasurementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PantMeasurementCreateWithoutOrderInput, PantMeasurementUncheckedCreateWithoutOrderInput> | PantMeasurementCreateWithoutOrderInput[] | PantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutOrderInput | PantMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: PantMeasurementCreateManyOrderInputEnvelope
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
  }

  export type ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ShirtMeasurementCreateWithoutOrderInput, ShirtMeasurementUncheckedCreateWithoutOrderInput> | ShirtMeasurementCreateWithoutOrderInput[] | ShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutOrderInput | ShirtMeasurementCreateOrConnectWithoutOrderInput[]
    createMany?: ShirtMeasurementCreateManyOrderInputEnvelope
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
  }

  export type OrderPhotosUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderPhotosCreateWithoutOrderInput, OrderPhotosUncheckedCreateWithoutOrderInput> | OrderPhotosCreateWithoutOrderInput[] | OrderPhotosUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderPhotosCreateOrConnectWithoutOrderInput | OrderPhotosCreateOrConnectWithoutOrderInput[]
    createMany?: OrderPhotosCreateManyOrderInputEnvelope
    connect?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
  }

  export type OrderTailorUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderTailorCreateWithoutOrderInput, OrderTailorUncheckedCreateWithoutOrderInput> | OrderTailorCreateWithoutOrderInput[] | OrderTailorUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutOrderInput | OrderTailorCreateOrConnectWithoutOrderInput[]
    createMany?: OrderTailorCreateManyOrderInputEnvelope
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
  }

  export type OrderProductionUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<OrderProductionCreateWithoutOrderInput, OrderProductionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderProductionCreateOrConnectWithoutOrderInput
    connect?: OrderProductionWhereUniqueInput
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type ItemsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ItemsCreateWithoutOrderInput, ItemsUncheckedCreateWithoutOrderInput> | ItemsCreateWithoutOrderInput[] | ItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutOrderInput | ItemsCreateOrConnectWithoutOrderInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutOrderInput | ItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ItemsCreateManyOrderInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutOrderInput | ItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutOrderInput | ItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type FinalJacketMeasurementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutOrderInput, FinalJacketMeasurementUncheckedCreateWithoutOrderInput> | FinalJacketMeasurementCreateWithoutOrderInput[] | FinalJacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutOrderInput | FinalJacketMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: FinalJacketMeasurementUpsertWithWhereUniqueWithoutOrderInput | FinalJacketMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FinalJacketMeasurementCreateManyOrderInputEnvelope
    set?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    disconnect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    delete?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    update?: FinalJacketMeasurementUpdateWithWhereUniqueWithoutOrderInput | FinalJacketMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FinalJacketMeasurementUpdateManyWithWhereWithoutOrderInput | FinalJacketMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FinalJacketMeasurementScalarWhereInput | FinalJacketMeasurementScalarWhereInput[]
  }

  export type FinalPantMeasurementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutOrderInput, FinalPantMeasurementUncheckedCreateWithoutOrderInput> | FinalPantMeasurementCreateWithoutOrderInput[] | FinalPantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutOrderInput | FinalPantMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: FinalPantMeasurementUpsertWithWhereUniqueWithoutOrderInput | FinalPantMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FinalPantMeasurementCreateManyOrderInputEnvelope
    set?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    disconnect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    delete?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    update?: FinalPantMeasurementUpdateWithWhereUniqueWithoutOrderInput | FinalPantMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FinalPantMeasurementUpdateManyWithWhereWithoutOrderInput | FinalPantMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FinalPantMeasurementScalarWhereInput | FinalPantMeasurementScalarWhereInput[]
  }

  export type FinalShirtMeasurementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutOrderInput, FinalShirtMeasurementUncheckedCreateWithoutOrderInput> | FinalShirtMeasurementCreateWithoutOrderInput[] | FinalShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutOrderInput | FinalShirtMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: FinalShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput | FinalShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FinalShirtMeasurementCreateManyOrderInputEnvelope
    set?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    disconnect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    delete?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    update?: FinalShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput | FinalShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FinalShirtMeasurementUpdateManyWithWhereWithoutOrderInput | FinalShirtMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FinalShirtMeasurementScalarWhereInput | FinalShirtMeasurementScalarWhereInput[]
  }

  export type JacketMeasurementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<JacketMeasurementCreateWithoutOrderInput, JacketMeasurementUncheckedCreateWithoutOrderInput> | JacketMeasurementCreateWithoutOrderInput[] | JacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutOrderInput | JacketMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: JacketMeasurementUpsertWithWhereUniqueWithoutOrderInput | JacketMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: JacketMeasurementCreateManyOrderInputEnvelope
    set?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    disconnect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    delete?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    update?: JacketMeasurementUpdateWithWhereUniqueWithoutOrderInput | JacketMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: JacketMeasurementUpdateManyWithWhereWithoutOrderInput | JacketMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: JacketMeasurementScalarWhereInput | JacketMeasurementScalarWhereInput[]
  }

  export type PantMeasurementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PantMeasurementCreateWithoutOrderInput, PantMeasurementUncheckedCreateWithoutOrderInput> | PantMeasurementCreateWithoutOrderInput[] | PantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutOrderInput | PantMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: PantMeasurementUpsertWithWhereUniqueWithoutOrderInput | PantMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PantMeasurementCreateManyOrderInputEnvelope
    set?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    disconnect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    delete?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    update?: PantMeasurementUpdateWithWhereUniqueWithoutOrderInput | PantMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PantMeasurementUpdateManyWithWhereWithoutOrderInput | PantMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PantMeasurementScalarWhereInput | PantMeasurementScalarWhereInput[]
  }

  export type ShirtMeasurementUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ShirtMeasurementCreateWithoutOrderInput, ShirtMeasurementUncheckedCreateWithoutOrderInput> | ShirtMeasurementCreateWithoutOrderInput[] | ShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutOrderInput | ShirtMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: ShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput | ShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ShirtMeasurementCreateManyOrderInputEnvelope
    set?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    disconnect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    delete?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    update?: ShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput | ShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ShirtMeasurementUpdateManyWithWhereWithoutOrderInput | ShirtMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ShirtMeasurementScalarWhereInput | ShirtMeasurementScalarWhereInput[]
  }

  export type OrderPhotosUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderPhotosCreateWithoutOrderInput, OrderPhotosUncheckedCreateWithoutOrderInput> | OrderPhotosCreateWithoutOrderInput[] | OrderPhotosUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderPhotosCreateOrConnectWithoutOrderInput | OrderPhotosCreateOrConnectWithoutOrderInput[]
    upsert?: OrderPhotosUpsertWithWhereUniqueWithoutOrderInput | OrderPhotosUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderPhotosCreateManyOrderInputEnvelope
    set?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    disconnect?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    delete?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    connect?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    update?: OrderPhotosUpdateWithWhereUniqueWithoutOrderInput | OrderPhotosUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderPhotosUpdateManyWithWhereWithoutOrderInput | OrderPhotosUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderPhotosScalarWhereInput | OrderPhotosScalarWhereInput[]
  }

  export type OrderTailorUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderTailorCreateWithoutOrderInput, OrderTailorUncheckedCreateWithoutOrderInput> | OrderTailorCreateWithoutOrderInput[] | OrderTailorUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutOrderInput | OrderTailorCreateOrConnectWithoutOrderInput[]
    upsert?: OrderTailorUpsertWithWhereUniqueWithoutOrderInput | OrderTailorUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderTailorCreateManyOrderInputEnvelope
    set?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    disconnect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    delete?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    update?: OrderTailorUpdateWithWhereUniqueWithoutOrderInput | OrderTailorUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderTailorUpdateManyWithWhereWithoutOrderInput | OrderTailorUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderTailorScalarWhereInput | OrderTailorScalarWhereInput[]
  }

  export type OrderProductionUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrderProductionCreateWithoutOrderInput, OrderProductionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderProductionCreateOrConnectWithoutOrderInput
    upsert?: OrderProductionUpsertWithoutOrderInput
    disconnect?: OrderProductionWhereInput | boolean
    delete?: OrderProductionWhereInput | boolean
    connect?: OrderProductionWhereUniqueInput
    update?: XOR<XOR<OrderProductionUpdateToOneWithWhereWithoutOrderInput, OrderProductionUpdateWithoutOrderInput>, OrderProductionUncheckedUpdateWithoutOrderInput>
  }

  export type ItemsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ItemsCreateWithoutOrderInput, ItemsUncheckedCreateWithoutOrderInput> | ItemsCreateWithoutOrderInput[] | ItemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutOrderInput | ItemsCreateOrConnectWithoutOrderInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutOrderInput | ItemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ItemsCreateManyOrderInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutOrderInput | ItemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutOrderInput | ItemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutOrderInput, FinalJacketMeasurementUncheckedCreateWithoutOrderInput> | FinalJacketMeasurementCreateWithoutOrderInput[] | FinalJacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutOrderInput | FinalJacketMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: FinalJacketMeasurementUpsertWithWhereUniqueWithoutOrderInput | FinalJacketMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FinalJacketMeasurementCreateManyOrderInputEnvelope
    set?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    disconnect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    delete?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    connect?: FinalJacketMeasurementWhereUniqueInput | FinalJacketMeasurementWhereUniqueInput[]
    update?: FinalJacketMeasurementUpdateWithWhereUniqueWithoutOrderInput | FinalJacketMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FinalJacketMeasurementUpdateManyWithWhereWithoutOrderInput | FinalJacketMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FinalJacketMeasurementScalarWhereInput | FinalJacketMeasurementScalarWhereInput[]
  }

  export type FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutOrderInput, FinalPantMeasurementUncheckedCreateWithoutOrderInput> | FinalPantMeasurementCreateWithoutOrderInput[] | FinalPantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutOrderInput | FinalPantMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: FinalPantMeasurementUpsertWithWhereUniqueWithoutOrderInput | FinalPantMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FinalPantMeasurementCreateManyOrderInputEnvelope
    set?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    disconnect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    delete?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    connect?: FinalPantMeasurementWhereUniqueInput | FinalPantMeasurementWhereUniqueInput[]
    update?: FinalPantMeasurementUpdateWithWhereUniqueWithoutOrderInput | FinalPantMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FinalPantMeasurementUpdateManyWithWhereWithoutOrderInput | FinalPantMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FinalPantMeasurementScalarWhereInput | FinalPantMeasurementScalarWhereInput[]
  }

  export type FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutOrderInput, FinalShirtMeasurementUncheckedCreateWithoutOrderInput> | FinalShirtMeasurementCreateWithoutOrderInput[] | FinalShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutOrderInput | FinalShirtMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: FinalShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput | FinalShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FinalShirtMeasurementCreateManyOrderInputEnvelope
    set?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    disconnect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    delete?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    connect?: FinalShirtMeasurementWhereUniqueInput | FinalShirtMeasurementWhereUniqueInput[]
    update?: FinalShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput | FinalShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FinalShirtMeasurementUpdateManyWithWhereWithoutOrderInput | FinalShirtMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FinalShirtMeasurementScalarWhereInput | FinalShirtMeasurementScalarWhereInput[]
  }

  export type JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<JacketMeasurementCreateWithoutOrderInput, JacketMeasurementUncheckedCreateWithoutOrderInput> | JacketMeasurementCreateWithoutOrderInput[] | JacketMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutOrderInput | JacketMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: JacketMeasurementUpsertWithWhereUniqueWithoutOrderInput | JacketMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: JacketMeasurementCreateManyOrderInputEnvelope
    set?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    disconnect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    delete?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    connect?: JacketMeasurementWhereUniqueInput | JacketMeasurementWhereUniqueInput[]
    update?: JacketMeasurementUpdateWithWhereUniqueWithoutOrderInput | JacketMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: JacketMeasurementUpdateManyWithWhereWithoutOrderInput | JacketMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: JacketMeasurementScalarWhereInput | JacketMeasurementScalarWhereInput[]
  }

  export type PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PantMeasurementCreateWithoutOrderInput, PantMeasurementUncheckedCreateWithoutOrderInput> | PantMeasurementCreateWithoutOrderInput[] | PantMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutOrderInput | PantMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: PantMeasurementUpsertWithWhereUniqueWithoutOrderInput | PantMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PantMeasurementCreateManyOrderInputEnvelope
    set?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    disconnect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    delete?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    connect?: PantMeasurementWhereUniqueInput | PantMeasurementWhereUniqueInput[]
    update?: PantMeasurementUpdateWithWhereUniqueWithoutOrderInput | PantMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PantMeasurementUpdateManyWithWhereWithoutOrderInput | PantMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PantMeasurementScalarWhereInput | PantMeasurementScalarWhereInput[]
  }

  export type ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ShirtMeasurementCreateWithoutOrderInput, ShirtMeasurementUncheckedCreateWithoutOrderInput> | ShirtMeasurementCreateWithoutOrderInput[] | ShirtMeasurementUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutOrderInput | ShirtMeasurementCreateOrConnectWithoutOrderInput[]
    upsert?: ShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput | ShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ShirtMeasurementCreateManyOrderInputEnvelope
    set?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    disconnect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    delete?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    connect?: ShirtMeasurementWhereUniqueInput | ShirtMeasurementWhereUniqueInput[]
    update?: ShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput | ShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ShirtMeasurementUpdateManyWithWhereWithoutOrderInput | ShirtMeasurementUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ShirtMeasurementScalarWhereInput | ShirtMeasurementScalarWhereInput[]
  }

  export type OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderPhotosCreateWithoutOrderInput, OrderPhotosUncheckedCreateWithoutOrderInput> | OrderPhotosCreateWithoutOrderInput[] | OrderPhotosUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderPhotosCreateOrConnectWithoutOrderInput | OrderPhotosCreateOrConnectWithoutOrderInput[]
    upsert?: OrderPhotosUpsertWithWhereUniqueWithoutOrderInput | OrderPhotosUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderPhotosCreateManyOrderInputEnvelope
    set?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    disconnect?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    delete?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    connect?: OrderPhotosWhereUniqueInput | OrderPhotosWhereUniqueInput[]
    update?: OrderPhotosUpdateWithWhereUniqueWithoutOrderInput | OrderPhotosUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderPhotosUpdateManyWithWhereWithoutOrderInput | OrderPhotosUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderPhotosScalarWhereInput | OrderPhotosScalarWhereInput[]
  }

  export type OrderTailorUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderTailorCreateWithoutOrderInput, OrderTailorUncheckedCreateWithoutOrderInput> | OrderTailorCreateWithoutOrderInput[] | OrderTailorUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutOrderInput | OrderTailorCreateOrConnectWithoutOrderInput[]
    upsert?: OrderTailorUpsertWithWhereUniqueWithoutOrderInput | OrderTailorUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderTailorCreateManyOrderInputEnvelope
    set?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    disconnect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    delete?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    update?: OrderTailorUpdateWithWhereUniqueWithoutOrderInput | OrderTailorUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderTailorUpdateManyWithWhereWithoutOrderInput | OrderTailorUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderTailorScalarWhereInput | OrderTailorScalarWhereInput[]
  }

  export type OrderProductionUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<OrderProductionCreateWithoutOrderInput, OrderProductionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: OrderProductionCreateOrConnectWithoutOrderInput
    upsert?: OrderProductionUpsertWithoutOrderInput
    disconnect?: OrderProductionWhereInput | boolean
    delete?: OrderProductionWhereInput | boolean
    connect?: OrderProductionWhereUniqueInput
    update?: XOR<XOR<OrderProductionUpdateToOneWithWhereWithoutOrderInput, OrderProductionUpdateWithoutOrderInput>, OrderProductionUncheckedUpdateWithoutOrderInput>
  }

  export type OrdersCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrdersCreateWithoutItemsInput, OrdersUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutItemsInput
    connect?: OrdersWhereUniqueInput
  }

  export type FabricCreateNestedOneWithoutItemsInput = {
    create?: XOR<FabricCreateWithoutItemsInput, FabricUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FabricCreateOrConnectWithoutItemsInput
    connect?: FabricWhereUniqueInput
  }

  export type FabricCreateNestedOneWithoutLiningItemsInput = {
    create?: XOR<FabricCreateWithoutLiningItemsInput, FabricUncheckedCreateWithoutLiningItemsInput>
    connectOrCreate?: FabricCreateOrConnectWithoutLiningItemsInput
    connect?: FabricWhereUniqueInput
  }

  export type JacketMeasurementCreateNestedOneWithoutItemsInput = {
    create?: XOR<JacketMeasurementCreateWithoutItemsInput, JacketMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutItemsInput
    connect?: JacketMeasurementWhereUniqueInput
  }

  export type ShirtMeasurementCreateNestedOneWithoutItemsInput = {
    create?: XOR<ShirtMeasurementCreateWithoutItemsInput, ShirtMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutItemsInput
    connect?: ShirtMeasurementWhereUniqueInput
  }

  export type PantMeasurementCreateNestedOneWithoutItemsInput = {
    create?: XOR<PantMeasurementCreateWithoutItemsInput, PantMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutItemsInput
    connect?: PantMeasurementWhereUniqueInput
  }

  export type FinalJacketMeasurementCreateNestedOneWithoutItemsInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutItemsInput, FinalJacketMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutItemsInput
    connect?: FinalJacketMeasurementWhereUniqueInput
  }

  export type FinalShirtMeasurementCreateNestedOneWithoutItemsInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutItemsInput, FinalShirtMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutItemsInput
    connect?: FinalShirtMeasurementWhereUniqueInput
  }

  export type FinalPantMeasurementCreateNestedOneWithoutItemsInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutItemsInput, FinalPantMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutItemsInput
    connect?: FinalPantMeasurementWhereUniqueInput
  }

  export type NullableEnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType | null
  }

  export type OrdersUpdateOneWithoutItemsNestedInput = {
    create?: XOR<OrdersCreateWithoutItemsInput, OrdersUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutItemsInput
    upsert?: OrdersUpsertWithoutItemsInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutItemsInput, OrdersUpdateWithoutItemsInput>, OrdersUncheckedUpdateWithoutItemsInput>
  }

  export type FabricUpdateOneWithoutItemsNestedInput = {
    create?: XOR<FabricCreateWithoutItemsInput, FabricUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FabricCreateOrConnectWithoutItemsInput
    upsert?: FabricUpsertWithoutItemsInput
    disconnect?: FabricWhereInput | boolean
    delete?: FabricWhereInput | boolean
    connect?: FabricWhereUniqueInput
    update?: XOR<XOR<FabricUpdateToOneWithWhereWithoutItemsInput, FabricUpdateWithoutItemsInput>, FabricUncheckedUpdateWithoutItemsInput>
  }

  export type FabricUpdateOneWithoutLiningItemsNestedInput = {
    create?: XOR<FabricCreateWithoutLiningItemsInput, FabricUncheckedCreateWithoutLiningItemsInput>
    connectOrCreate?: FabricCreateOrConnectWithoutLiningItemsInput
    upsert?: FabricUpsertWithoutLiningItemsInput
    disconnect?: FabricWhereInput | boolean
    delete?: FabricWhereInput | boolean
    connect?: FabricWhereUniqueInput
    update?: XOR<XOR<FabricUpdateToOneWithWhereWithoutLiningItemsInput, FabricUpdateWithoutLiningItemsInput>, FabricUncheckedUpdateWithoutLiningItemsInput>
  }

  export type JacketMeasurementUpdateOneWithoutItemsNestedInput = {
    create?: XOR<JacketMeasurementCreateWithoutItemsInput, JacketMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: JacketMeasurementCreateOrConnectWithoutItemsInput
    upsert?: JacketMeasurementUpsertWithoutItemsInput
    disconnect?: JacketMeasurementWhereInput | boolean
    delete?: JacketMeasurementWhereInput | boolean
    connect?: JacketMeasurementWhereUniqueInput
    update?: XOR<XOR<JacketMeasurementUpdateToOneWithWhereWithoutItemsInput, JacketMeasurementUpdateWithoutItemsInput>, JacketMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type ShirtMeasurementUpdateOneWithoutItemsNestedInput = {
    create?: XOR<ShirtMeasurementCreateWithoutItemsInput, ShirtMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShirtMeasurementCreateOrConnectWithoutItemsInput
    upsert?: ShirtMeasurementUpsertWithoutItemsInput
    disconnect?: ShirtMeasurementWhereInput | boolean
    delete?: ShirtMeasurementWhereInput | boolean
    connect?: ShirtMeasurementWhereUniqueInput
    update?: XOR<XOR<ShirtMeasurementUpdateToOneWithWhereWithoutItemsInput, ShirtMeasurementUpdateWithoutItemsInput>, ShirtMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type PantMeasurementUpdateOneWithoutItemsNestedInput = {
    create?: XOR<PantMeasurementCreateWithoutItemsInput, PantMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PantMeasurementCreateOrConnectWithoutItemsInput
    upsert?: PantMeasurementUpsertWithoutItemsInput
    disconnect?: PantMeasurementWhereInput | boolean
    delete?: PantMeasurementWhereInput | boolean
    connect?: PantMeasurementWhereUniqueInput
    update?: XOR<XOR<PantMeasurementUpdateToOneWithWhereWithoutItemsInput, PantMeasurementUpdateWithoutItemsInput>, PantMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FinalJacketMeasurementUpdateOneWithoutItemsNestedInput = {
    create?: XOR<FinalJacketMeasurementCreateWithoutItemsInput, FinalJacketMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FinalJacketMeasurementCreateOrConnectWithoutItemsInput
    upsert?: FinalJacketMeasurementUpsertWithoutItemsInput
    disconnect?: FinalJacketMeasurementWhereInput | boolean
    delete?: FinalJacketMeasurementWhereInput | boolean
    connect?: FinalJacketMeasurementWhereUniqueInput
    update?: XOR<XOR<FinalJacketMeasurementUpdateToOneWithWhereWithoutItemsInput, FinalJacketMeasurementUpdateWithoutItemsInput>, FinalJacketMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FinalShirtMeasurementUpdateOneWithoutItemsNestedInput = {
    create?: XOR<FinalShirtMeasurementCreateWithoutItemsInput, FinalShirtMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FinalShirtMeasurementCreateOrConnectWithoutItemsInput
    upsert?: FinalShirtMeasurementUpsertWithoutItemsInput
    disconnect?: FinalShirtMeasurementWhereInput | boolean
    delete?: FinalShirtMeasurementWhereInput | boolean
    connect?: FinalShirtMeasurementWhereUniqueInput
    update?: XOR<XOR<FinalShirtMeasurementUpdateToOneWithWhereWithoutItemsInput, FinalShirtMeasurementUpdateWithoutItemsInput>, FinalShirtMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FinalPantMeasurementUpdateOneWithoutItemsNestedInput = {
    create?: XOR<FinalPantMeasurementCreateWithoutItemsInput, FinalPantMeasurementUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FinalPantMeasurementCreateOrConnectWithoutItemsInput
    upsert?: FinalPantMeasurementUpsertWithoutItemsInput
    disconnect?: FinalPantMeasurementWhereInput | boolean
    delete?: FinalPantMeasurementWhereInput | boolean
    connect?: FinalPantMeasurementWhereUniqueInput
    update?: XOR<XOR<FinalPantMeasurementUpdateToOneWithWhereWithoutItemsInput, FinalPantMeasurementUpdateWithoutItemsInput>, FinalPantMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FabricOrderListCreateNestedManyWithoutSupplierInput = {
    create?: XOR<FabricOrderListCreateWithoutSupplierInput, FabricOrderListUncheckedCreateWithoutSupplierInput> | FabricOrderListCreateWithoutSupplierInput[] | FabricOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutSupplierInput | FabricOrderListCreateOrConnectWithoutSupplierInput[]
    createMany?: FabricOrderListCreateManySupplierInputEnvelope
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
  }

  export type RawMaterialsOrderListCreateNestedManyWithoutSupplierInput = {
    create?: XOR<RawMaterialsOrderListCreateWithoutSupplierInput, RawMaterialsOrderListUncheckedCreateWithoutSupplierInput> | RawMaterialsOrderListCreateWithoutSupplierInput[] | RawMaterialsOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RawMaterialsOrderListCreateOrConnectWithoutSupplierInput | RawMaterialsOrderListCreateOrConnectWithoutSupplierInput[]
    createMany?: RawMaterialsOrderListCreateManySupplierInputEnvelope
    connect?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
  }

  export type ItemSupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type FabricOrderListUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<FabricOrderListCreateWithoutSupplierInput, FabricOrderListUncheckedCreateWithoutSupplierInput> | FabricOrderListCreateWithoutSupplierInput[] | FabricOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutSupplierInput | FabricOrderListCreateOrConnectWithoutSupplierInput[]
    createMany?: FabricOrderListCreateManySupplierInputEnvelope
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
  }

  export type RawMaterialsOrderListUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<RawMaterialsOrderListCreateWithoutSupplierInput, RawMaterialsOrderListUncheckedCreateWithoutSupplierInput> | RawMaterialsOrderListCreateWithoutSupplierInput[] | RawMaterialsOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RawMaterialsOrderListCreateOrConnectWithoutSupplierInput | RawMaterialsOrderListCreateOrConnectWithoutSupplierInput[]
    createMany?: RawMaterialsOrderListCreateManySupplierInputEnvelope
    connect?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
  }

  export type ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
  }

  export type FabricOrderListUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<FabricOrderListCreateWithoutSupplierInput, FabricOrderListUncheckedCreateWithoutSupplierInput> | FabricOrderListCreateWithoutSupplierInput[] | FabricOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutSupplierInput | FabricOrderListCreateOrConnectWithoutSupplierInput[]
    upsert?: FabricOrderListUpsertWithWhereUniqueWithoutSupplierInput | FabricOrderListUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: FabricOrderListCreateManySupplierInputEnvelope
    set?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    disconnect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    delete?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    update?: FabricOrderListUpdateWithWhereUniqueWithoutSupplierInput | FabricOrderListUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: FabricOrderListUpdateManyWithWhereWithoutSupplierInput | FabricOrderListUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: FabricOrderListScalarWhereInput | FabricOrderListScalarWhereInput[]
  }

  export type RawMaterialsOrderListUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<RawMaterialsOrderListCreateWithoutSupplierInput, RawMaterialsOrderListUncheckedCreateWithoutSupplierInput> | RawMaterialsOrderListCreateWithoutSupplierInput[] | RawMaterialsOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RawMaterialsOrderListCreateOrConnectWithoutSupplierInput | RawMaterialsOrderListCreateOrConnectWithoutSupplierInput[]
    upsert?: RawMaterialsOrderListUpsertWithWhereUniqueWithoutSupplierInput | RawMaterialsOrderListUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: RawMaterialsOrderListCreateManySupplierInputEnvelope
    set?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    disconnect?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    delete?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    connect?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    update?: RawMaterialsOrderListUpdateWithWhereUniqueWithoutSupplierInput | RawMaterialsOrderListUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: RawMaterialsOrderListUpdateManyWithWhereWithoutSupplierInput | RawMaterialsOrderListUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: RawMaterialsOrderListScalarWhereInput | RawMaterialsOrderListScalarWhereInput[]
  }

  export type ItemSupplierUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput | ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput | ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutSupplierInput | ItemSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type FabricOrderListUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<FabricOrderListCreateWithoutSupplierInput, FabricOrderListUncheckedCreateWithoutSupplierInput> | FabricOrderListCreateWithoutSupplierInput[] | FabricOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FabricOrderListCreateOrConnectWithoutSupplierInput | FabricOrderListCreateOrConnectWithoutSupplierInput[]
    upsert?: FabricOrderListUpsertWithWhereUniqueWithoutSupplierInput | FabricOrderListUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: FabricOrderListCreateManySupplierInputEnvelope
    set?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    disconnect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    delete?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    connect?: FabricOrderListWhereUniqueInput | FabricOrderListWhereUniqueInput[]
    update?: FabricOrderListUpdateWithWhereUniqueWithoutSupplierInput | FabricOrderListUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: FabricOrderListUpdateManyWithWhereWithoutSupplierInput | FabricOrderListUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: FabricOrderListScalarWhereInput | FabricOrderListScalarWhereInput[]
  }

  export type RawMaterialsOrderListUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<RawMaterialsOrderListCreateWithoutSupplierInput, RawMaterialsOrderListUncheckedCreateWithoutSupplierInput> | RawMaterialsOrderListCreateWithoutSupplierInput[] | RawMaterialsOrderListUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: RawMaterialsOrderListCreateOrConnectWithoutSupplierInput | RawMaterialsOrderListCreateOrConnectWithoutSupplierInput[]
    upsert?: RawMaterialsOrderListUpsertWithWhereUniqueWithoutSupplierInput | RawMaterialsOrderListUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: RawMaterialsOrderListCreateManySupplierInputEnvelope
    set?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    disconnect?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    delete?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    connect?: RawMaterialsOrderListWhereUniqueInput | RawMaterialsOrderListWhereUniqueInput[]
    update?: RawMaterialsOrderListUpdateWithWhereUniqueWithoutSupplierInput | RawMaterialsOrderListUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: RawMaterialsOrderListUpdateManyWithWhereWithoutSupplierInput | RawMaterialsOrderListUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: RawMaterialsOrderListScalarWhereInput | RawMaterialsOrderListScalarWhereInput[]
  }

  export type ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput> | ItemSupplierCreateWithoutSupplierInput[] | ItemSupplierUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemSupplierCreateOrConnectWithoutSupplierInput | ItemSupplierCreateOrConnectWithoutSupplierInput[]
    upsert?: ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput | ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ItemSupplierCreateManySupplierInputEnvelope
    set?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    disconnect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    delete?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    connect?: ItemSupplierWhereUniqueInput | ItemSupplierWhereUniqueInput[]
    update?: ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput | ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ItemSupplierUpdateManyWithWhereWithoutSupplierInput | ItemSupplierUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
  }

  export type OrderTailorCreateNestedManyWithoutTailorInput = {
    create?: XOR<OrderTailorCreateWithoutTailorInput, OrderTailorUncheckedCreateWithoutTailorInput> | OrderTailorCreateWithoutTailorInput[] | OrderTailorUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutTailorInput | OrderTailorCreateOrConnectWithoutTailorInput[]
    createMany?: OrderTailorCreateManyTailorInputEnvelope
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
  }

  export type OrderTailorUncheckedCreateNestedManyWithoutTailorInput = {
    create?: XOR<OrderTailorCreateWithoutTailorInput, OrderTailorUncheckedCreateWithoutTailorInput> | OrderTailorCreateWithoutTailorInput[] | OrderTailorUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutTailorInput | OrderTailorCreateOrConnectWithoutTailorInput[]
    createMany?: OrderTailorCreateManyTailorInputEnvelope
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
  }

  export type OrderTailorUpdateManyWithoutTailorNestedInput = {
    create?: XOR<OrderTailorCreateWithoutTailorInput, OrderTailorUncheckedCreateWithoutTailorInput> | OrderTailorCreateWithoutTailorInput[] | OrderTailorUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutTailorInput | OrderTailorCreateOrConnectWithoutTailorInput[]
    upsert?: OrderTailorUpsertWithWhereUniqueWithoutTailorInput | OrderTailorUpsertWithWhereUniqueWithoutTailorInput[]
    createMany?: OrderTailorCreateManyTailorInputEnvelope
    set?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    disconnect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    delete?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    update?: OrderTailorUpdateWithWhereUniqueWithoutTailorInput | OrderTailorUpdateWithWhereUniqueWithoutTailorInput[]
    updateMany?: OrderTailorUpdateManyWithWhereWithoutTailorInput | OrderTailorUpdateManyWithWhereWithoutTailorInput[]
    deleteMany?: OrderTailorScalarWhereInput | OrderTailorScalarWhereInput[]
  }

  export type OrderTailorUncheckedUpdateManyWithoutTailorNestedInput = {
    create?: XOR<OrderTailorCreateWithoutTailorInput, OrderTailorUncheckedCreateWithoutTailorInput> | OrderTailorCreateWithoutTailorInput[] | OrderTailorUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: OrderTailorCreateOrConnectWithoutTailorInput | OrderTailorCreateOrConnectWithoutTailorInput[]
    upsert?: OrderTailorUpsertWithWhereUniqueWithoutTailorInput | OrderTailorUpsertWithWhereUniqueWithoutTailorInput[]
    createMany?: OrderTailorCreateManyTailorInputEnvelope
    set?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    disconnect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    delete?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    connect?: OrderTailorWhereUniqueInput | OrderTailorWhereUniqueInput[]
    update?: OrderTailorUpdateWithWhereUniqueWithoutTailorInput | OrderTailorUpdateWithWhereUniqueWithoutTailorInput[]
    updateMany?: OrderTailorUpdateManyWithWhereWithoutTailorInput | OrderTailorUpdateManyWithWhereWithoutTailorInput[]
    deleteMany?: OrderTailorScalarWhereInput | OrderTailorScalarWhereInput[]
  }

  export type OrdersCreateNestedOneWithoutTailorsInput = {
    create?: XOR<OrdersCreateWithoutTailorsInput, OrdersUncheckedCreateWithoutTailorsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutTailorsInput
    connect?: OrdersWhereUniqueInput
  }

  export type TailorCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TailorCreateWithoutOrdersInput, TailorUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TailorCreateOrConnectWithoutOrdersInput
    connect?: TailorWhereUniqueInput
  }

  export type OrdersUpdateOneRequiredWithoutTailorsNestedInput = {
    create?: XOR<OrdersCreateWithoutTailorsInput, OrdersUncheckedCreateWithoutTailorsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutTailorsInput
    upsert?: OrdersUpsertWithoutTailorsInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutTailorsInput, OrdersUpdateWithoutTailorsInput>, OrdersUncheckedUpdateWithoutTailorsInput>
  }

  export type TailorUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<TailorCreateWithoutOrdersInput, TailorUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TailorCreateOrConnectWithoutOrdersInput
    upsert?: TailorUpsertWithoutOrdersInput
    connect?: TailorWhereUniqueInput
    update?: XOR<XOR<TailorUpdateToOneWithWhereWithoutOrdersInput, TailorUpdateWithoutOrdersInput>, TailorUncheckedUpdateWithoutOrdersInput>
  }

  export type SupplierCreateNestedOneWithoutRawMaterialsOrderListInput = {
    create?: XOR<SupplierCreateWithoutRawMaterialsOrderListInput, SupplierUncheckedCreateWithoutRawMaterialsOrderListInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutRawMaterialsOrderListInput
    connect?: SupplierWhereUniqueInput
  }

  export type SupplierUpdateOneWithoutRawMaterialsOrderListNestedInput = {
    create?: XOR<SupplierCreateWithoutRawMaterialsOrderListInput, SupplierUncheckedCreateWithoutRawMaterialsOrderListInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutRawMaterialsOrderListInput
    upsert?: SupplierUpsertWithoutRawMaterialsOrderListInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutRawMaterialsOrderListInput, SupplierUpdateWithoutRawMaterialsOrderListInput>, SupplierUncheckedUpdateWithoutRawMaterialsOrderListInput>
  }

  export type LogEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<LogEntryCreateWithoutUserInput, LogEntryUncheckedCreateWithoutUserInput> | LogEntryCreateWithoutUserInput[] | LogEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutUserInput | LogEntryCreateOrConnectWithoutUserInput[]
    createMany?: LogEntryCreateManyUserInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type LogEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogEntryCreateWithoutUserInput, LogEntryUncheckedCreateWithoutUserInput> | LogEntryCreateWithoutUserInput[] | LogEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutUserInput | LogEntryCreateOrConnectWithoutUserInput[]
    createMany?: LogEntryCreateManyUserInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type LogEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogEntryCreateWithoutUserInput, LogEntryUncheckedCreateWithoutUserInput> | LogEntryCreateWithoutUserInput[] | LogEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutUserInput | LogEntryCreateOrConnectWithoutUserInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutUserInput | LogEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogEntryCreateManyUserInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutUserInput | LogEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutUserInput | LogEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type LogEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogEntryCreateWithoutUserInput, LogEntryUncheckedCreateWithoutUserInput> | LogEntryCreateWithoutUserInput[] | LogEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutUserInput | LogEntryCreateOrConnectWithoutUserInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutUserInput | LogEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogEntryCreateManyUserInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutUserInput | LogEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutUserInput | LogEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type OrdersCreateNestedOneWithoutProductionInput = {
    create?: XOR<OrdersCreateWithoutProductionInput, OrdersUncheckedCreateWithoutProductionInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutProductionInput
    connect?: OrdersWhereUniqueInput
  }

  export type EnumProductionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductionStatus
  }

  export type OrdersUpdateOneRequiredWithoutProductionNestedInput = {
    create?: XOR<OrdersCreateWithoutProductionInput, OrdersUncheckedCreateWithoutProductionInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutProductionInput
    upsert?: OrdersUpsertWithoutProductionInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutProductionInput, OrdersUpdateWithoutProductionInput>, OrdersUncheckedUpdateWithoutProductionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumInventoryItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryItemType | EnumInventoryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryItemTypeFilter<$PrismaModel> | $Enums.InventoryItemType
  }

  export type NestedEnumInventoryItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryItemType | EnumInventoryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryItemType[] | ListEnumInventoryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryItemTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryItemTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumItemTypeNullableFilter<$PrismaModel> | $Enums.ItemType | null
  }

  export type NestedEnumItemTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumItemTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ItemType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumItemTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumItemTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusFilter<$PrismaModel> | $Enums.ProductionStatus
  }

  export type NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionStatusFilter<$PrismaModel>
  }

  export type RackCreateWithoutLocationInput = {
    name: string
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
    bunches?: BunchCreateNestedManyWithoutRackInput
  }

  export type RackUncheckedCreateWithoutLocationInput = {
    id?: number
    name: string
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
    bunches?: BunchUncheckedCreateNestedManyWithoutRackInput
  }

  export type RackCreateOrConnectWithoutLocationInput = {
    where: RackWhereUniqueInput
    create: XOR<RackCreateWithoutLocationInput, RackUncheckedCreateWithoutLocationInput>
  }

  export type RackCreateManyLocationInputEnvelope = {
    data: RackCreateManyLocationInput | RackCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type RackUpsertWithWhereUniqueWithoutLocationInput = {
    where: RackWhereUniqueInput
    update: XOR<RackUpdateWithoutLocationInput, RackUncheckedUpdateWithoutLocationInput>
    create: XOR<RackCreateWithoutLocationInput, RackUncheckedCreateWithoutLocationInput>
  }

  export type RackUpdateWithWhereUniqueWithoutLocationInput = {
    where: RackWhereUniqueInput
    data: XOR<RackUpdateWithoutLocationInput, RackUncheckedUpdateWithoutLocationInput>
  }

  export type RackUpdateManyWithWhereWithoutLocationInput = {
    where: RackScalarWhereInput
    data: XOR<RackUpdateManyMutationInput, RackUncheckedUpdateManyWithoutLocationInput>
  }

  export type RackScalarWhereInput = {
    AND?: RackScalarWhereInput | RackScalarWhereInput[]
    OR?: RackScalarWhereInput[]
    NOT?: RackScalarWhereInput | RackScalarWhereInput[]
    id?: IntFilter<"Rack"> | number
    name?: StringFilter<"Rack"> | string
    location_id?: IntFilter<"Rack"> | number
    capacity?: IntFilter<"Rack"> | number
    current_utilization?: IntFilter<"Rack"> | number
    createdAt?: DateTimeFilter<"Rack"> | Date | string
  }

  export type LocationCreateWithoutRacksInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type LocationUncheckedCreateWithoutRacksInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type LocationCreateOrConnectWithoutRacksInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRacksInput, LocationUncheckedCreateWithoutRacksInput>
  }

  export type BunchCreateWithoutRackInput = {
    name: string
    createdAt?: Date | string
    items?: InventoryItemCreateNestedManyWithoutBunchInput
  }

  export type BunchUncheckedCreateWithoutRackInput = {
    id?: number
    name: string
    createdAt?: Date | string
    items?: InventoryItemUncheckedCreateNestedManyWithoutBunchInput
  }

  export type BunchCreateOrConnectWithoutRackInput = {
    where: BunchWhereUniqueInput
    create: XOR<BunchCreateWithoutRackInput, BunchUncheckedCreateWithoutRackInput>
  }

  export type BunchCreateManyRackInputEnvelope = {
    data: BunchCreateManyRackInput | BunchCreateManyRackInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutRacksInput = {
    update: XOR<LocationUpdateWithoutRacksInput, LocationUncheckedUpdateWithoutRacksInput>
    create: XOR<LocationCreateWithoutRacksInput, LocationUncheckedCreateWithoutRacksInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRacksInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRacksInput, LocationUncheckedUpdateWithoutRacksInput>
  }

  export type LocationUpdateWithoutRacksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateWithoutRacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BunchUpsertWithWhereUniqueWithoutRackInput = {
    where: BunchWhereUniqueInput
    update: XOR<BunchUpdateWithoutRackInput, BunchUncheckedUpdateWithoutRackInput>
    create: XOR<BunchCreateWithoutRackInput, BunchUncheckedCreateWithoutRackInput>
  }

  export type BunchUpdateWithWhereUniqueWithoutRackInput = {
    where: BunchWhereUniqueInput
    data: XOR<BunchUpdateWithoutRackInput, BunchUncheckedUpdateWithoutRackInput>
  }

  export type BunchUpdateManyWithWhereWithoutRackInput = {
    where: BunchScalarWhereInput
    data: XOR<BunchUpdateManyMutationInput, BunchUncheckedUpdateManyWithoutRackInput>
  }

  export type BunchScalarWhereInput = {
    AND?: BunchScalarWhereInput | BunchScalarWhereInput[]
    OR?: BunchScalarWhereInput[]
    NOT?: BunchScalarWhereInput | BunchScalarWhereInput[]
    id?: IntFilter<"Bunch"> | number
    name?: StringFilter<"Bunch"> | string
    rack_id?: IntFilter<"Bunch"> | number
    createdAt?: DateTimeFilter<"Bunch"> | Date | string
  }

  export type RackCreateWithoutBunchesInput = {
    name: string
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutRacksInput
  }

  export type RackUncheckedCreateWithoutBunchesInput = {
    id?: number
    name: string
    location_id: number
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
  }

  export type RackCreateOrConnectWithoutBunchesInput = {
    where: RackWhereUniqueInput
    create: XOR<RackCreateWithoutBunchesInput, RackUncheckedCreateWithoutBunchesInput>
  }

  export type InventoryItemCreateWithoutBunchInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    quantity?: number | null
    unit?: UnitCreateNestedOneWithoutItemsInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    movement_logs?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutBunchInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    unit_id?: number | null
    quantity?: number | null
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    movement_logs?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutBunchInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutBunchInput, InventoryItemUncheckedCreateWithoutBunchInput>
  }

  export type InventoryItemCreateManyBunchInputEnvelope = {
    data: InventoryItemCreateManyBunchInput | InventoryItemCreateManyBunchInput[]
    skipDuplicates?: boolean
  }

  export type RackUpsertWithoutBunchesInput = {
    update: XOR<RackUpdateWithoutBunchesInput, RackUncheckedUpdateWithoutBunchesInput>
    create: XOR<RackCreateWithoutBunchesInput, RackUncheckedCreateWithoutBunchesInput>
    where?: RackWhereInput
  }

  export type RackUpdateToOneWithWhereWithoutBunchesInput = {
    where?: RackWhereInput
    data: XOR<RackUpdateWithoutBunchesInput, RackUncheckedUpdateWithoutBunchesInput>
  }

  export type RackUpdateWithoutBunchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutRacksNestedInput
  }

  export type RackUncheckedUpdateWithoutBunchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutBunchInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutBunchInput, InventoryItemUncheckedUpdateWithoutBunchInput>
    create: XOR<InventoryItemCreateWithoutBunchInput, InventoryItemUncheckedCreateWithoutBunchInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutBunchInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutBunchInput, InventoryItemUncheckedUpdateWithoutBunchInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutBunchInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutBunchInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    item_id?: StringFilter<"InventoryItem"> | string
    item_name?: StringFilter<"InventoryItem"> | string
    item_type?: EnumInventoryItemTypeFilter<"InventoryItem"> | $Enums.InventoryItemType
    bunch_id?: IntNullableFilter<"InventoryItem"> | number | null
    unit_id?: IntNullableFilter<"InventoryItem"> | number | null
    quantity?: FloatNullableFilter<"InventoryItem"> | number | null
  }

  export type InventoryItemCreateWithoutUnitInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    quantity?: number | null
    bunch?: BunchCreateNestedOneWithoutItemsInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
    movement_logs?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutUnitInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id?: number | null
    quantity?: number | null
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
    movement_logs?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutUnitInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutUnitInput, InventoryItemUncheckedCreateWithoutUnitInput>
  }

  export type InventoryItemCreateManyUnitInputEnvelope = {
    data: InventoryItemCreateManyUnitInput | InventoryItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutUnitInput, InventoryItemUncheckedUpdateWithoutUnitInput>
    create: XOR<InventoryItemCreateWithoutUnitInput, InventoryItemUncheckedCreateWithoutUnitInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutUnitInput, InventoryItemUncheckedUpdateWithoutUnitInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutUnitInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type InventoryItemCreateWithoutMovement_logsInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    quantity?: number | null
    bunch?: BunchCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    suppliers?: ItemSupplierCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutMovement_logsInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id?: number | null
    unit_id?: number | null
    quantity?: number | null
    suppliers?: ItemSupplierUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutMovement_logsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutMovement_logsInput, InventoryItemUncheckedCreateWithoutMovement_logsInput>
  }

  export type InventoryItemUpsertWithoutMovement_logsInput = {
    update: XOR<InventoryItemUpdateWithoutMovement_logsInput, InventoryItemUncheckedUpdateWithoutMovement_logsInput>
    create: XOR<InventoryItemCreateWithoutMovement_logsInput, InventoryItemUncheckedCreateWithoutMovement_logsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutMovement_logsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutMovement_logsInput, InventoryItemUncheckedUpdateWithoutMovement_logsInput>
  }

  export type InventoryItemUpdateWithoutMovement_logsInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    bunch?: BunchUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutMovement_logsInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    bunch_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateWithoutSuppliersInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    quantity?: number | null
    bunch?: BunchCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    movement_logs?: InventoryMovementCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutSuppliersInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id?: number | null
    unit_id?: number | null
    quantity?: number | null
    movement_logs?: InventoryMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutSuppliersInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutSuppliersInput, InventoryItemUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierCreateWithoutItemSupplierInput = {
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    FabricOrderList?: FabricOrderListCreateNestedManyWithoutSupplierInput
    RawMaterialsOrderList?: RawMaterialsOrderListCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutItemSupplierInput = {
    supplier_id?: number
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    FabricOrderList?: FabricOrderListUncheckedCreateNestedManyWithoutSupplierInput
    RawMaterialsOrderList?: RawMaterialsOrderListUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutItemSupplierInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutItemSupplierInput, SupplierUncheckedCreateWithoutItemSupplierInput>
  }

  export type InventoryItemUpsertWithoutSuppliersInput = {
    update: XOR<InventoryItemUpdateWithoutSuppliersInput, InventoryItemUncheckedUpdateWithoutSuppliersInput>
    create: XOR<InventoryItemCreateWithoutSuppliersInput, InventoryItemUncheckedCreateWithoutSuppliersInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutSuppliersInput, InventoryItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type InventoryItemUpdateWithoutSuppliersInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    bunch?: BunchUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    movement_logs?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutSuppliersInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    bunch_id?: NullableIntFieldUpdateOperationsInput | number | null
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    movement_logs?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierUpsertWithoutItemSupplierInput = {
    update: XOR<SupplierUpdateWithoutItemSupplierInput, SupplierUncheckedUpdateWithoutItemSupplierInput>
    create: XOR<SupplierCreateWithoutItemSupplierInput, SupplierUncheckedCreateWithoutItemSupplierInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutItemSupplierInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutItemSupplierInput, SupplierUncheckedUpdateWithoutItemSupplierInput>
  }

  export type SupplierUpdateWithoutItemSupplierInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    FabricOrderList?: FabricOrderListUpdateManyWithoutSupplierNestedInput
    RawMaterialsOrderList?: RawMaterialsOrderListUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutItemSupplierInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    FabricOrderList?: FabricOrderListUncheckedUpdateManyWithoutSupplierNestedInput
    RawMaterialsOrderList?: RawMaterialsOrderListUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type BunchCreateWithoutItemsInput = {
    name: string
    createdAt?: Date | string
    rack: RackCreateNestedOneWithoutBunchesInput
  }

  export type BunchUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    rack_id: number
    createdAt?: Date | string
  }

  export type BunchCreateOrConnectWithoutItemsInput = {
    where: BunchWhereUniqueInput
    create: XOR<BunchCreateWithoutItemsInput, BunchUncheckedCreateWithoutItemsInput>
  }

  export type UnitCreateWithoutItemsInput = {
    name: string
    symbol: string
    baseUnit?: string | null
    conversion_rate?: number | null
  }

  export type UnitUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    symbol: string
    baseUnit?: string | null
    conversion_rate?: number | null
  }

  export type UnitCreateOrConnectWithoutItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
  }

  export type ItemSupplierCreateWithoutItemInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
    supplier: SupplierCreateNestedOneWithoutItemSupplierInput
  }

  export type ItemSupplierUncheckedCreateWithoutItemInput = {
    id?: number
    supplier_id: number
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
  }

  export type ItemSupplierCreateOrConnectWithoutItemInput = {
    where: ItemSupplierWhereUniqueInput
    create: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput>
  }

  export type ItemSupplierCreateManyItemInputEnvelope = {
    data: ItemSupplierCreateManyItemInput | ItemSupplierCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutItemInput = {
    type: $Enums.MovementType
    quantity: number
    note?: string | null
    moved_at?: Date | string
  }

  export type InventoryMovementUncheckedCreateWithoutItemInput = {
    id?: number
    type: $Enums.MovementType
    quantity: number
    note?: string | null
    moved_at?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementCreateManyItemInputEnvelope = {
    data: InventoryMovementCreateManyItemInput | InventoryMovementCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type BunchUpsertWithoutItemsInput = {
    update: XOR<BunchUpdateWithoutItemsInput, BunchUncheckedUpdateWithoutItemsInput>
    create: XOR<BunchCreateWithoutItemsInput, BunchUncheckedCreateWithoutItemsInput>
    where?: BunchWhereInput
  }

  export type BunchUpdateToOneWithWhereWithoutItemsInput = {
    where?: BunchWhereInput
    data: XOR<BunchUpdateWithoutItemsInput, BunchUncheckedUpdateWithoutItemsInput>
  }

  export type BunchUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rack?: RackUpdateOneRequiredWithoutBunchesNestedInput
  }

  export type BunchUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rack_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpsertWithoutItemsInput = {
    update: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type UnitUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    baseUnit?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UnitUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    baseUnit?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ItemSupplierUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemSupplierWhereUniqueInput
    update: XOR<ItemSupplierUpdateWithoutItemInput, ItemSupplierUncheckedUpdateWithoutItemInput>
    create: XOR<ItemSupplierCreateWithoutItemInput, ItemSupplierUncheckedCreateWithoutItemInput>
  }

  export type ItemSupplierUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemSupplierWhereUniqueInput
    data: XOR<ItemSupplierUpdateWithoutItemInput, ItemSupplierUncheckedUpdateWithoutItemInput>
  }

  export type ItemSupplierUpdateManyWithWhereWithoutItemInput = {
    where: ItemSupplierScalarWhereInput
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemSupplierScalarWhereInput = {
    AND?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
    OR?: ItemSupplierScalarWhereInput[]
    NOT?: ItemSupplierScalarWhereInput | ItemSupplierScalarWhereInput[]
    id?: IntFilter<"ItemSupplier"> | number
    item_id?: StringFilter<"ItemSupplier"> | string
    supplier_id?: IntFilter<"ItemSupplier"> | number
    price?: DecimalNullableFilter<"ItemSupplier"> | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFilter<"ItemSupplier"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryMovementCreateWithoutItemInput, InventoryMovementUncheckedCreateWithoutItemInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutItemInput, InventoryMovementUncheckedUpdateWithoutItemInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutItemInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: IntFilter<"InventoryMovement"> | number
    item_id?: StringFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: FloatFilter<"InventoryMovement"> | number
    note?: StringNullableFilter<"InventoryMovement"> | string | null
    moved_at?: DateTimeFilter<"InventoryMovement"> | Date | string
  }

  export type OrdersCreateWithoutCustomerInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutCustomerInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutCustomerInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutCustomerInput, OrdersUncheckedCreateWithoutCustomerInput>
  }

  export type OrdersCreateManyCustomerInputEnvelope = {
    data: OrdersCreateManyCustomerInput | OrdersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type FinalJacketMeasurementCreateWithoutCustomerInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    order?: OrdersCreateNestedOneWithoutFinalJacketMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_jacket_measurementInput
  }

  export type FinalJacketMeasurementUncheckedCreateWithoutCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_jacket_measurementInput
  }

  export type FinalJacketMeasurementCreateOrConnectWithoutCustomerInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    create: XOR<FinalJacketMeasurementCreateWithoutCustomerInput, FinalJacketMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type FinalJacketMeasurementCreateManyCustomerInputEnvelope = {
    data: FinalJacketMeasurementCreateManyCustomerInput | FinalJacketMeasurementCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type FinalPantMeasurementCreateWithoutCustomerInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    order?: OrdersCreateNestedOneWithoutFinalPantMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_pant_measurementInput
  }

  export type FinalPantMeasurementUncheckedCreateWithoutCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_pant_measurementInput
  }

  export type FinalPantMeasurementCreateOrConnectWithoutCustomerInput = {
    where: FinalPantMeasurementWhereUniqueInput
    create: XOR<FinalPantMeasurementCreateWithoutCustomerInput, FinalPantMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type FinalPantMeasurementCreateManyCustomerInputEnvelope = {
    data: FinalPantMeasurementCreateManyCustomerInput | FinalPantMeasurementCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type FinalShirtMeasurementCreateWithoutCustomerInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    order?: OrdersCreateNestedOneWithoutFinalShirtMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_shirt_measurementInput
  }

  export type FinalShirtMeasurementUncheckedCreateWithoutCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_shirt_measurementInput
  }

  export type FinalShirtMeasurementCreateOrConnectWithoutCustomerInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    create: XOR<FinalShirtMeasurementCreateWithoutCustomerInput, FinalShirtMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type FinalShirtMeasurementCreateManyCustomerInputEnvelope = {
    data: FinalShirtMeasurementCreateManyCustomerInput | FinalShirtMeasurementCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type JacketMeasurementCreateWithoutCustomerInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    order?: OrdersCreateNestedOneWithoutJacketMeasurementInput
    Items?: ItemsCreateNestedManyWithoutJacket_measurementInput
  }

  export type JacketMeasurementUncheckedCreateWithoutCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutJacket_measurementInput
  }

  export type JacketMeasurementCreateOrConnectWithoutCustomerInput = {
    where: JacketMeasurementWhereUniqueInput
    create: XOR<JacketMeasurementCreateWithoutCustomerInput, JacketMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type JacketMeasurementCreateManyCustomerInputEnvelope = {
    data: JacketMeasurementCreateManyCustomerInput | JacketMeasurementCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PantMeasurementCreateWithoutCustomerInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    order?: OrdersCreateNestedOneWithoutPantMeasurementInput
    Items?: ItemsCreateNestedManyWithoutPant_measurementInput
  }

  export type PantMeasurementUncheckedCreateWithoutCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutPant_measurementInput
  }

  export type PantMeasurementCreateOrConnectWithoutCustomerInput = {
    where: PantMeasurementWhereUniqueInput
    create: XOR<PantMeasurementCreateWithoutCustomerInput, PantMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type PantMeasurementCreateManyCustomerInputEnvelope = {
    data: PantMeasurementCreateManyCustomerInput | PantMeasurementCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ShirtMeasurementCreateWithoutCustomerInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    order?: OrdersCreateNestedOneWithoutShirtMeasurementInput
    Items?: ItemsCreateNestedManyWithoutShirt_measurementInput
  }

  export type ShirtMeasurementUncheckedCreateWithoutCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutShirt_measurementInput
  }

  export type ShirtMeasurementCreateOrConnectWithoutCustomerInput = {
    where: ShirtMeasurementWhereUniqueInput
    create: XOR<ShirtMeasurementCreateWithoutCustomerInput, ShirtMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type ShirtMeasurementCreateManyCustomerInputEnvelope = {
    data: ShirtMeasurementCreateManyCustomerInput | ShirtMeasurementCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrdersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutCustomerInput, OrdersUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrdersCreateWithoutCustomerInput, OrdersUncheckedCreateWithoutCustomerInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutCustomerInput, OrdersUncheckedUpdateWithoutCustomerInput>
  }

  export type OrdersUpdateManyWithWhereWithoutCustomerInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    OR?: OrdersScalarWhereInput[]
    NOT?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    orderNo?: StringFilter<"Orders"> | string
    customer_id?: IntNullableFilter<"Orders"> | number | null
    date?: DateTimeNullableFilter<"Orders"> | Date | string | null
    onote?: StringNullableFilter<"Orders"> | string | null
  }

  export type FinalJacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    update: XOR<FinalJacketMeasurementUpdateWithoutCustomerInput, FinalJacketMeasurementUncheckedUpdateWithoutCustomerInput>
    create: XOR<FinalJacketMeasurementCreateWithoutCustomerInput, FinalJacketMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type FinalJacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    data: XOR<FinalJacketMeasurementUpdateWithoutCustomerInput, FinalJacketMeasurementUncheckedUpdateWithoutCustomerInput>
  }

  export type FinalJacketMeasurementUpdateManyWithWhereWithoutCustomerInput = {
    where: FinalJacketMeasurementScalarWhereInput
    data: XOR<FinalJacketMeasurementUpdateManyMutationInput, FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerInput>
  }

  export type FinalJacketMeasurementScalarWhereInput = {
    AND?: FinalJacketMeasurementScalarWhereInput | FinalJacketMeasurementScalarWhereInput[]
    OR?: FinalJacketMeasurementScalarWhereInput[]
    NOT?: FinalJacketMeasurementScalarWhereInput | FinalJacketMeasurementScalarWhereInput[]
    measurement_id?: StringFilter<"FinalJacketMeasurement"> | string
    customer_id?: IntNullableFilter<"FinalJacketMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalJacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    natural_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    back_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    x_back?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    chest?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    collar?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    waist_coat_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    sherwani_length?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalJacketMeasurement"> | string | null
  }

  export type FinalPantMeasurementUpsertWithWhereUniqueWithoutCustomerInput = {
    where: FinalPantMeasurementWhereUniqueInput
    update: XOR<FinalPantMeasurementUpdateWithoutCustomerInput, FinalPantMeasurementUncheckedUpdateWithoutCustomerInput>
    create: XOR<FinalPantMeasurementCreateWithoutCustomerInput, FinalPantMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type FinalPantMeasurementUpdateWithWhereUniqueWithoutCustomerInput = {
    where: FinalPantMeasurementWhereUniqueInput
    data: XOR<FinalPantMeasurementUpdateWithoutCustomerInput, FinalPantMeasurementUncheckedUpdateWithoutCustomerInput>
  }

  export type FinalPantMeasurementUpdateManyWithWhereWithoutCustomerInput = {
    where: FinalPantMeasurementScalarWhereInput
    data: XOR<FinalPantMeasurementUpdateManyMutationInput, FinalPantMeasurementUncheckedUpdateManyWithoutCustomerInput>
  }

  export type FinalPantMeasurementScalarWhereInput = {
    AND?: FinalPantMeasurementScalarWhereInput | FinalPantMeasurementScalarWhereInput[]
    OR?: FinalPantMeasurementScalarWhereInput[]
    NOT?: FinalPantMeasurementScalarWhereInput | FinalPantMeasurementScalarWhereInput[]
    measurement_id?: StringFilter<"FinalPantMeasurement"> | string
    customer_id?: IntNullableFilter<"FinalPantMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalPantMeasurement"> | Date | string | null
    length?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    inseem?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    hips?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    bottom?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    knee?: StringNullableFilter<"FinalPantMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalPantMeasurement"> | string | null
  }

  export type FinalShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    update: XOR<FinalShirtMeasurementUpdateWithoutCustomerInput, FinalShirtMeasurementUncheckedUpdateWithoutCustomerInput>
    create: XOR<FinalShirtMeasurementCreateWithoutCustomerInput, FinalShirtMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type FinalShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    data: XOR<FinalShirtMeasurementUpdateWithoutCustomerInput, FinalShirtMeasurementUncheckedUpdateWithoutCustomerInput>
  }

  export type FinalShirtMeasurementUpdateManyWithWhereWithoutCustomerInput = {
    where: FinalShirtMeasurementScalarWhereInput
    data: XOR<FinalShirtMeasurementUpdateManyMutationInput, FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerInput>
  }

  export type FinalShirtMeasurementScalarWhereInput = {
    AND?: FinalShirtMeasurementScalarWhereInput | FinalShirtMeasurementScalarWhereInput[]
    OR?: FinalShirtMeasurementScalarWhereInput[]
    NOT?: FinalShirtMeasurementScalarWhereInput | FinalShirtMeasurementScalarWhereInput[]
    measurement_id?: StringFilter<"FinalShirtMeasurement"> | string
    customer_id?: IntNullableFilter<"FinalShirtMeasurement"> | number | null
    orderNo?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    date?: DateTimeNullableFilter<"FinalShirtMeasurement"> | Date | string | null
    length?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    chest?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    waist?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    collar?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
    other_notes?: StringNullableFilter<"FinalShirtMeasurement"> | string | null
  }

  export type JacketMeasurementUpsertWithWhereUniqueWithoutCustomerInput = {
    where: JacketMeasurementWhereUniqueInput
    update: XOR<JacketMeasurementUpdateWithoutCustomerInput, JacketMeasurementUncheckedUpdateWithoutCustomerInput>
    create: XOR<JacketMeasurementCreateWithoutCustomerInput, JacketMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type JacketMeasurementUpdateWithWhereUniqueWithoutCustomerInput = {
    where: JacketMeasurementWhereUniqueInput
    data: XOR<JacketMeasurementUpdateWithoutCustomerInput, JacketMeasurementUncheckedUpdateWithoutCustomerInput>
  }

  export type JacketMeasurementUpdateManyWithWhereWithoutCustomerInput = {
    where: JacketMeasurementScalarWhereInput
    data: XOR<JacketMeasurementUpdateManyMutationInput, JacketMeasurementUncheckedUpdateManyWithoutCustomerInput>
  }

  export type JacketMeasurementScalarWhereInput = {
    AND?: JacketMeasurementScalarWhereInput | JacketMeasurementScalarWhereInput[]
    OR?: JacketMeasurementScalarWhereInput[]
    NOT?: JacketMeasurementScalarWhereInput | JacketMeasurementScalarWhereInput[]
    measurement_id?: StringFilter<"JacketMeasurement"> | string
    customer_id?: IntNullableFilter<"JacketMeasurement"> | number | null
    orderNo?: StringNullableFilter<"JacketMeasurement"> | string | null
    date?: DateTimeNullableFilter<"JacketMeasurement"> | Date | string | null
    jacket_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    natural_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    back_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    x_back?: StringNullableFilter<"JacketMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"JacketMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"JacketMeasurement"> | string | null
    chest?: StringNullableFilter<"JacketMeasurement"> | string | null
    waist?: StringNullableFilter<"JacketMeasurement"> | string | null
    collar?: StringNullableFilter<"JacketMeasurement"> | string | null
    waist_coat_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    sherwani_length?: StringNullableFilter<"JacketMeasurement"> | string | null
    other_notes?: StringNullableFilter<"JacketMeasurement"> | string | null
  }

  export type PantMeasurementUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PantMeasurementWhereUniqueInput
    update: XOR<PantMeasurementUpdateWithoutCustomerInput, PantMeasurementUncheckedUpdateWithoutCustomerInput>
    create: XOR<PantMeasurementCreateWithoutCustomerInput, PantMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type PantMeasurementUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PantMeasurementWhereUniqueInput
    data: XOR<PantMeasurementUpdateWithoutCustomerInput, PantMeasurementUncheckedUpdateWithoutCustomerInput>
  }

  export type PantMeasurementUpdateManyWithWhereWithoutCustomerInput = {
    where: PantMeasurementScalarWhereInput
    data: XOR<PantMeasurementUpdateManyMutationInput, PantMeasurementUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PantMeasurementScalarWhereInput = {
    AND?: PantMeasurementScalarWhereInput | PantMeasurementScalarWhereInput[]
    OR?: PantMeasurementScalarWhereInput[]
    NOT?: PantMeasurementScalarWhereInput | PantMeasurementScalarWhereInput[]
    measurement_id?: StringFilter<"PantMeasurement"> | string
    customer_id?: IntNullableFilter<"PantMeasurement"> | number | null
    orderNo?: StringNullableFilter<"PantMeasurement"> | string | null
    date?: DateTimeNullableFilter<"PantMeasurement"> | Date | string | null
    length?: StringNullableFilter<"PantMeasurement"> | string | null
    inseem?: StringNullableFilter<"PantMeasurement"> | string | null
    waist?: StringNullableFilter<"PantMeasurement"> | string | null
    hips?: StringNullableFilter<"PantMeasurement"> | string | null
    bottom?: StringNullableFilter<"PantMeasurement"> | string | null
    knee?: StringNullableFilter<"PantMeasurement"> | string | null
    other_notes?: StringNullableFilter<"PantMeasurement"> | string | null
  }

  export type ShirtMeasurementUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ShirtMeasurementWhereUniqueInput
    update: XOR<ShirtMeasurementUpdateWithoutCustomerInput, ShirtMeasurementUncheckedUpdateWithoutCustomerInput>
    create: XOR<ShirtMeasurementCreateWithoutCustomerInput, ShirtMeasurementUncheckedCreateWithoutCustomerInput>
  }

  export type ShirtMeasurementUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ShirtMeasurementWhereUniqueInput
    data: XOR<ShirtMeasurementUpdateWithoutCustomerInput, ShirtMeasurementUncheckedUpdateWithoutCustomerInput>
  }

  export type ShirtMeasurementUpdateManyWithWhereWithoutCustomerInput = {
    where: ShirtMeasurementScalarWhereInput
    data: XOR<ShirtMeasurementUpdateManyMutationInput, ShirtMeasurementUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ShirtMeasurementScalarWhereInput = {
    AND?: ShirtMeasurementScalarWhereInput | ShirtMeasurementScalarWhereInput[]
    OR?: ShirtMeasurementScalarWhereInput[]
    NOT?: ShirtMeasurementScalarWhereInput | ShirtMeasurementScalarWhereInput[]
    measurement_id?: StringFilter<"ShirtMeasurement"> | string
    customer_id?: IntNullableFilter<"ShirtMeasurement"> | number | null
    orderNo?: StringNullableFilter<"ShirtMeasurement"> | string | null
    date?: DateTimeNullableFilter<"ShirtMeasurement"> | Date | string | null
    length?: StringNullableFilter<"ShirtMeasurement"> | string | null
    half_shoulder?: StringNullableFilter<"ShirtMeasurement"> | string | null
    to_sleeve?: StringNullableFilter<"ShirtMeasurement"> | string | null
    chest?: StringNullableFilter<"ShirtMeasurement"> | string | null
    waist?: StringNullableFilter<"ShirtMeasurement"> | string | null
    collar?: StringNullableFilter<"ShirtMeasurement"> | string | null
    other_notes?: StringNullableFilter<"ShirtMeasurement"> | string | null
  }

  export type FabricOrderListCreateWithoutFabricInput = {
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    supplier?: SupplierCreateNestedOneWithoutFabricOrderListInput
  }

  export type FabricOrderListUncheckedCreateWithoutFabricInput = {
    order_id?: number
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    supplier_id?: number | null
  }

  export type FabricOrderListCreateOrConnectWithoutFabricInput = {
    where: FabricOrderListWhereUniqueInput
    create: XOR<FabricOrderListCreateWithoutFabricInput, FabricOrderListUncheckedCreateWithoutFabricInput>
  }

  export type FabricOrderListCreateManyFabricInputEnvelope = {
    data: FabricOrderListCreateManyFabricInput | FabricOrderListCreateManyFabricInput[]
    skipDuplicates?: boolean
  }

  export type ItemsCreateWithoutFabricInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutFabricInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutFabricInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutFabricInput, ItemsUncheckedCreateWithoutFabricInput>
  }

  export type ItemsCreateManyFabricInputEnvelope = {
    data: ItemsCreateManyFabricInput | ItemsCreateManyFabricInput[]
    skipDuplicates?: boolean
  }

  export type ItemsCreateWithoutLining_fabricInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutLining_fabricInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutLining_fabricInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutLining_fabricInput, ItemsUncheckedCreateWithoutLining_fabricInput>
  }

  export type ItemsCreateManyLining_fabricInputEnvelope = {
    data: ItemsCreateManyLining_fabricInput | ItemsCreateManyLining_fabricInput[]
    skipDuplicates?: boolean
  }

  export type FabricOrderListUpsertWithWhereUniqueWithoutFabricInput = {
    where: FabricOrderListWhereUniqueInput
    update: XOR<FabricOrderListUpdateWithoutFabricInput, FabricOrderListUncheckedUpdateWithoutFabricInput>
    create: XOR<FabricOrderListCreateWithoutFabricInput, FabricOrderListUncheckedCreateWithoutFabricInput>
  }

  export type FabricOrderListUpdateWithWhereUniqueWithoutFabricInput = {
    where: FabricOrderListWhereUniqueInput
    data: XOR<FabricOrderListUpdateWithoutFabricInput, FabricOrderListUncheckedUpdateWithoutFabricInput>
  }

  export type FabricOrderListUpdateManyWithWhereWithoutFabricInput = {
    where: FabricOrderListScalarWhereInput
    data: XOR<FabricOrderListUpdateManyMutationInput, FabricOrderListUncheckedUpdateManyWithoutFabricInput>
  }

  export type FabricOrderListScalarWhereInput = {
    AND?: FabricOrderListScalarWhereInput | FabricOrderListScalarWhereInput[]
    OR?: FabricOrderListScalarWhereInput[]
    NOT?: FabricOrderListScalarWhereInput | FabricOrderListScalarWhereInput[]
    order_id?: IntFilter<"FabricOrderList"> | number
    fabric_id?: IntNullableFilter<"FabricOrderList"> | number | null
    description?: StringNullableFilter<"FabricOrderList"> | string | null
    supplier_name?: StringNullableFilter<"FabricOrderList"> | string | null
    meters?: DecimalNullableFilter<"FabricOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableFilter<"FabricOrderList"> | Date | string | null
    ordered_for?: StringNullableFilter<"FabricOrderList"> | string | null
    supplier_id?: IntNullableFilter<"FabricOrderList"> | number | null
  }

  export type ItemsUpsertWithWhereUniqueWithoutFabricInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutFabricInput, ItemsUncheckedUpdateWithoutFabricInput>
    create: XOR<ItemsCreateWithoutFabricInput, ItemsUncheckedCreateWithoutFabricInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutFabricInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutFabricInput, ItemsUncheckedUpdateWithoutFabricInput>
  }

  export type ItemsUpdateManyWithWhereWithoutFabricInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutFabricInput>
  }

  export type ItemsScalarWhereInput = {
    AND?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
    OR?: ItemsScalarWhereInput[]
    NOT?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
    item_id?: IntFilter<"Items"> | number
    orderNo?: StringNullableFilter<"Items"> | string | null
    item_name?: StringNullableFilter<"Items"> | string | null
    item_type?: EnumItemTypeNullableFilter<"Items"> | $Enums.ItemType | null
    fabric_id?: IntNullableFilter<"Items"> | number | null
    lining_fabric_id?: IntNullableFilter<"Items"> | number | null
    jacket_measurement_id?: StringNullableFilter<"Items"> | string | null
    shirt_measurement_id?: StringNullableFilter<"Items"> | string | null
    pant_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_jacket_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_shirt_measurement_id?: StringNullableFilter<"Items"> | string | null
    final_pant_measurement_id?: StringNullableFilter<"Items"> | string | null
  }

  export type ItemsUpsertWithWhereUniqueWithoutLining_fabricInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutLining_fabricInput, ItemsUncheckedUpdateWithoutLining_fabricInput>
    create: XOR<ItemsCreateWithoutLining_fabricInput, ItemsUncheckedCreateWithoutLining_fabricInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutLining_fabricInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutLining_fabricInput, ItemsUncheckedUpdateWithoutLining_fabricInput>
  }

  export type ItemsUpdateManyWithWhereWithoutLining_fabricInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutLining_fabricInput>
  }

  export type FabricCreateWithoutFabricOrdersInput = {
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    items?: ItemsCreateNestedManyWithoutFabricInput
    liningItems?: ItemsCreateNestedManyWithoutLining_fabricInput
  }

  export type FabricUncheckedCreateWithoutFabricOrdersInput = {
    fabric_id?: number
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutFabricInput
    liningItems?: ItemsUncheckedCreateNestedManyWithoutLining_fabricInput
  }

  export type FabricCreateOrConnectWithoutFabricOrdersInput = {
    where: FabricWhereUniqueInput
    create: XOR<FabricCreateWithoutFabricOrdersInput, FabricUncheckedCreateWithoutFabricOrdersInput>
  }

  export type SupplierCreateWithoutFabricOrderListInput = {
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    RawMaterialsOrderList?: RawMaterialsOrderListCreateNestedManyWithoutSupplierInput
    ItemSupplier?: ItemSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutFabricOrderListInput = {
    supplier_id?: number
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    RawMaterialsOrderList?: RawMaterialsOrderListUncheckedCreateNestedManyWithoutSupplierInput
    ItemSupplier?: ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutFabricOrderListInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutFabricOrderListInput, SupplierUncheckedCreateWithoutFabricOrderListInput>
  }

  export type FabricUpsertWithoutFabricOrdersInput = {
    update: XOR<FabricUpdateWithoutFabricOrdersInput, FabricUncheckedUpdateWithoutFabricOrdersInput>
    create: XOR<FabricCreateWithoutFabricOrdersInput, FabricUncheckedCreateWithoutFabricOrdersInput>
    where?: FabricWhereInput
  }

  export type FabricUpdateToOneWithWhereWithoutFabricOrdersInput = {
    where?: FabricWhereInput
    data: XOR<FabricUpdateWithoutFabricOrdersInput, FabricUncheckedUpdateWithoutFabricOrdersInput>
  }

  export type FabricUpdateWithoutFabricOrdersInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUpdateManyWithoutFabricNestedInput
    liningItems?: ItemsUpdateManyWithoutLining_fabricNestedInput
  }

  export type FabricUncheckedUpdateWithoutFabricOrdersInput = {
    fabric_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutFabricNestedInput
    liningItems?: ItemsUncheckedUpdateManyWithoutLining_fabricNestedInput
  }

  export type SupplierUpsertWithoutFabricOrderListInput = {
    update: XOR<SupplierUpdateWithoutFabricOrderListInput, SupplierUncheckedUpdateWithoutFabricOrderListInput>
    create: XOR<SupplierCreateWithoutFabricOrderListInput, SupplierUncheckedCreateWithoutFabricOrderListInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutFabricOrderListInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutFabricOrderListInput, SupplierUncheckedUpdateWithoutFabricOrderListInput>
  }

  export type SupplierUpdateWithoutFabricOrderListInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    RawMaterialsOrderList?: RawMaterialsOrderListUpdateManyWithoutSupplierNestedInput
    ItemSupplier?: ItemSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutFabricOrderListInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    RawMaterialsOrderList?: RawMaterialsOrderListUncheckedUpdateManyWithoutSupplierNestedInput
    ItemSupplier?: ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerCreateWithoutMeasurementsInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutMeasurementsInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutMeasurementsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutMeasurementsInput, CustomerUncheckedCreateWithoutMeasurementsInput>
  }

  export type OrdersCreateWithoutFinalJacketMeasurementInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutFinalJacketMeasurementInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutFinalJacketMeasurementInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutFinalJacketMeasurementInput, OrdersUncheckedCreateWithoutFinalJacketMeasurementInput>
  }

  export type ItemsCreateWithoutFinal_jacket_measurementInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutFinal_jacket_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutFinal_jacket_measurementInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutFinal_jacket_measurementInput, ItemsUncheckedCreateWithoutFinal_jacket_measurementInput>
  }

  export type ItemsCreateManyFinal_jacket_measurementInputEnvelope = {
    data: ItemsCreateManyFinal_jacket_measurementInput | ItemsCreateManyFinal_jacket_measurementInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutMeasurementsInput = {
    update: XOR<CustomerUpdateWithoutMeasurementsInput, CustomerUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<CustomerCreateWithoutMeasurementsInput, CustomerUncheckedCreateWithoutMeasurementsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutMeasurementsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutMeasurementsInput, CustomerUncheckedUpdateWithoutMeasurementsInput>
  }

  export type CustomerUpdateWithoutMeasurementsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutMeasurementsInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrdersUpsertWithoutFinalJacketMeasurementInput = {
    update: XOR<OrdersUpdateWithoutFinalJacketMeasurementInput, OrdersUncheckedUpdateWithoutFinalJacketMeasurementInput>
    create: XOR<OrdersCreateWithoutFinalJacketMeasurementInput, OrdersUncheckedCreateWithoutFinalJacketMeasurementInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutFinalJacketMeasurementInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutFinalJacketMeasurementInput, OrdersUncheckedUpdateWithoutFinalJacketMeasurementInput>
  }

  export type OrdersUpdateWithoutFinalJacketMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutFinalJacketMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutFinal_jacket_measurementInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutFinal_jacket_measurementInput, ItemsUncheckedUpdateWithoutFinal_jacket_measurementInput>
    create: XOR<ItemsCreateWithoutFinal_jacket_measurementInput, ItemsUncheckedCreateWithoutFinal_jacket_measurementInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutFinal_jacket_measurementInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutFinal_jacket_measurementInput, ItemsUncheckedUpdateWithoutFinal_jacket_measurementInput>
  }

  export type ItemsUpdateManyWithWhereWithoutFinal_jacket_measurementInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutFinal_jacket_measurementInput>
  }

  export type CustomerCreateWithoutJacketMeasurementInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutJacketMeasurementInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutJacketMeasurementInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutJacketMeasurementInput, CustomerUncheckedCreateWithoutJacketMeasurementInput>
  }

  export type OrdersCreateWithoutJacketMeasurementInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutJacketMeasurementInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutJacketMeasurementInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutJacketMeasurementInput, OrdersUncheckedCreateWithoutJacketMeasurementInput>
  }

  export type ItemsCreateWithoutJacket_measurementInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutJacket_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutJacket_measurementInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutJacket_measurementInput, ItemsUncheckedCreateWithoutJacket_measurementInput>
  }

  export type ItemsCreateManyJacket_measurementInputEnvelope = {
    data: ItemsCreateManyJacket_measurementInput | ItemsCreateManyJacket_measurementInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutJacketMeasurementInput = {
    update: XOR<CustomerUpdateWithoutJacketMeasurementInput, CustomerUncheckedUpdateWithoutJacketMeasurementInput>
    create: XOR<CustomerCreateWithoutJacketMeasurementInput, CustomerUncheckedCreateWithoutJacketMeasurementInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutJacketMeasurementInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutJacketMeasurementInput, CustomerUncheckedUpdateWithoutJacketMeasurementInput>
  }

  export type CustomerUpdateWithoutJacketMeasurementInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutJacketMeasurementInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrdersUpsertWithoutJacketMeasurementInput = {
    update: XOR<OrdersUpdateWithoutJacketMeasurementInput, OrdersUncheckedUpdateWithoutJacketMeasurementInput>
    create: XOR<OrdersCreateWithoutJacketMeasurementInput, OrdersUncheckedCreateWithoutJacketMeasurementInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutJacketMeasurementInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutJacketMeasurementInput, OrdersUncheckedUpdateWithoutJacketMeasurementInput>
  }

  export type OrdersUpdateWithoutJacketMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutJacketMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutJacket_measurementInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutJacket_measurementInput, ItemsUncheckedUpdateWithoutJacket_measurementInput>
    create: XOR<ItemsCreateWithoutJacket_measurementInput, ItemsUncheckedCreateWithoutJacket_measurementInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutJacket_measurementInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutJacket_measurementInput, ItemsUncheckedUpdateWithoutJacket_measurementInput>
  }

  export type ItemsUpdateManyWithWhereWithoutJacket_measurementInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutJacket_measurementInput>
  }

  export type CustomerCreateWithoutFinalPantMeasurementInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutFinalPantMeasurementInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutFinalPantMeasurementInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutFinalPantMeasurementInput, CustomerUncheckedCreateWithoutFinalPantMeasurementInput>
  }

  export type OrdersCreateWithoutFinalPantMeasurementInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutFinalPantMeasurementInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutFinalPantMeasurementInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutFinalPantMeasurementInput, OrdersUncheckedCreateWithoutFinalPantMeasurementInput>
  }

  export type ItemsCreateWithoutFinal_pant_measurementInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutFinal_pant_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutFinal_pant_measurementInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutFinal_pant_measurementInput, ItemsUncheckedCreateWithoutFinal_pant_measurementInput>
  }

  export type ItemsCreateManyFinal_pant_measurementInputEnvelope = {
    data: ItemsCreateManyFinal_pant_measurementInput | ItemsCreateManyFinal_pant_measurementInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutFinalPantMeasurementInput = {
    update: XOR<CustomerUpdateWithoutFinalPantMeasurementInput, CustomerUncheckedUpdateWithoutFinalPantMeasurementInput>
    create: XOR<CustomerCreateWithoutFinalPantMeasurementInput, CustomerUncheckedCreateWithoutFinalPantMeasurementInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutFinalPantMeasurementInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutFinalPantMeasurementInput, CustomerUncheckedUpdateWithoutFinalPantMeasurementInput>
  }

  export type CustomerUpdateWithoutFinalPantMeasurementInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutFinalPantMeasurementInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrdersUpsertWithoutFinalPantMeasurementInput = {
    update: XOR<OrdersUpdateWithoutFinalPantMeasurementInput, OrdersUncheckedUpdateWithoutFinalPantMeasurementInput>
    create: XOR<OrdersCreateWithoutFinalPantMeasurementInput, OrdersUncheckedCreateWithoutFinalPantMeasurementInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutFinalPantMeasurementInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutFinalPantMeasurementInput, OrdersUncheckedUpdateWithoutFinalPantMeasurementInput>
  }

  export type OrdersUpdateWithoutFinalPantMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutFinalPantMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutFinal_pant_measurementInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutFinal_pant_measurementInput, ItemsUncheckedUpdateWithoutFinal_pant_measurementInput>
    create: XOR<ItemsCreateWithoutFinal_pant_measurementInput, ItemsUncheckedCreateWithoutFinal_pant_measurementInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutFinal_pant_measurementInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutFinal_pant_measurementInput, ItemsUncheckedUpdateWithoutFinal_pant_measurementInput>
  }

  export type ItemsUpdateManyWithWhereWithoutFinal_pant_measurementInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutFinal_pant_measurementInput>
  }

  export type CustomerCreateWithoutPantMeasurementInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPantMeasurementInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPantMeasurementInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPantMeasurementInput, CustomerUncheckedCreateWithoutPantMeasurementInput>
  }

  export type OrdersCreateWithoutPantMeasurementInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutPantMeasurementInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutPantMeasurementInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutPantMeasurementInput, OrdersUncheckedCreateWithoutPantMeasurementInput>
  }

  export type ItemsCreateWithoutPant_measurementInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutPant_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutPant_measurementInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutPant_measurementInput, ItemsUncheckedCreateWithoutPant_measurementInput>
  }

  export type ItemsCreateManyPant_measurementInputEnvelope = {
    data: ItemsCreateManyPant_measurementInput | ItemsCreateManyPant_measurementInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutPantMeasurementInput = {
    update: XOR<CustomerUpdateWithoutPantMeasurementInput, CustomerUncheckedUpdateWithoutPantMeasurementInput>
    create: XOR<CustomerCreateWithoutPantMeasurementInput, CustomerUncheckedCreateWithoutPantMeasurementInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPantMeasurementInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPantMeasurementInput, CustomerUncheckedUpdateWithoutPantMeasurementInput>
  }

  export type CustomerUpdateWithoutPantMeasurementInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPantMeasurementInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrdersUpsertWithoutPantMeasurementInput = {
    update: XOR<OrdersUpdateWithoutPantMeasurementInput, OrdersUncheckedUpdateWithoutPantMeasurementInput>
    create: XOR<OrdersCreateWithoutPantMeasurementInput, OrdersUncheckedCreateWithoutPantMeasurementInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutPantMeasurementInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutPantMeasurementInput, OrdersUncheckedUpdateWithoutPantMeasurementInput>
  }

  export type OrdersUpdateWithoutPantMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutPantMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutPant_measurementInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutPant_measurementInput, ItemsUncheckedUpdateWithoutPant_measurementInput>
    create: XOR<ItemsCreateWithoutPant_measurementInput, ItemsUncheckedCreateWithoutPant_measurementInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutPant_measurementInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutPant_measurementInput, ItemsUncheckedUpdateWithoutPant_measurementInput>
  }

  export type ItemsUpdateManyWithWhereWithoutPant_measurementInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutPant_measurementInput>
  }

  export type CustomerCreateWithoutFinalShirtMeasurementInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutFinalShirtMeasurementInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutFinalShirtMeasurementInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutFinalShirtMeasurementInput, CustomerUncheckedCreateWithoutFinalShirtMeasurementInput>
  }

  export type OrdersCreateWithoutFinalShirtMeasurementInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutFinalShirtMeasurementInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutFinalShirtMeasurementInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutFinalShirtMeasurementInput, OrdersUncheckedCreateWithoutFinalShirtMeasurementInput>
  }

  export type ItemsCreateWithoutFinal_shirt_measurementInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutFinal_shirt_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutFinal_shirt_measurementInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutFinal_shirt_measurementInput, ItemsUncheckedCreateWithoutFinal_shirt_measurementInput>
  }

  export type ItemsCreateManyFinal_shirt_measurementInputEnvelope = {
    data: ItemsCreateManyFinal_shirt_measurementInput | ItemsCreateManyFinal_shirt_measurementInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutFinalShirtMeasurementInput = {
    update: XOR<CustomerUpdateWithoutFinalShirtMeasurementInput, CustomerUncheckedUpdateWithoutFinalShirtMeasurementInput>
    create: XOR<CustomerCreateWithoutFinalShirtMeasurementInput, CustomerUncheckedCreateWithoutFinalShirtMeasurementInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutFinalShirtMeasurementInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutFinalShirtMeasurementInput, CustomerUncheckedUpdateWithoutFinalShirtMeasurementInput>
  }

  export type CustomerUpdateWithoutFinalShirtMeasurementInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutFinalShirtMeasurementInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrdersUpsertWithoutFinalShirtMeasurementInput = {
    update: XOR<OrdersUpdateWithoutFinalShirtMeasurementInput, OrdersUncheckedUpdateWithoutFinalShirtMeasurementInput>
    create: XOR<OrdersCreateWithoutFinalShirtMeasurementInput, OrdersUncheckedCreateWithoutFinalShirtMeasurementInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutFinalShirtMeasurementInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutFinalShirtMeasurementInput, OrdersUncheckedUpdateWithoutFinalShirtMeasurementInput>
  }

  export type OrdersUpdateWithoutFinalShirtMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutFinalShirtMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutFinal_shirt_measurementInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutFinal_shirt_measurementInput, ItemsUncheckedUpdateWithoutFinal_shirt_measurementInput>
    create: XOR<ItemsCreateWithoutFinal_shirt_measurementInput, ItemsUncheckedCreateWithoutFinal_shirt_measurementInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutFinal_shirt_measurementInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutFinal_shirt_measurementInput, ItemsUncheckedUpdateWithoutFinal_shirt_measurementInput>
  }

  export type ItemsUpdateManyWithWhereWithoutFinal_shirt_measurementInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutFinal_shirt_measurementInput>
  }

  export type CustomerCreateWithoutShirtMeasurementInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutShirtMeasurementInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomerInput
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutShirtMeasurementInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutShirtMeasurementInput, CustomerUncheckedCreateWithoutShirtMeasurementInput>
  }

  export type OrdersCreateWithoutShirtMeasurementInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutShirtMeasurementInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutShirtMeasurementInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutShirtMeasurementInput, OrdersUncheckedCreateWithoutShirtMeasurementInput>
  }

  export type ItemsCreateWithoutShirt_measurementInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    order?: OrdersCreateNestedOneWithoutItemsInput
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutShirt_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutShirt_measurementInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutShirt_measurementInput, ItemsUncheckedCreateWithoutShirt_measurementInput>
  }

  export type ItemsCreateManyShirt_measurementInputEnvelope = {
    data: ItemsCreateManyShirt_measurementInput | ItemsCreateManyShirt_measurementInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutShirtMeasurementInput = {
    update: XOR<CustomerUpdateWithoutShirtMeasurementInput, CustomerUncheckedUpdateWithoutShirtMeasurementInput>
    create: XOR<CustomerCreateWithoutShirtMeasurementInput, CustomerUncheckedCreateWithoutShirtMeasurementInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutShirtMeasurementInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutShirtMeasurementInput, CustomerUncheckedUpdateWithoutShirtMeasurementInput>
  }

  export type CustomerUpdateWithoutShirtMeasurementInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutShirtMeasurementInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrdersUncheckedUpdateManyWithoutCustomerNestedInput
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrdersUpsertWithoutShirtMeasurementInput = {
    update: XOR<OrdersUpdateWithoutShirtMeasurementInput, OrdersUncheckedUpdateWithoutShirtMeasurementInput>
    create: XOR<OrdersCreateWithoutShirtMeasurementInput, OrdersUncheckedCreateWithoutShirtMeasurementInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutShirtMeasurementInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutShirtMeasurementInput, OrdersUncheckedUpdateWithoutShirtMeasurementInput>
  }

  export type OrdersUpdateWithoutShirtMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutShirtMeasurementInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutShirt_measurementInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutShirt_measurementInput, ItemsUncheckedUpdateWithoutShirt_measurementInput>
    create: XOR<ItemsCreateWithoutShirt_measurementInput, ItemsUncheckedCreateWithoutShirt_measurementInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutShirt_measurementInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutShirt_measurementInput, ItemsUncheckedUpdateWithoutShirt_measurementInput>
  }

  export type ItemsUpdateManyWithWhereWithoutShirt_measurementInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutShirt_measurementInput>
  }

  export type OrdersCreateWithoutOrderPhotosInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutOrderPhotosInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutOrderPhotosInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrderPhotosInput, OrdersUncheckedCreateWithoutOrderPhotosInput>
  }

  export type OrdersUpsertWithoutOrderPhotosInput = {
    update: XOR<OrdersUpdateWithoutOrderPhotosInput, OrdersUncheckedUpdateWithoutOrderPhotosInput>
    create: XOR<OrdersCreateWithoutOrderPhotosInput, OrdersUncheckedCreateWithoutOrderPhotosInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutOrderPhotosInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutOrderPhotosInput, OrdersUncheckedUpdateWithoutOrderPhotosInput>
  }

  export type OrdersUpdateWithoutOrderPhotosInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrderPhotosInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type CustomerCreateWithoutOrdersInput = {
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    measurements?: FinalJacketMeasurementCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    customer_id?: number
    first_name?: string | null
    middle_name?: string | null
    last_name?: string | null
    add1?: string | null
    add2?: string | null
    add3?: string | null
    add4?: string | null
    email?: string | null
    mobile?: string | null
    office_phone?: string | null
    residential_phone?: string | null
    last_ordered_date?: Date | string | null
    measurements?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutCustomerInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type ItemsCreateWithoutOrderInput = {
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric?: FabricCreateNestedOneWithoutItemsInput
    lining_fabric?: FabricCreateNestedOneWithoutLiningItemsInput
    jacket_measurement?: JacketMeasurementCreateNestedOneWithoutItemsInput
    shirt_measurement?: ShirtMeasurementCreateNestedOneWithoutItemsInput
    pant_measurement?: PantMeasurementCreateNestedOneWithoutItemsInput
    final_jacket_measurement?: FinalJacketMeasurementCreateNestedOneWithoutItemsInput
    final_shirt_measurement?: FinalShirtMeasurementCreateNestedOneWithoutItemsInput
    final_pant_measurement?: FinalPantMeasurementCreateNestedOneWithoutItemsInput
  }

  export type ItemsUncheckedCreateWithoutOrderInput = {
    item_id?: number
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateOrConnectWithoutOrderInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutOrderInput, ItemsUncheckedCreateWithoutOrderInput>
  }

  export type ItemsCreateManyOrderInputEnvelope = {
    data: ItemsCreateManyOrderInput | ItemsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type FinalJacketMeasurementCreateWithoutOrderInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutMeasurementsInput
    Items?: ItemsCreateNestedManyWithoutFinal_jacket_measurementInput
  }

  export type FinalJacketMeasurementUncheckedCreateWithoutOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_jacket_measurementInput
  }

  export type FinalJacketMeasurementCreateOrConnectWithoutOrderInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    create: XOR<FinalJacketMeasurementCreateWithoutOrderInput, FinalJacketMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type FinalJacketMeasurementCreateManyOrderInputEnvelope = {
    data: FinalJacketMeasurementCreateManyOrderInput | FinalJacketMeasurementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type FinalPantMeasurementCreateWithoutOrderInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutFinalPantMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_pant_measurementInput
  }

  export type FinalPantMeasurementUncheckedCreateWithoutOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_pant_measurementInput
  }

  export type FinalPantMeasurementCreateOrConnectWithoutOrderInput = {
    where: FinalPantMeasurementWhereUniqueInput
    create: XOR<FinalPantMeasurementCreateWithoutOrderInput, FinalPantMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type FinalPantMeasurementCreateManyOrderInputEnvelope = {
    data: FinalPantMeasurementCreateManyOrderInput | FinalPantMeasurementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type FinalShirtMeasurementCreateWithoutOrderInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutFinalShirtMeasurementInput
    Items?: ItemsCreateNestedManyWithoutFinal_shirt_measurementInput
  }

  export type FinalShirtMeasurementUncheckedCreateWithoutOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutFinal_shirt_measurementInput
  }

  export type FinalShirtMeasurementCreateOrConnectWithoutOrderInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    create: XOR<FinalShirtMeasurementCreateWithoutOrderInput, FinalShirtMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type FinalShirtMeasurementCreateManyOrderInputEnvelope = {
    data: FinalShirtMeasurementCreateManyOrderInput | FinalShirtMeasurementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type JacketMeasurementCreateWithoutOrderInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutJacketMeasurementInput
    Items?: ItemsCreateNestedManyWithoutJacket_measurementInput
  }

  export type JacketMeasurementUncheckedCreateWithoutOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutJacket_measurementInput
  }

  export type JacketMeasurementCreateOrConnectWithoutOrderInput = {
    where: JacketMeasurementWhereUniqueInput
    create: XOR<JacketMeasurementCreateWithoutOrderInput, JacketMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type JacketMeasurementCreateManyOrderInputEnvelope = {
    data: JacketMeasurementCreateManyOrderInput | JacketMeasurementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PantMeasurementCreateWithoutOrderInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutPantMeasurementInput
    Items?: ItemsCreateNestedManyWithoutPant_measurementInput
  }

  export type PantMeasurementUncheckedCreateWithoutOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutPant_measurementInput
  }

  export type PantMeasurementCreateOrConnectWithoutOrderInput = {
    where: PantMeasurementWhereUniqueInput
    create: XOR<PantMeasurementCreateWithoutOrderInput, PantMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type PantMeasurementCreateManyOrderInputEnvelope = {
    data: PantMeasurementCreateManyOrderInput | PantMeasurementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ShirtMeasurementCreateWithoutOrderInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutShirtMeasurementInput
    Items?: ItemsCreateNestedManyWithoutShirt_measurementInput
  }

  export type ShirtMeasurementUncheckedCreateWithoutOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    Items?: ItemsUncheckedCreateNestedManyWithoutShirt_measurementInput
  }

  export type ShirtMeasurementCreateOrConnectWithoutOrderInput = {
    where: ShirtMeasurementWhereUniqueInput
    create: XOR<ShirtMeasurementCreateWithoutOrderInput, ShirtMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type ShirtMeasurementCreateManyOrderInputEnvelope = {
    data: ShirtMeasurementCreateManyOrderInput | ShirtMeasurementCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderPhotosCreateWithoutOrderInput = {
    s3_key?: string | null
    uploaded_at?: Date | string
  }

  export type OrderPhotosUncheckedCreateWithoutOrderInput = {
    photo_id?: number
    s3_key?: string | null
    uploaded_at?: Date | string
  }

  export type OrderPhotosCreateOrConnectWithoutOrderInput = {
    where: OrderPhotosWhereUniqueInput
    create: XOR<OrderPhotosCreateWithoutOrderInput, OrderPhotosUncheckedCreateWithoutOrderInput>
  }

  export type OrderPhotosCreateManyOrderInputEnvelope = {
    data: OrderPhotosCreateManyOrderInput | OrderPhotosCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderTailorCreateWithoutOrderInput = {
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
    tailor: TailorCreateNestedOneWithoutOrdersInput
  }

  export type OrderTailorUncheckedCreateWithoutOrderInput = {
    id?: number
    tailor_id: number
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
  }

  export type OrderTailorCreateOrConnectWithoutOrderInput = {
    where: OrderTailorWhereUniqueInput
    create: XOR<OrderTailorCreateWithoutOrderInput, OrderTailorUncheckedCreateWithoutOrderInput>
  }

  export type OrderTailorCreateManyOrderInputEnvelope = {
    data: OrderTailorCreateManyOrderInput | OrderTailorCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderProductionCreateWithoutOrderInput = {
    status?: $Enums.ProductionStatus
    updatedAt?: Date | string
    notes?: string | null
  }

  export type OrderProductionUncheckedCreateWithoutOrderInput = {
    id?: number
    status?: $Enums.ProductionStatus
    updatedAt?: Date | string
    notes?: string | null
  }

  export type OrderProductionCreateOrConnectWithoutOrderInput = {
    where: OrderProductionWhereUniqueInput
    create: XOR<OrderProductionCreateWithoutOrderInput, OrderProductionUncheckedCreateWithoutOrderInput>
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurements?: FinalJacketMeasurementUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    customer_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    add4?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    office_phone?: NullableStringFieldUpdateOperationsInput | string | null
    residential_phone?: NullableStringFieldUpdateOperationsInput | string | null
    last_ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    measurements?: FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ItemsUpsertWithWhereUniqueWithoutOrderInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutOrderInput, ItemsUncheckedUpdateWithoutOrderInput>
    create: XOR<ItemsCreateWithoutOrderInput, ItemsUncheckedCreateWithoutOrderInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutOrderInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutOrderInput, ItemsUncheckedUpdateWithoutOrderInput>
  }

  export type ItemsUpdateManyWithWhereWithoutOrderInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutOrderInput>
  }

  export type FinalJacketMeasurementUpsertWithWhereUniqueWithoutOrderInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    update: XOR<FinalJacketMeasurementUpdateWithoutOrderInput, FinalJacketMeasurementUncheckedUpdateWithoutOrderInput>
    create: XOR<FinalJacketMeasurementCreateWithoutOrderInput, FinalJacketMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type FinalJacketMeasurementUpdateWithWhereUniqueWithoutOrderInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    data: XOR<FinalJacketMeasurementUpdateWithoutOrderInput, FinalJacketMeasurementUncheckedUpdateWithoutOrderInput>
  }

  export type FinalJacketMeasurementUpdateManyWithWhereWithoutOrderInput = {
    where: FinalJacketMeasurementScalarWhereInput
    data: XOR<FinalJacketMeasurementUpdateManyMutationInput, FinalJacketMeasurementUncheckedUpdateManyWithoutOrderInput>
  }

  export type FinalPantMeasurementUpsertWithWhereUniqueWithoutOrderInput = {
    where: FinalPantMeasurementWhereUniqueInput
    update: XOR<FinalPantMeasurementUpdateWithoutOrderInput, FinalPantMeasurementUncheckedUpdateWithoutOrderInput>
    create: XOR<FinalPantMeasurementCreateWithoutOrderInput, FinalPantMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type FinalPantMeasurementUpdateWithWhereUniqueWithoutOrderInput = {
    where: FinalPantMeasurementWhereUniqueInput
    data: XOR<FinalPantMeasurementUpdateWithoutOrderInput, FinalPantMeasurementUncheckedUpdateWithoutOrderInput>
  }

  export type FinalPantMeasurementUpdateManyWithWhereWithoutOrderInput = {
    where: FinalPantMeasurementScalarWhereInput
    data: XOR<FinalPantMeasurementUpdateManyMutationInput, FinalPantMeasurementUncheckedUpdateManyWithoutOrderInput>
  }

  export type FinalShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    update: XOR<FinalShirtMeasurementUpdateWithoutOrderInput, FinalShirtMeasurementUncheckedUpdateWithoutOrderInput>
    create: XOR<FinalShirtMeasurementCreateWithoutOrderInput, FinalShirtMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type FinalShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    data: XOR<FinalShirtMeasurementUpdateWithoutOrderInput, FinalShirtMeasurementUncheckedUpdateWithoutOrderInput>
  }

  export type FinalShirtMeasurementUpdateManyWithWhereWithoutOrderInput = {
    where: FinalShirtMeasurementScalarWhereInput
    data: XOR<FinalShirtMeasurementUpdateManyMutationInput, FinalShirtMeasurementUncheckedUpdateManyWithoutOrderInput>
  }

  export type JacketMeasurementUpsertWithWhereUniqueWithoutOrderInput = {
    where: JacketMeasurementWhereUniqueInput
    update: XOR<JacketMeasurementUpdateWithoutOrderInput, JacketMeasurementUncheckedUpdateWithoutOrderInput>
    create: XOR<JacketMeasurementCreateWithoutOrderInput, JacketMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type JacketMeasurementUpdateWithWhereUniqueWithoutOrderInput = {
    where: JacketMeasurementWhereUniqueInput
    data: XOR<JacketMeasurementUpdateWithoutOrderInput, JacketMeasurementUncheckedUpdateWithoutOrderInput>
  }

  export type JacketMeasurementUpdateManyWithWhereWithoutOrderInput = {
    where: JacketMeasurementScalarWhereInput
    data: XOR<JacketMeasurementUpdateManyMutationInput, JacketMeasurementUncheckedUpdateManyWithoutOrderInput>
  }

  export type PantMeasurementUpsertWithWhereUniqueWithoutOrderInput = {
    where: PantMeasurementWhereUniqueInput
    update: XOR<PantMeasurementUpdateWithoutOrderInput, PantMeasurementUncheckedUpdateWithoutOrderInput>
    create: XOR<PantMeasurementCreateWithoutOrderInput, PantMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type PantMeasurementUpdateWithWhereUniqueWithoutOrderInput = {
    where: PantMeasurementWhereUniqueInput
    data: XOR<PantMeasurementUpdateWithoutOrderInput, PantMeasurementUncheckedUpdateWithoutOrderInput>
  }

  export type PantMeasurementUpdateManyWithWhereWithoutOrderInput = {
    where: PantMeasurementScalarWhereInput
    data: XOR<PantMeasurementUpdateManyMutationInput, PantMeasurementUncheckedUpdateManyWithoutOrderInput>
  }

  export type ShirtMeasurementUpsertWithWhereUniqueWithoutOrderInput = {
    where: ShirtMeasurementWhereUniqueInput
    update: XOR<ShirtMeasurementUpdateWithoutOrderInput, ShirtMeasurementUncheckedUpdateWithoutOrderInput>
    create: XOR<ShirtMeasurementCreateWithoutOrderInput, ShirtMeasurementUncheckedCreateWithoutOrderInput>
  }

  export type ShirtMeasurementUpdateWithWhereUniqueWithoutOrderInput = {
    where: ShirtMeasurementWhereUniqueInput
    data: XOR<ShirtMeasurementUpdateWithoutOrderInput, ShirtMeasurementUncheckedUpdateWithoutOrderInput>
  }

  export type ShirtMeasurementUpdateManyWithWhereWithoutOrderInput = {
    where: ShirtMeasurementScalarWhereInput
    data: XOR<ShirtMeasurementUpdateManyMutationInput, ShirtMeasurementUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderPhotosUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderPhotosWhereUniqueInput
    update: XOR<OrderPhotosUpdateWithoutOrderInput, OrderPhotosUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderPhotosCreateWithoutOrderInput, OrderPhotosUncheckedCreateWithoutOrderInput>
  }

  export type OrderPhotosUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderPhotosWhereUniqueInput
    data: XOR<OrderPhotosUpdateWithoutOrderInput, OrderPhotosUncheckedUpdateWithoutOrderInput>
  }

  export type OrderPhotosUpdateManyWithWhereWithoutOrderInput = {
    where: OrderPhotosScalarWhereInput
    data: XOR<OrderPhotosUpdateManyMutationInput, OrderPhotosUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderPhotosScalarWhereInput = {
    AND?: OrderPhotosScalarWhereInput | OrderPhotosScalarWhereInput[]
    OR?: OrderPhotosScalarWhereInput[]
    NOT?: OrderPhotosScalarWhereInput | OrderPhotosScalarWhereInput[]
    photo_id?: IntFilter<"OrderPhotos"> | number
    orderNo?: StringNullableFilter<"OrderPhotos"> | string | null
    s3_key?: StringNullableFilter<"OrderPhotos"> | string | null
    uploaded_at?: DateTimeFilter<"OrderPhotos"> | Date | string
  }

  export type OrderTailorUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderTailorWhereUniqueInput
    update: XOR<OrderTailorUpdateWithoutOrderInput, OrderTailorUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderTailorCreateWithoutOrderInput, OrderTailorUncheckedCreateWithoutOrderInput>
  }

  export type OrderTailorUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderTailorWhereUniqueInput
    data: XOR<OrderTailorUpdateWithoutOrderInput, OrderTailorUncheckedUpdateWithoutOrderInput>
  }

  export type OrderTailorUpdateManyWithWhereWithoutOrderInput = {
    where: OrderTailorScalarWhereInput
    data: XOR<OrderTailorUpdateManyMutationInput, OrderTailorUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderTailorScalarWhereInput = {
    AND?: OrderTailorScalarWhereInput | OrderTailorScalarWhereInput[]
    OR?: OrderTailorScalarWhereInput[]
    NOT?: OrderTailorScalarWhereInput | OrderTailorScalarWhereInput[]
    id?: IntFilter<"OrderTailor"> | number
    orderNo?: StringFilter<"OrderTailor"> | string
    tailor_id?: IntFilter<"OrderTailor"> | number
    assigned_at?: DateTimeFilter<"OrderTailor"> | Date | string
    status?: StringFilter<"OrderTailor"> | string
    due_date?: DateTimeNullableFilter<"OrderTailor"> | Date | string | null
    notes?: StringNullableFilter<"OrderTailor"> | string | null
  }

  export type OrderProductionUpsertWithoutOrderInput = {
    update: XOR<OrderProductionUpdateWithoutOrderInput, OrderProductionUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderProductionCreateWithoutOrderInput, OrderProductionUncheckedCreateWithoutOrderInput>
    where?: OrderProductionWhereInput
  }

  export type OrderProductionUpdateToOneWithWhereWithoutOrderInput = {
    where?: OrderProductionWhereInput
    data: XOR<OrderProductionUpdateWithoutOrderInput, OrderProductionUncheckedUpdateWithoutOrderInput>
  }

  export type OrderProductionUpdateWithoutOrderInput = {
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderProductionUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrdersCreateWithoutItemsInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutItemsInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutItemsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutItemsInput, OrdersUncheckedCreateWithoutItemsInput>
  }

  export type FabricCreateWithoutItemsInput = {
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    fabricOrders?: FabricOrderListCreateNestedManyWithoutFabricInput
    liningItems?: ItemsCreateNestedManyWithoutLining_fabricInput
  }

  export type FabricUncheckedCreateWithoutItemsInput = {
    fabric_id?: number
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    fabricOrders?: FabricOrderListUncheckedCreateNestedManyWithoutFabricInput
    liningItems?: ItemsUncheckedCreateNestedManyWithoutLining_fabricInput
  }

  export type FabricCreateOrConnectWithoutItemsInput = {
    where: FabricWhereUniqueInput
    create: XOR<FabricCreateWithoutItemsInput, FabricUncheckedCreateWithoutItemsInput>
  }

  export type FabricCreateWithoutLiningItemsInput = {
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    fabricOrders?: FabricOrderListCreateNestedManyWithoutFabricInput
    items?: ItemsCreateNestedManyWithoutFabricInput
  }

  export type FabricUncheckedCreateWithoutLiningItemsInput = {
    fabric_id?: number
    description?: string | null
    available_length?: Decimal | DecimalJsLike | number | string | null
    fabric_code?: string | null
    fabric_brand?: string | null
    stock_location?: string | null
    image?: string | null
    barcode?: string | null
    fabricOrders?: FabricOrderListUncheckedCreateNestedManyWithoutFabricInput
    items?: ItemsUncheckedCreateNestedManyWithoutFabricInput
  }

  export type FabricCreateOrConnectWithoutLiningItemsInput = {
    where: FabricWhereUniqueInput
    create: XOR<FabricCreateWithoutLiningItemsInput, FabricUncheckedCreateWithoutLiningItemsInput>
  }

  export type JacketMeasurementCreateWithoutItemsInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutJacketMeasurementInput
    order?: OrdersCreateNestedOneWithoutJacketMeasurementInput
  }

  export type JacketMeasurementUncheckedCreateWithoutItemsInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type JacketMeasurementCreateOrConnectWithoutItemsInput = {
    where: JacketMeasurementWhereUniqueInput
    create: XOR<JacketMeasurementCreateWithoutItemsInput, JacketMeasurementUncheckedCreateWithoutItemsInput>
  }

  export type ShirtMeasurementCreateWithoutItemsInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutShirtMeasurementInput
    order?: OrdersCreateNestedOneWithoutShirtMeasurementInput
  }

  export type ShirtMeasurementUncheckedCreateWithoutItemsInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type ShirtMeasurementCreateOrConnectWithoutItemsInput = {
    where: ShirtMeasurementWhereUniqueInput
    create: XOR<ShirtMeasurementCreateWithoutItemsInput, ShirtMeasurementUncheckedCreateWithoutItemsInput>
  }

  export type PantMeasurementCreateWithoutItemsInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutPantMeasurementInput
    order?: OrdersCreateNestedOneWithoutPantMeasurementInput
  }

  export type PantMeasurementUncheckedCreateWithoutItemsInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type PantMeasurementCreateOrConnectWithoutItemsInput = {
    where: PantMeasurementWhereUniqueInput
    create: XOR<PantMeasurementCreateWithoutItemsInput, PantMeasurementUncheckedCreateWithoutItemsInput>
  }

  export type FinalJacketMeasurementCreateWithoutItemsInput = {
    measurement_id?: string
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutMeasurementsInput
    order?: OrdersCreateNestedOneWithoutFinalJacketMeasurementInput
  }

  export type FinalJacketMeasurementUncheckedCreateWithoutItemsInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type FinalJacketMeasurementCreateOrConnectWithoutItemsInput = {
    where: FinalJacketMeasurementWhereUniqueInput
    create: XOR<FinalJacketMeasurementCreateWithoutItemsInput, FinalJacketMeasurementUncheckedCreateWithoutItemsInput>
  }

  export type FinalShirtMeasurementCreateWithoutItemsInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutFinalShirtMeasurementInput
    order?: OrdersCreateNestedOneWithoutFinalShirtMeasurementInput
  }

  export type FinalShirtMeasurementUncheckedCreateWithoutItemsInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type FinalShirtMeasurementCreateOrConnectWithoutItemsInput = {
    where: FinalShirtMeasurementWhereUniqueInput
    create: XOR<FinalShirtMeasurementCreateWithoutItemsInput, FinalShirtMeasurementUncheckedCreateWithoutItemsInput>
  }

  export type FinalPantMeasurementCreateWithoutItemsInput = {
    measurement_id?: string
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
    customer?: CustomerCreateNestedOneWithoutFinalPantMeasurementInput
    order?: OrdersCreateNestedOneWithoutFinalPantMeasurementInput
  }

  export type FinalPantMeasurementUncheckedCreateWithoutItemsInput = {
    measurement_id?: string
    customer_id?: number | null
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type FinalPantMeasurementCreateOrConnectWithoutItemsInput = {
    where: FinalPantMeasurementWhereUniqueInput
    create: XOR<FinalPantMeasurementCreateWithoutItemsInput, FinalPantMeasurementUncheckedCreateWithoutItemsInput>
  }

  export type OrdersUpsertWithoutItemsInput = {
    update: XOR<OrdersUpdateWithoutItemsInput, OrdersUncheckedUpdateWithoutItemsInput>
    create: XOR<OrdersCreateWithoutItemsInput, OrdersUncheckedCreateWithoutItemsInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutItemsInput, OrdersUncheckedUpdateWithoutItemsInput>
  }

  export type OrdersUpdateWithoutItemsInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutItemsInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type FabricUpsertWithoutItemsInput = {
    update: XOR<FabricUpdateWithoutItemsInput, FabricUncheckedUpdateWithoutItemsInput>
    create: XOR<FabricCreateWithoutItemsInput, FabricUncheckedCreateWithoutItemsInput>
    where?: FabricWhereInput
  }

  export type FabricUpdateToOneWithWhereWithoutItemsInput = {
    where?: FabricWhereInput
    data: XOR<FabricUpdateWithoutItemsInput, FabricUncheckedUpdateWithoutItemsInput>
  }

  export type FabricUpdateWithoutItemsInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricOrders?: FabricOrderListUpdateManyWithoutFabricNestedInput
    liningItems?: ItemsUpdateManyWithoutLining_fabricNestedInput
  }

  export type FabricUncheckedUpdateWithoutItemsInput = {
    fabric_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricOrders?: FabricOrderListUncheckedUpdateManyWithoutFabricNestedInput
    liningItems?: ItemsUncheckedUpdateManyWithoutLining_fabricNestedInput
  }

  export type FabricUpsertWithoutLiningItemsInput = {
    update: XOR<FabricUpdateWithoutLiningItemsInput, FabricUncheckedUpdateWithoutLiningItemsInput>
    create: XOR<FabricCreateWithoutLiningItemsInput, FabricUncheckedCreateWithoutLiningItemsInput>
    where?: FabricWhereInput
  }

  export type FabricUpdateToOneWithWhereWithoutLiningItemsInput = {
    where?: FabricWhereInput
    data: XOR<FabricUpdateWithoutLiningItemsInput, FabricUncheckedUpdateWithoutLiningItemsInput>
  }

  export type FabricUpdateWithoutLiningItemsInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricOrders?: FabricOrderListUpdateManyWithoutFabricNestedInput
    items?: ItemsUpdateManyWithoutFabricNestedInput
  }

  export type FabricUncheckedUpdateWithoutLiningItemsInput = {
    fabric_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    available_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fabric_code?: NullableStringFieldUpdateOperationsInput | string | null
    fabric_brand?: NullableStringFieldUpdateOperationsInput | string | null
    stock_location?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricOrders?: FabricOrderListUncheckedUpdateManyWithoutFabricNestedInput
    items?: ItemsUncheckedUpdateManyWithoutFabricNestedInput
  }

  export type JacketMeasurementUpsertWithoutItemsInput = {
    update: XOR<JacketMeasurementUpdateWithoutItemsInput, JacketMeasurementUncheckedUpdateWithoutItemsInput>
    create: XOR<JacketMeasurementCreateWithoutItemsInput, JacketMeasurementUncheckedCreateWithoutItemsInput>
    where?: JacketMeasurementWhereInput
  }

  export type JacketMeasurementUpdateToOneWithWhereWithoutItemsInput = {
    where?: JacketMeasurementWhereInput
    data: XOR<JacketMeasurementUpdateWithoutItemsInput, JacketMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type JacketMeasurementUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutJacketMeasurementNestedInput
    order?: OrdersUpdateOneWithoutJacketMeasurementNestedInput
  }

  export type JacketMeasurementUncheckedUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShirtMeasurementUpsertWithoutItemsInput = {
    update: XOR<ShirtMeasurementUpdateWithoutItemsInput, ShirtMeasurementUncheckedUpdateWithoutItemsInput>
    create: XOR<ShirtMeasurementCreateWithoutItemsInput, ShirtMeasurementUncheckedCreateWithoutItemsInput>
    where?: ShirtMeasurementWhereInput
  }

  export type ShirtMeasurementUpdateToOneWithWhereWithoutItemsInput = {
    where?: ShirtMeasurementWhereInput
    data: XOR<ShirtMeasurementUpdateWithoutItemsInput, ShirtMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type ShirtMeasurementUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutShirtMeasurementNestedInput
    order?: OrdersUpdateOneWithoutShirtMeasurementNestedInput
  }

  export type ShirtMeasurementUncheckedUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PantMeasurementUpsertWithoutItemsInput = {
    update: XOR<PantMeasurementUpdateWithoutItemsInput, PantMeasurementUncheckedUpdateWithoutItemsInput>
    create: XOR<PantMeasurementCreateWithoutItemsInput, PantMeasurementUncheckedCreateWithoutItemsInput>
    where?: PantMeasurementWhereInput
  }

  export type PantMeasurementUpdateToOneWithWhereWithoutItemsInput = {
    where?: PantMeasurementWhereInput
    data: XOR<PantMeasurementUpdateWithoutItemsInput, PantMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type PantMeasurementUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPantMeasurementNestedInput
    order?: OrdersUpdateOneWithoutPantMeasurementNestedInput
  }

  export type PantMeasurementUncheckedUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalJacketMeasurementUpsertWithoutItemsInput = {
    update: XOR<FinalJacketMeasurementUpdateWithoutItemsInput, FinalJacketMeasurementUncheckedUpdateWithoutItemsInput>
    create: XOR<FinalJacketMeasurementCreateWithoutItemsInput, FinalJacketMeasurementUncheckedCreateWithoutItemsInput>
    where?: FinalJacketMeasurementWhereInput
  }

  export type FinalJacketMeasurementUpdateToOneWithWhereWithoutItemsInput = {
    where?: FinalJacketMeasurementWhereInput
    data: XOR<FinalJacketMeasurementUpdateWithoutItemsInput, FinalJacketMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FinalJacketMeasurementUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutMeasurementsNestedInput
    order?: OrdersUpdateOneWithoutFinalJacketMeasurementNestedInput
  }

  export type FinalJacketMeasurementUncheckedUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalShirtMeasurementUpsertWithoutItemsInput = {
    update: XOR<FinalShirtMeasurementUpdateWithoutItemsInput, FinalShirtMeasurementUncheckedUpdateWithoutItemsInput>
    create: XOR<FinalShirtMeasurementCreateWithoutItemsInput, FinalShirtMeasurementUncheckedCreateWithoutItemsInput>
    where?: FinalShirtMeasurementWhereInput
  }

  export type FinalShirtMeasurementUpdateToOneWithWhereWithoutItemsInput = {
    where?: FinalShirtMeasurementWhereInput
    data: XOR<FinalShirtMeasurementUpdateWithoutItemsInput, FinalShirtMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FinalShirtMeasurementUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutFinalShirtMeasurementNestedInput
    order?: OrdersUpdateOneWithoutFinalShirtMeasurementNestedInput
  }

  export type FinalShirtMeasurementUncheckedUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalPantMeasurementUpsertWithoutItemsInput = {
    update: XOR<FinalPantMeasurementUpdateWithoutItemsInput, FinalPantMeasurementUncheckedUpdateWithoutItemsInput>
    create: XOR<FinalPantMeasurementCreateWithoutItemsInput, FinalPantMeasurementUncheckedCreateWithoutItemsInput>
    where?: FinalPantMeasurementWhereInput
  }

  export type FinalPantMeasurementUpdateToOneWithWhereWithoutItemsInput = {
    where?: FinalPantMeasurementWhereInput
    data: XOR<FinalPantMeasurementUpdateWithoutItemsInput, FinalPantMeasurementUncheckedUpdateWithoutItemsInput>
  }

  export type FinalPantMeasurementUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutFinalPantMeasurementNestedInput
    order?: OrdersUpdateOneWithoutFinalPantMeasurementNestedInput
  }

  export type FinalPantMeasurementUncheckedUpdateWithoutItemsInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricOrderListCreateWithoutSupplierInput = {
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    fabric?: FabricCreateNestedOneWithoutFabricOrdersInput
  }

  export type FabricOrderListUncheckedCreateWithoutSupplierInput = {
    order_id?: number
    fabric_id?: number | null
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
  }

  export type FabricOrderListCreateOrConnectWithoutSupplierInput = {
    where: FabricOrderListWhereUniqueInput
    create: XOR<FabricOrderListCreateWithoutSupplierInput, FabricOrderListUncheckedCreateWithoutSupplierInput>
  }

  export type FabricOrderListCreateManySupplierInputEnvelope = {
    data: FabricOrderListCreateManySupplierInput | FabricOrderListCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type RawMaterialsOrderListCreateWithoutSupplierInput = {
    product_name?: string | null
    description?: string | null
    raw_material_code?: string | null
    color?: string | null
    supplier_name?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
  }

  export type RawMaterialsOrderListUncheckedCreateWithoutSupplierInput = {
    order_id?: number
    product_name?: string | null
    description?: string | null
    raw_material_code?: string | null
    color?: string | null
    supplier_name?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
  }

  export type RawMaterialsOrderListCreateOrConnectWithoutSupplierInput = {
    where: RawMaterialsOrderListWhereUniqueInput
    create: XOR<RawMaterialsOrderListCreateWithoutSupplierInput, RawMaterialsOrderListUncheckedCreateWithoutSupplierInput>
  }

  export type RawMaterialsOrderListCreateManySupplierInputEnvelope = {
    data: RawMaterialsOrderListCreateManySupplierInput | RawMaterialsOrderListCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ItemSupplierCreateWithoutSupplierInput = {
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
    item: InventoryItemCreateNestedOneWithoutSuppliersInput
  }

  export type ItemSupplierUncheckedCreateWithoutSupplierInput = {
    id?: number
    item_id: string
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
  }

  export type ItemSupplierCreateOrConnectWithoutSupplierInput = {
    where: ItemSupplierWhereUniqueInput
    create: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type ItemSupplierCreateManySupplierInputEnvelope = {
    data: ItemSupplierCreateManySupplierInput | ItemSupplierCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type FabricOrderListUpsertWithWhereUniqueWithoutSupplierInput = {
    where: FabricOrderListWhereUniqueInput
    update: XOR<FabricOrderListUpdateWithoutSupplierInput, FabricOrderListUncheckedUpdateWithoutSupplierInput>
    create: XOR<FabricOrderListCreateWithoutSupplierInput, FabricOrderListUncheckedCreateWithoutSupplierInput>
  }

  export type FabricOrderListUpdateWithWhereUniqueWithoutSupplierInput = {
    where: FabricOrderListWhereUniqueInput
    data: XOR<FabricOrderListUpdateWithoutSupplierInput, FabricOrderListUncheckedUpdateWithoutSupplierInput>
  }

  export type FabricOrderListUpdateManyWithWhereWithoutSupplierInput = {
    where: FabricOrderListScalarWhereInput
    data: XOR<FabricOrderListUpdateManyMutationInput, FabricOrderListUncheckedUpdateManyWithoutSupplierInput>
  }

  export type RawMaterialsOrderListUpsertWithWhereUniqueWithoutSupplierInput = {
    where: RawMaterialsOrderListWhereUniqueInput
    update: XOR<RawMaterialsOrderListUpdateWithoutSupplierInput, RawMaterialsOrderListUncheckedUpdateWithoutSupplierInput>
    create: XOR<RawMaterialsOrderListCreateWithoutSupplierInput, RawMaterialsOrderListUncheckedCreateWithoutSupplierInput>
  }

  export type RawMaterialsOrderListUpdateWithWhereUniqueWithoutSupplierInput = {
    where: RawMaterialsOrderListWhereUniqueInput
    data: XOR<RawMaterialsOrderListUpdateWithoutSupplierInput, RawMaterialsOrderListUncheckedUpdateWithoutSupplierInput>
  }

  export type RawMaterialsOrderListUpdateManyWithWhereWithoutSupplierInput = {
    where: RawMaterialsOrderListScalarWhereInput
    data: XOR<RawMaterialsOrderListUpdateManyMutationInput, RawMaterialsOrderListUncheckedUpdateManyWithoutSupplierInput>
  }

  export type RawMaterialsOrderListScalarWhereInput = {
    AND?: RawMaterialsOrderListScalarWhereInput | RawMaterialsOrderListScalarWhereInput[]
    OR?: RawMaterialsOrderListScalarWhereInput[]
    NOT?: RawMaterialsOrderListScalarWhereInput | RawMaterialsOrderListScalarWhereInput[]
    order_id?: IntFilter<"RawMaterialsOrderList"> | number
    product_name?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    description?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    raw_material_code?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    color?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    supplier_name?: StringNullableFilter<"RawMaterialsOrderList"> | string | null
    quantity?: DecimalNullableFilter<"RawMaterialsOrderList"> | Decimal | DecimalJsLike | number | string | null
    ordered_date?: DateTimeNullableFilter<"RawMaterialsOrderList"> | Date | string | null
    supplier_id?: IntNullableFilter<"RawMaterialsOrderList"> | number | null
  }

  export type ItemSupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ItemSupplierWhereUniqueInput
    update: XOR<ItemSupplierUpdateWithoutSupplierInput, ItemSupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<ItemSupplierCreateWithoutSupplierInput, ItemSupplierUncheckedCreateWithoutSupplierInput>
  }

  export type ItemSupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ItemSupplierWhereUniqueInput
    data: XOR<ItemSupplierUpdateWithoutSupplierInput, ItemSupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type ItemSupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: ItemSupplierScalarWhereInput
    data: XOR<ItemSupplierUpdateManyMutationInput, ItemSupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type OrderTailorCreateWithoutTailorInput = {
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
    order: OrdersCreateNestedOneWithoutTailorsInput
  }

  export type OrderTailorUncheckedCreateWithoutTailorInput = {
    id?: number
    orderNo: string
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
  }

  export type OrderTailorCreateOrConnectWithoutTailorInput = {
    where: OrderTailorWhereUniqueInput
    create: XOR<OrderTailorCreateWithoutTailorInput, OrderTailorUncheckedCreateWithoutTailorInput>
  }

  export type OrderTailorCreateManyTailorInputEnvelope = {
    data: OrderTailorCreateManyTailorInput | OrderTailorCreateManyTailorInput[]
    skipDuplicates?: boolean
  }

  export type OrderTailorUpsertWithWhereUniqueWithoutTailorInput = {
    where: OrderTailorWhereUniqueInput
    update: XOR<OrderTailorUpdateWithoutTailorInput, OrderTailorUncheckedUpdateWithoutTailorInput>
    create: XOR<OrderTailorCreateWithoutTailorInput, OrderTailorUncheckedCreateWithoutTailorInput>
  }

  export type OrderTailorUpdateWithWhereUniqueWithoutTailorInput = {
    where: OrderTailorWhereUniqueInput
    data: XOR<OrderTailorUpdateWithoutTailorInput, OrderTailorUncheckedUpdateWithoutTailorInput>
  }

  export type OrderTailorUpdateManyWithWhereWithoutTailorInput = {
    where: OrderTailorScalarWhereInput
    data: XOR<OrderTailorUpdateManyMutationInput, OrderTailorUncheckedUpdateManyWithoutTailorInput>
  }

  export type OrdersCreateWithoutTailorsInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    production?: OrderProductionCreateNestedOneWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutTailorsInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    production?: OrderProductionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutTailorsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutTailorsInput, OrdersUncheckedCreateWithoutTailorsInput>
  }

  export type TailorCreateWithoutOrdersInput = {
    first_name: string
    last_name?: string | null
    specialization?: string | null
    experience_years?: number | null
    joining_date?: Date | string
    address?: string | null
    phone_number?: string | null
    email?: string | null
    emergency_contact?: string | null
    status?: string
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type TailorUncheckedCreateWithoutOrdersInput = {
    tailor_id?: number
    first_name: string
    last_name?: string | null
    specialization?: string | null
    experience_years?: number | null
    joining_date?: Date | string
    address?: string | null
    phone_number?: string | null
    email?: string | null
    emergency_contact?: string | null
    status?: string
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
  }

  export type TailorCreateOrConnectWithoutOrdersInput = {
    where: TailorWhereUniqueInput
    create: XOR<TailorCreateWithoutOrdersInput, TailorUncheckedCreateWithoutOrdersInput>
  }

  export type OrdersUpsertWithoutTailorsInput = {
    update: XOR<OrdersUpdateWithoutTailorsInput, OrdersUncheckedUpdateWithoutTailorsInput>
    create: XOR<OrdersCreateWithoutTailorsInput, OrdersUncheckedCreateWithoutTailorsInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutTailorsInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutTailorsInput, OrdersUncheckedUpdateWithoutTailorsInput>
  }

  export type OrdersUpdateWithoutTailorsInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutTailorsInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type TailorUpsertWithoutOrdersInput = {
    update: XOR<TailorUpdateWithoutOrdersInput, TailorUncheckedUpdateWithoutOrdersInput>
    create: XOR<TailorCreateWithoutOrdersInput, TailorUncheckedCreateWithoutOrdersInput>
    where?: TailorWhereInput
  }

  export type TailorUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TailorWhereInput
    data: XOR<TailorUpdateWithoutOrdersInput, TailorUncheckedUpdateWithoutOrdersInput>
  }

  export type TailorUpdateWithoutOrdersInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TailorUncheckedUpdateWithoutOrdersInput = {
    tailor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience_years?: NullableIntFieldUpdateOperationsInput | number | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierCreateWithoutRawMaterialsOrderListInput = {
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    FabricOrderList?: FabricOrderListCreateNestedManyWithoutSupplierInput
    ItemSupplier?: ItemSupplierCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutRawMaterialsOrderListInput = {
    supplier_id?: number
    supplier_name: string
    add1?: string | null
    add2?: string | null
    add3?: string | null
    phone_number1?: string | null
    phone_number2?: string | null
    phone_number3?: string | null
    email?: string | null
    primary_contact_name1?: string | null
    primary_contact_name2?: string | null
    primary_contact_name3?: string | null
    notes?: string | null
    FabricOrderList?: FabricOrderListUncheckedCreateNestedManyWithoutSupplierInput
    ItemSupplier?: ItemSupplierUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutRawMaterialsOrderListInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutRawMaterialsOrderListInput, SupplierUncheckedCreateWithoutRawMaterialsOrderListInput>
  }

  export type SupplierUpsertWithoutRawMaterialsOrderListInput = {
    update: XOR<SupplierUpdateWithoutRawMaterialsOrderListInput, SupplierUncheckedUpdateWithoutRawMaterialsOrderListInput>
    create: XOR<SupplierCreateWithoutRawMaterialsOrderListInput, SupplierUncheckedCreateWithoutRawMaterialsOrderListInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutRawMaterialsOrderListInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutRawMaterialsOrderListInput, SupplierUncheckedUpdateWithoutRawMaterialsOrderListInput>
  }

  export type SupplierUpdateWithoutRawMaterialsOrderListInput = {
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    FabricOrderList?: FabricOrderListUpdateManyWithoutSupplierNestedInput
    ItemSupplier?: ItemSupplierUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutRawMaterialsOrderListInput = {
    supplier_id?: IntFieldUpdateOperationsInput | number
    supplier_name?: StringFieldUpdateOperationsInput | string
    add1?: NullableStringFieldUpdateOperationsInput | string | null
    add2?: NullableStringFieldUpdateOperationsInput | string | null
    add3?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number1?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number2?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number3?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name1?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name2?: NullableStringFieldUpdateOperationsInput | string | null
    primary_contact_name3?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    FabricOrderList?: FabricOrderListUncheckedUpdateManyWithoutSupplierNestedInput
    ItemSupplier?: ItemSupplierUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type LogEntryCreateWithoutUserInput = {
    action: string
    timestamp?: Date | string
  }

  export type LogEntryUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    timestamp?: Date | string
  }

  export type LogEntryCreateOrConnectWithoutUserInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutUserInput, LogEntryUncheckedCreateWithoutUserInput>
  }

  export type LogEntryCreateManyUserInputEnvelope = {
    data: LogEntryCreateManyUserInput | LogEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: LogEntryWhereUniqueInput
    update: XOR<LogEntryUpdateWithoutUserInput, LogEntryUncheckedUpdateWithoutUserInput>
    create: XOR<LogEntryCreateWithoutUserInput, LogEntryUncheckedCreateWithoutUserInput>
  }

  export type LogEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: LogEntryWhereUniqueInput
    data: XOR<LogEntryUpdateWithoutUserInput, LogEntryUncheckedUpdateWithoutUserInput>
  }

  export type LogEntryUpdateManyWithWhereWithoutUserInput = {
    where: LogEntryScalarWhereInput
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type LogEntryScalarWhereInput = {
    AND?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
    OR?: LogEntryScalarWhereInput[]
    NOT?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
    id?: IntFilter<"LogEntry"> | number
    userId?: IntFilter<"LogEntry"> | number
    action?: StringFilter<"LogEntry"> | string
    timestamp?: DateTimeFilter<"LogEntry"> | Date | string
  }

  export type UserCreateWithoutLogsInput = {
    username: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    username: string
    password: string
    role: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateWithoutProductionInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: ItemsCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutProductionInput = {
    orderNo: string
    customer_id?: number | null
    date?: Date | string | null
    onote?: string | null
    items?: ItemsUncheckedCreateNestedManyWithoutOrderInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    JacketMeasurement?: JacketMeasurementUncheckedCreateNestedManyWithoutOrderInput
    PantMeasurement?: PantMeasurementUncheckedCreateNestedManyWithoutOrderInput
    ShirtMeasurement?: ShirtMeasurementUncheckedCreateNestedManyWithoutOrderInput
    OrderPhotos?: OrderPhotosUncheckedCreateNestedManyWithoutOrderInput
    tailors?: OrderTailorUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutProductionInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutProductionInput, OrdersUncheckedCreateWithoutProductionInput>
  }

  export type OrdersUpsertWithoutProductionInput = {
    update: XOR<OrdersUpdateWithoutProductionInput, OrdersUncheckedUpdateWithoutProductionInput>
    create: XOR<OrdersCreateWithoutProductionInput, OrdersUncheckedCreateWithoutProductionInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutProductionInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutProductionInput, OrdersUncheckedUpdateWithoutProductionInput>
  }

  export type OrdersUpdateWithoutProductionInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutProductionInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RackCreateManyLocationInput = {
    id?: number
    name: string
    capacity?: number
    current_utilization?: number
    createdAt?: Date | string
  }

  export type RackUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bunches?: BunchUpdateManyWithoutRackNestedInput
  }

  export type RackUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bunches?: BunchUncheckedUpdateManyWithoutRackNestedInput
  }

  export type RackUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    current_utilization?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BunchCreateManyRackInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type BunchUpdateWithoutRackInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventoryItemUpdateManyWithoutBunchNestedInput
  }

  export type BunchUncheckedUpdateWithoutRackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventoryItemUncheckedUpdateManyWithoutBunchNestedInput
  }

  export type BunchUncheckedUpdateManyWithoutRackInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyBunchInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    unit_id?: number | null
    quantity?: number | null
  }

  export type InventoryItemUpdateWithoutBunchInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: UnitUpdateOneWithoutItemsNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    movement_logs?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutBunchInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    movement_logs?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutBunchInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InventoryItemCreateManyUnitInput = {
    item_id: string
    item_name: string
    item_type: $Enums.InventoryItemType
    bunch_id?: number | null
    quantity?: number | null
  }

  export type InventoryItemUpdateWithoutUnitInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    bunch?: BunchUpdateOneWithoutItemsNestedInput
    suppliers?: ItemSupplierUpdateManyWithoutItemNestedInput
    movement_logs?: InventoryMovementUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutUnitInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    bunch_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    suppliers?: ItemSupplierUncheckedUpdateManyWithoutItemNestedInput
    movement_logs?: InventoryMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutUnitInput = {
    item_id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    item_type?: EnumInventoryItemTypeFieldUpdateOperationsInput | $Enums.InventoryItemType
    bunch_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ItemSupplierCreateManyItemInput = {
    id?: number
    supplier_id: number
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
  }

  export type InventoryMovementCreateManyItemInput = {
    id?: number
    type: $Enums.MovementType
    quantity: number
    note?: string | null
    moved_at?: Date | string
  }

  export type ItemSupplierUpdateWithoutItemInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutItemSupplierNestedInput
  }

  export type ItemSupplierUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSupplierUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier_id?: IntFieldUpdateOperationsInput | number
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutItemInput = {
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    moved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateManyCustomerInput = {
    orderNo: string
    date?: Date | string | null
    onote?: string | null
  }

  export type FinalJacketMeasurementCreateManyCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type FinalPantMeasurementCreateManyCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type FinalShirtMeasurementCreateManyCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type JacketMeasurementCreateManyCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type PantMeasurementCreateManyCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type ShirtMeasurementCreateManyCustomerInput = {
    measurement_id?: string
    orderNo?: string | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type OrdersUpdateWithoutCustomerInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutCustomerInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemsUncheckedUpdateManyWithoutOrderNestedInput
    FinalJacketMeasurement?: FinalJacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalPantMeasurement?: FinalPantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    FinalShirtMeasurement?: FinalShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    JacketMeasurement?: JacketMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    PantMeasurement?: PantMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    ShirtMeasurement?: ShirtMeasurementUncheckedUpdateManyWithoutOrderNestedInput
    OrderPhotos?: OrderPhotosUncheckedUpdateManyWithoutOrderNestedInput
    tailors?: OrderTailorUncheckedUpdateManyWithoutOrderNestedInput
    production?: OrderProductionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutCustomerInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    onote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalJacketMeasurementUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneWithoutFinalJacketMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_jacket_measurementNestedInput
  }

  export type FinalJacketMeasurementUncheckedUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_jacket_measurementNestedInput
  }

  export type FinalJacketMeasurementUncheckedUpdateManyWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalPantMeasurementUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneWithoutFinalPantMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_pant_measurementNestedInput
  }

  export type FinalPantMeasurementUncheckedUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_pant_measurementNestedInput
  }

  export type FinalPantMeasurementUncheckedUpdateManyWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalShirtMeasurementUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneWithoutFinalShirtMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_shirt_measurementNestedInput
  }

  export type FinalShirtMeasurementUncheckedUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_shirt_measurementNestedInput
  }

  export type FinalShirtMeasurementUncheckedUpdateManyWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JacketMeasurementUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneWithoutJacketMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutJacket_measurementNestedInput
  }

  export type JacketMeasurementUncheckedUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutJacket_measurementNestedInput
  }

  export type JacketMeasurementUncheckedUpdateManyWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PantMeasurementUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneWithoutPantMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutPant_measurementNestedInput
  }

  export type PantMeasurementUncheckedUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutPant_measurementNestedInput
  }

  export type PantMeasurementUncheckedUpdateManyWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShirtMeasurementUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneWithoutShirtMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutShirt_measurementNestedInput
  }

  export type ShirtMeasurementUncheckedUpdateWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutShirt_measurementNestedInput
  }

  export type ShirtMeasurementUncheckedUpdateManyWithoutCustomerInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricOrderListCreateManyFabricInput = {
    order_id?: number
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
    supplier_id?: number | null
  }

  export type ItemsCreateManyFabricInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsCreateManyLining_fabricInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type FabricOrderListUpdateWithoutFabricInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: SupplierUpdateOneWithoutFabricOrderListNestedInput
  }

  export type FabricOrderListUncheckedUpdateWithoutFabricInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FabricOrderListUncheckedUpdateManyWithoutFabricInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ItemsUpdateWithoutFabricInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutFabricInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutFabricInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUpdateWithoutLining_fabricInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutLining_fabricInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutLining_fabricInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyFinal_jacket_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateWithoutFinal_jacket_measurementInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutFinal_jacket_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutFinal_jacket_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyJacket_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateWithoutJacket_measurementInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutJacket_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutJacket_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyFinal_pant_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
  }

  export type ItemsUpdateWithoutFinal_pant_measurementInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutFinal_pant_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutFinal_pant_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyPant_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateWithoutPant_measurementInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutPant_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutPant_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyFinal_shirt_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateWithoutFinal_shirt_measurementInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutFinal_shirt_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutFinal_shirt_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyShirt_measurementInput = {
    item_id?: number
    orderNo?: string | null
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type ItemsUpdateWithoutShirt_measurementInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    order?: OrdersUpdateOneWithoutItemsNestedInput
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutShirt_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutShirt_measurementInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    orderNo?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsCreateManyOrderInput = {
    item_id?: number
    item_name?: string | null
    item_type?: $Enums.ItemType | null
    fabric_id?: number | null
    lining_fabric_id?: number | null
    jacket_measurement_id?: string | null
    shirt_measurement_id?: string | null
    pant_measurement_id?: string | null
    final_jacket_measurement_id?: string | null
    final_shirt_measurement_id?: string | null
    final_pant_measurement_id?: string | null
  }

  export type FinalJacketMeasurementCreateManyOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type FinalPantMeasurementCreateManyOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type FinalShirtMeasurementCreateManyOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type JacketMeasurementCreateManyOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    jacket_length?: string | null
    natural_length?: string | null
    back_length?: string | null
    x_back?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    waist_coat_length?: string | null
    sherwani_length?: string | null
    other_notes?: string | null
  }

  export type PantMeasurementCreateManyOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    inseem?: string | null
    waist?: string | null
    hips?: string | null
    bottom?: string | null
    knee?: string | null
    other_notes?: string | null
  }

  export type ShirtMeasurementCreateManyOrderInput = {
    measurement_id?: string
    customer_id?: number | null
    date?: Date | string | null
    length?: string | null
    half_shoulder?: string | null
    to_sleeve?: string | null
    chest?: string | null
    waist?: string | null
    collar?: string | null
    other_notes?: string | null
  }

  export type OrderPhotosCreateManyOrderInput = {
    photo_id?: number
    s3_key?: string | null
    uploaded_at?: Date | string
  }

  export type OrderTailorCreateManyOrderInput = {
    id?: number
    tailor_id: number
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
  }

  export type ItemsUpdateWithoutOrderInput = {
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric?: FabricUpdateOneWithoutItemsNestedInput
    lining_fabric?: FabricUpdateOneWithoutLiningItemsNestedInput
    jacket_measurement?: JacketMeasurementUpdateOneWithoutItemsNestedInput
    shirt_measurement?: ShirtMeasurementUpdateOneWithoutItemsNestedInput
    pant_measurement?: PantMeasurementUpdateOneWithoutItemsNestedInput
    final_jacket_measurement?: FinalJacketMeasurementUpdateOneWithoutItemsNestedInput
    final_shirt_measurement?: FinalShirtMeasurementUpdateOneWithoutItemsNestedInput
    final_pant_measurement?: FinalPantMeasurementUpdateOneWithoutItemsNestedInput
  }

  export type ItemsUncheckedUpdateWithoutOrderInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemsUncheckedUpdateManyWithoutOrderInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    item_type?: NullableEnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType | null
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    lining_fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_jacket_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_shirt_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
    final_pant_measurement_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalJacketMeasurementUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutMeasurementsNestedInput
    Items?: ItemsUpdateManyWithoutFinal_jacket_measurementNestedInput
  }

  export type FinalJacketMeasurementUncheckedUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_jacket_measurementNestedInput
  }

  export type FinalJacketMeasurementUncheckedUpdateManyWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalPantMeasurementUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutFinalPantMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_pant_measurementNestedInput
  }

  export type FinalPantMeasurementUncheckedUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_pant_measurementNestedInput
  }

  export type FinalPantMeasurementUncheckedUpdateManyWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalShirtMeasurementUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutFinalShirtMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutFinal_shirt_measurementNestedInput
  }

  export type FinalShirtMeasurementUncheckedUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutFinal_shirt_measurementNestedInput
  }

  export type FinalShirtMeasurementUncheckedUpdateManyWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JacketMeasurementUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutJacketMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutJacket_measurementNestedInput
  }

  export type JacketMeasurementUncheckedUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutJacket_measurementNestedInput
  }

  export type JacketMeasurementUncheckedUpdateManyWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jacket_length?: NullableStringFieldUpdateOperationsInput | string | null
    natural_length?: NullableStringFieldUpdateOperationsInput | string | null
    back_length?: NullableStringFieldUpdateOperationsInput | string | null
    x_back?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    waist_coat_length?: NullableStringFieldUpdateOperationsInput | string | null
    sherwani_length?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PantMeasurementUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutPantMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutPant_measurementNestedInput
  }

  export type PantMeasurementUncheckedUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutPant_measurementNestedInput
  }

  export type PantMeasurementUncheckedUpdateManyWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    inseem?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    hips?: NullableStringFieldUpdateOperationsInput | string | null
    bottom?: NullableStringFieldUpdateOperationsInput | string | null
    knee?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShirtMeasurementUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutShirtMeasurementNestedInput
    Items?: ItemsUpdateManyWithoutShirt_measurementNestedInput
  }

  export type ShirtMeasurementUncheckedUpdateWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
    Items?: ItemsUncheckedUpdateManyWithoutShirt_measurementNestedInput
  }

  export type ShirtMeasurementUncheckedUpdateManyWithoutOrderInput = {
    measurement_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    length?: NullableStringFieldUpdateOperationsInput | string | null
    half_shoulder?: NullableStringFieldUpdateOperationsInput | string | null
    to_sleeve?: NullableStringFieldUpdateOperationsInput | string | null
    chest?: NullableStringFieldUpdateOperationsInput | string | null
    waist?: NullableStringFieldUpdateOperationsInput | string | null
    collar?: NullableStringFieldUpdateOperationsInput | string | null
    other_notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPhotosUpdateWithoutOrderInput = {
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPhotosUncheckedUpdateWithoutOrderInput = {
    photo_id?: IntFieldUpdateOperationsInput | number
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderPhotosUncheckedUpdateManyWithoutOrderInput = {
    photo_id?: IntFieldUpdateOperationsInput | number
    s3_key?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTailorUpdateWithoutOrderInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tailor?: TailorUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderTailorUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    tailor_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderTailorUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    tailor_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricOrderListCreateManySupplierInput = {
    order_id?: number
    fabric_id?: number | null
    description?: string | null
    supplier_name?: string | null
    meters?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
    ordered_for?: string | null
  }

  export type RawMaterialsOrderListCreateManySupplierInput = {
    order_id?: number
    product_name?: string | null
    description?: string | null
    raw_material_code?: string | null
    color?: string | null
    supplier_name?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    ordered_date?: Date | string | null
  }

  export type ItemSupplierCreateManySupplierInput = {
    id?: number
    item_id: string
    price?: Decimal | DecimalJsLike | number | string | null
    added_on?: Date | string
  }

  export type FabricOrderListUpdateWithoutSupplierInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
    fabric?: FabricUpdateOneWithoutFabricOrdersNestedInput
  }

  export type FabricOrderListUncheckedUpdateWithoutSupplierInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FabricOrderListUncheckedUpdateManyWithoutSupplierInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    fabric_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    meters?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ordered_for?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RawMaterialsOrderListUpdateWithoutSupplierInput = {
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RawMaterialsOrderListUncheckedUpdateWithoutSupplierInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RawMaterialsOrderListUncheckedUpdateManyWithoutSupplierInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    raw_material_code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ordered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemSupplierUpdateWithoutSupplierInput = {
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type ItemSupplierUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemSupplierUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTailorCreateManyTailorInput = {
    id?: number
    orderNo: string
    assigned_at?: Date | string
    status?: string
    due_date?: Date | string | null
    notes?: string | null
  }

  export type OrderTailorUpdateWithoutTailorInput = {
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrdersUpdateOneRequiredWithoutTailorsNestedInput
  }

  export type OrderTailorUncheckedUpdateWithoutTailorInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderTailorUncheckedUpdateManyWithoutTailorInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    assigned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEntryCreateManyUserInput = {
    id?: number
    action: string
    timestamp?: Date | string
  }

  export type LogEntryUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}